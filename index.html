<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' https: data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https:; style-src 'self' 'unsafe-inline' https:; img-src 'self' data: https:; font-src 'self' https:; connect-src 'self' https:;"> -->
    <title>Omega Terminal v1.5.9 - Complete Interface</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js" type="application/javascript"></script>
    <script src="https://cdn.jsdelivr.net/npm/eth-crypto@2.1.2/dist/lib.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.93.1/lib/index.iife.min.js"></script>
    <link rel="stylesheet" href="styles/gui-themes.css">
    <script>
        // VERSION CHECK - This should be visible in console if updated code is loaded
        console.log('🚀 OMEGA TERMINAL VERSION 1.5.9 LOADED');
        console.log('🚀 OMEGA TERMINAL v1.5.9 - READY');
        console.log('🚀 TIMESTAMP: ' + new Date().toISOString());
        
        // Force cache bust if needed for version 1.5.9
        if (!window.location.search.includes('v=159') && !window.location.search.includes('v=1.5.9')) {
            const timestamp = Date.now();
            const newUrl = window.location.href.split('?')[0] + '?v=159' + timestamp;
            console.log('🚀 OMEGA TERMINAL v1.5.9 - CACHE UPDATING');
            window.location.href = newUrl;
        }
        
        // Simple base58 decoder implementation
        const base58Chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
        const base58Lookup = {};
        for (let i = 0; i < base58Chars.length; i++) {
            base58Lookup[base58Chars[i]] = i;
        }
        
        function base58Decode(str) {
            let decoded = 0n;
            let multi = 1n;
            const base = 58n;
            
            for (let i = str.length - 1; i >= 0; i--) {
                const char = str[i];
                if (!(char in base58Lookup)) {
                    throw new Error('Invalid base58 character: ' + char);
                }
                decoded += BigInt(base58Lookup[char]) * multi;
                multi *= base;
            }
            
            // Convert to bytes
            const bytes = [];
            while (decoded > 0n) {
                bytes.unshift(Number(decoded % 256n));
                decoded = decoded / 256n;
            }
            
            // Handle leading zeros
            for (let i = 0; i < str.length && str[i] === '1'; i++) {
                bytes.unshift(0);
            }
            
            return new Uint8Array(bytes);
        }
    </script>
    <script>
        // Ensure Solana Web3 is accessible
        if (typeof window.solanaWeb3 === 'undefined' && typeof solanaWeb3 !== 'undefined') {
            window.solanaWeb3 = solanaWeb3;
        }
        
        // Completely prevent Phantom from taking over window.ethereum
        const originalEthereum = window.ethereum;
        if (originalEthereum && originalEthereum.isPhantom) {
            console.log('Phantom detected in early script - blocking immediately');
            // Store the original providers before Phantom takes over
            const providers = originalEthereum.providers || [];
            const metamaskProvider = providers.find(p => p.isMetaMask);
            
            if (metamaskProvider) {
                window.ethereum = metamaskProvider;
                console.log('MetaMask restored in early script');
            } else {
                window.ethereum = null;
                console.log('No MetaMask found - blocking all wallets');
            }
        }
        

        
        // Force MetaMask preference immediately after libraries load
        (function() {
            // More aggressive MetaMask forcing
            if (window.ethereum && window.ethereum.providers && Array.isArray(window.ethereum.providers)) {
                const metamaskProvider = window.ethereum.providers.find(p => p.isMetaMask);
                if (metamaskProvider) {
                    // Completely replace window.ethereum with MetaMask
                    window.ethereum = metamaskProvider;
                    console.log('MetaMask provider selected (early)');
                    
                    // Also set a flag to prevent other providers from taking over
                    window.ethereum._forceMetaMask = true;
                }
            }
            
            // Additional check: if we detect Phantom, try to find MetaMask again
            if (window.ethereum && window.ethereum.isPhantom && !window.ethereum._forceMetaMask) {
                console.log('Phantom detected, searching for MetaMask...');
                // Look for MetaMask in the original providers array
                if (window.ethereum.providers && Array.isArray(window.ethereum.providers)) {
                    const metamaskProvider = window.ethereum.providers.find(p => p.isMetaMask);
                    if (metamaskProvider) {
                        window.ethereum = metamaskProvider;
                        window.ethereum._forceMetaMask = true;
                        console.log('MetaMask found and forced after Phantom detection');
                    }
                }
            }
        })();
    </script>
            <style>
            /* iOS Message Animations */
            @keyframes slideInRight {
                from {
                    transform: translateX(100px);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }
            
            @keyframes slideInLeft {
                from {
                    transform: translateX(-100px);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            overflow: hidden;
        }

        .terminal {
            width: 100vw;
            height: 100dvh;
            padding: 20px;
            background: linear-gradient(135deg, #000 0%, #111111 100%);
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .terminal-header {
            border-bottom: 1px solid #ffffff;
            padding-bottom: 10px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .terminal-title {
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 15px #ffffff, 0 0 30px #ffffff;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .terminal-status {
            font-size: 12px;
            color: #cccccc;
        }

        .theme-toggle {
            width: 22px;
            height: 22px;
            background: transparent;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: pointer;
            margin-right: 0;
            margin-left: 0;
            display: inline-block;
            transition: border-color 0.2s;
            box-sizing: border-box;
            outline: none;
        }

        .theme-toggle:hover {
            border-color: #99ccff;
            background: rgba(255,255,255,0.05);
        }

        .ai-toggle {
            background: #ffffff;
            border: 1px solid #ffffff;
            border-radius: 4px;
            cursor: pointer;
            padding: 4px 8px;
            font-size: 12px;
            color: #333333;
            font-family: 'Courier New', monospace;
            transition: all 0.3s ease;
            outline: none;
        }

        .ai-toggle:hover {
            background: #f0f0f0;
            border-color: #f0f0f0;
            color: #000000;
        }

        .terminal-input-section {
            border-top: 1px solid #ffffff;
            padding-top: 10px;
            margin-top: auto;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #ffffff;
        }

        .terminal-content {
            flex: 1;
            overflow-y: auto;
            padding-right: 10px;
            margin-bottom: 20px;
            user-select: text !important;
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
        }

        /* Modal popup styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: linear-gradient(135deg, #000 0%, #111111 100%);
            border: 2px solid #ffffff;
            border-radius: 10px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
            animation: modalFadeIn 0.5s ease-out;
        }

        @keyframes modalFadeIn {
            from {
                opacity: 0;
                transform: scale(0.8) translateY(-20px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .modal-title {
            font-size: 24px;
            font-weight: bold;
            color: #ffffff;
            margin-bottom: 20px;
            text-shadow: 0 0 15px #ffffff;
            letter-spacing: 2px;
        }

        .modal-steps {
            text-align: left;
            margin: 20px 0;
        }

        .modal-step {
            font-size: 16px;
            color: #ffffff;
            margin: 15px 0;
            padding: 10px;
            border-left: 3px solid #33bbff;
            background: rgba(51, 187, 255, 0.1);
        }

        .modal-step-number {
            color: #33bbff;
            font-weight: bold;
            margin-right: 10px;
        }

        .modal-button {
            background: linear-gradient(135deg, #33bbff 0%, #0066cc 100%);
            border: none;
            color: white;
            padding: 12px 30px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .modal-button:hover {
            background: linear-gradient(135deg, #66ccff 0%, #0099ff 100%);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(51, 187, 255, 0.4);
        }

        .terminal-line {
            margin-bottom: 5px;
            word-wrap: break-word;
        }

        .prompt {
            color: #ffffff;
            font-weight: bold;
        }

        .command {
            color: #ffffff;
        }

        .output {
            color: #cccccc;
            margin-left: 20px;
            user-select: text !important;
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
        }

        .error {
            color: #ff6666;
        }

        .success {
            color: #ffffff;
        }

        .warning {
            color: #ffffcc;
        }

        .info {
            color: #99ccff;
        }

        .mining-status {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #ffffff;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #111111;
            border: 1px solid #ffffff;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffffff, #cccccc);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px #ffffff;
        }

        .input-line {
            display: flex;
            align-items: center;
            background: transparent;
        }

        .input-prompt {
            color: #ffffff;
            font-weight: bold;
            margin-right: 10px;
            font-size: 16px;
        }

        .input-field {
            background: transparent;
            border: none;
            color: transparent; /* Make text transparent */
            text-shadow: 0 0 0 #ffffff; /* Show text via shadow */
            font-family: 'Courier New', monospace;
            font-size: 16px;
            outline: none;
            flex: 1;
            padding: 5px;
            caret-color: transparent; /* Hide the blinking cursor */
            width: 100%; /* Extend full width */
            min-width: 400px; /* Minimum width */
        }

        .input-field::placeholder {
            color: #666666;
        }

        .cursor {
            animation: blink 1s infinite;
            color: #ffffff;
            font-size: 16px;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .mining-animation {
            display: inline-block;
            animation: mining-pulse 2s infinite;
        }

        @keyframes mining-pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #ffffff;
            padding: 10px;
            border-radius: 5px;
        }

        .stat-label {
            color: #cccccc;
            font-size: 12px;
        }

        .stat-value {
            color: #ffffff;
            font-size: 16px;
            font-weight: bold;
        }

        /* Boot Animation Styles */
        .boot-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-family: 'Courier New', monospace;
        }

        .omega-symbols {
            font-size: 48px;
            color: #ffffff;
            text-shadow: 0 0 20px #ffffff;
            margin-bottom: 20px;
            animation: omega-float 3s ease-in-out infinite;
        }

        .pickaxe {
            font-size: 36px;
            color: #ffcc00;
            text-shadow: 0 0 15px #ffcc00;
            animation: pickaxe-swing 2s ease-in-out infinite;
            margin-bottom: 30px;
        }

        .welcome-text {
            font-size: 24px;
            color: #ffffff;
            text-align: center;
            line-height: 1.5;
            text-shadow: 0 0 10px #ffffff;
        }

        .loading-dots {
            font-size: 18px;
            color: #cccccc;
            margin-top: 20px;
            animation: loading-pulse 1.5s ease-in-out infinite;
        }

        @keyframes omega-float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        @keyframes pickaxe-swing {
            0%, 100% { transform: rotate(-15deg); }
            50% { transform: rotate(15deg); }
        }

        @keyframes loading-pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        .hidden {
            display: none !important;
        }

        /* Light Theme Styles */
        .terminal.light-theme {
            background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);
            color: #000000;
        }

        .terminal.light-theme .terminal-header {
            border-bottom: 1px solid #000000;
        }

        .terminal.light-theme .terminal-title {
            color: #000000;
            text-shadow: 0 0 15px #000000, 0 0 30px #000000;
        }

        .terminal.light-theme .terminal-status {
            color: #333333;
        }

        .terminal.light-theme .theme-toggle {
            background: rgba(0, 0, 0, 0.1);
            border: 1px solid #000000;
            color: #000000;
        }

        .terminal.light-theme .theme-toggle:hover {
            background: rgba(0, 0, 0, 0.2);
        }

        .terminal.light-theme .terminal-input-section {
            border-top: 1px solid #000000;
            background: rgba(0, 0, 0, 0.05);
            border: 1px solid #000000;
        }

        .terminal.light-theme .prompt {
            color: #000000;
        }

        .terminal.light-theme .command {
            color: #000000;
        }

        .terminal.light-theme .output {
            color: #333333;
        }

        .terminal.light-theme .error {
            color: #cc0000;
        }

        .terminal.light-theme .success {
            color: #000000;
        }

        .terminal.light-theme .warning {
            color: #cc6600;
        }

        .terminal.light-theme .info {
            color: #0066cc;
        }

        .terminal.light-theme .input-prompt {
            color: #000000;
        }

        .terminal.light-theme .input-field {
            color: #000000;
        }

        .terminal.light-theme .input-field::placeholder {
            color: #666666;
        }

        .terminal.light-theme .cursor {
            color: #000000;
        }

        .terminal.light-theme .mining-status {
            background: rgba(0, 0, 0, 0.1);
            border: 1px solid #000000;
        }

        .terminal.light-theme .stat-box {
            background: rgba(0, 0, 0, 0.05);
            border: 1px solid #000000;
        }

        .terminal.light-theme .stat-label {
            color: #333333;
        }

        .terminal.light-theme .stat-value {
            color: #000000;
        }

        .output.error {
            color: #ff3333 !important;
            font-weight: bold !important;
        }

        /* --- FORCE RED AND BOLD FOR ERROR OUTPUT --- */
        .terminal-content .output.error,
        .output.error {
            color: #ff3333 !important;
            font-weight: bold !important;
        }

        .terminal-content, .output, .output.error, .output.success, .output.info, .output.warning,
        .terminal-content *, .output *, .output.error *, .output.success *, .output.info *, .output.warning * {
            user-select: text !important;
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
        }

        .terminal-line .copyable {
            cursor: pointer;
            text-decoration: underline;
            color: #00ff00;
            transition: all 0.3s ease;
        }
        
        .terminal-line .copyable:hover {
            color: #ffff00;
            text-shadow: 0 0 10px #ffff00;
        }
        
        .terminal-line .copyable:active {
            color: #ff0000;
        }

        body.theme-dark {
            background: #000;
            color: #fff;
        }
        body.theme-light {
            background: #fff;
            color: #111;
        }
        body.theme-matrix {
            background: #000;
            color: #00ff00;
        }
        body.theme-retro {
            background: #111;
            color: #39ff14;
        }
        .theme-matrix .terminal-header, .theme-retro .terminal-header {
            border-bottom: 1px solid #00ff00;
        }
        .theme-matrix .input-prompt, .theme-retro .input-prompt {
            color: #39ff14;
        }
        .theme-retro .input-prompt {
            color: orange;
        }

        /* Matrix Theme Styles */
        body.theme-matrix {
            background: #000 !important;
            color: #00ff00 !important;
        }
        body.theme-matrix .terminal {
            background: #000 !important;
            color: #00ff00 !important;
        }
        body.theme-matrix .terminal-header {
            border-bottom: 1px solid #00ff00 !important;
        }
        body.theme-matrix .prompt,
        body.theme-matrix .input-prompt {
            color: #00ff00 !important;
            font-weight: bold;
        }
        body.theme-matrix .command {
            color: #00ff00 !important;
        }
        body.theme-matrix .output {
            color: #00ff00 !important;
        }
        body.theme-matrix .error {
            color: #ff3333 !important;
        }
        body.theme-matrix .success {
            color: #00ff00 !important;
        }
        body.theme-matrix .warning {
            color: #ffff00 !important;
        }
        body.theme-matrix .info {
            color: #00ffff !important;
        }

        /* Retro Theme Styles */
        body.theme-retro {
            background: #181200 !important;
            color: #39ff14 !important;
        }
        body.theme-retro .terminal {
            background: #181200 !important;
            color: #39ff14 !important;
        }
        body.theme-retro .terminal-header {
            border-bottom: 1px solid #ffaa00 !important;
        }
        body.theme-retro .prompt,
        body.theme-retro .input-prompt {
            color: #ffaa00 !important;
            font-weight: bold;
        }
        body.theme-retro .command {
            color: #39ff14 !important;
        }
        body.theme-retro .output {
            color: #39ff14 !important;
        }
        body.theme-retro .error {
            color: #ff3333 !important;
        }
        body.theme-retro .success {
            color: #ffaa00 !important;
        }
        body.theme-retro .warning {
            color: #ffff00 !important;
        }
        body.theme-retro .info {
            color: #00ffff !important;
        }

        body.theme-retro .info {
            color: #00ffff !important;
        }

        /* PowerShell Theme Styles */
        body.theme-powershell {
            background: #012456 !important;
            color: #ffffff !important;
        }
        body.theme-powershell .terminal {
            background: #012456 !important;
            color: #ffffff !important;
        }
        body.theme-powershell .terminal-header {
            border-bottom: 1px solid #00bcf2 !important;
        }
        body.theme-powershell .prompt,
        body.theme-powershell .input-prompt {
            color: #f9f1a5 !important;
            font-weight: bold;
        }
        body.theme-powershell .command {
            color: #ffffff !important;
        }
        body.theme-powershell .output {
            color: #d7eaff !important;
        }
        body.theme-powershell .error {
            color: #ff3333 !important;
        }
        body.theme-powershell .success {
            color: #00bcf2 !important;
        }
        body.theme-powershell .warning {
            color: #f9f1a5 !important;
        }
        body.theme-powershell .info {
            color: #00bcf2 !important;
        }

        .omega-test-wallet-prompt {
            color: #fff !important;
            font-size: 1.5em !important;
            font-weight: bold;
            margin: 16px 0;
            display: block;
        }
    </style>
</head>
<body>
    <!-- Boot Animation -->
    <div class="boot-animation" id="bootAnimation">
        <div class="omega-symbols">Ω Ω Ω Ω Ω</div>
        <div class="pickaxe">⛏️</div>
        <div class="welcome-text">
            Welcome to Omega Terminal v1<br>
            <span style="font-size: 16px; color: #cccccc;">Type below to get started</span>
        </div>
        <div class="loading-dots">Loading...</div>
    </div>

    <div class="terminal" id="terminal" style="display: none;">
        <div class="terminal-header">
                            <div class="terminal-title">Omega Terminal v1.5.9</div>
            <div style="display: flex; align-items: center; gap: 18px; margin-left: auto;">
                <button class="ai-toggle" title="Toggle AI Mode" id="aiToggle">AI Mode (off)</button>
                <button class="theme-toggle" title="Toggle Theme"></button>
                <div class="terminal-status" id="connectionStatus">DISCONNECTED</div>
            </div>
        </div>
        <div class="tab-bar" id="tabBar" style="display: flex; align-items: center; background: #111; border-bottom: 1px solid #fff;">
            <div class="tab active" data-tab="0" style="padding: 8px 18px; cursor: pointer; border-right: 1px solid #333; color: #fff; font-weight: bold;">Terminal 1</div>
            <div id="addTabBtn" style="padding: 8px 18px; cursor: pointer; color: #00bcf2; font-size: 1.3em;">+</div>
        </div>
        
        <!-- Faucet Info Box -->
        <div id="faucetInfoBox" style="background: rgba(0, 153, 255, 0.10); border: 1px solid #99ccff; color: #99ccff; padding: 10px 16px; border-radius: 6px; margin: 0 0 12px 0; font-size: 15px;">
            <b>Note:</b> Each wallet can only claim from the faucet once every 24 hours.<br>
            If you try to claim again before the cooldown is over, the transaction will fail.
        </div>
        <div class="terminal-content" id="terminalContent"></div>
        <div class="terminal-input-section">
            <div class="input-line">
                <span class="input-prompt">root@omega-miner:~$</span>
                <input type="text" class="input-field" id="commandInput" placeholder="Enter command..." autocomplete="off">
                <span class="cursor">|</span>
            </div>
        </div>
    </div>

    <script>
        // API URLs for different services
          const RELAYER_URL = 'http://localhost:4000'; // Local relayer for mining/claims
          const OMEGA_API_URL = 'https://omeganetwork.co/api'; // Production API for ambassador data

        // Simplified ethers loading with fallback support
        function loadEthers() {
            return new Promise((resolve, reject) => {
                // Small delay to ensure CDN script has time to load
                setTimeout(() => {
                    console.log('Checking for ethers availability...');
                    
                    // Check if ethers is already loaded (CDN success)
                    if (typeof ethers !== 'undefined') {
                        console.log('Ethers loaded successfully from CDN');
                        resolve(ethers);
                        return;
                    }
                    
                    console.log('CDN ethers not loaded, trying additional CDN sources...');
                    
                    // Try multiple CDN sources
                    const cdnSources = [
                        'https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js',
                        'https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js'
                    ];
                    
                    let currentSource = 0;
                    
                    function tryNextSource() {
                        if (currentSource >= cdnSources.length) {
                            // All CDN sources failed, load fallback
                            console.log('All CDN sources failed, loading fallback ethers...');
                            loadEthersFallback();
                            resolve(ethers);
                            return;
                        }
                        
                        const script = document.createElement('script');
                        script.src = cdnSources[currentSource];
                        script.onload = () => {
                            if (typeof ethers !== 'undefined') {
                                console.log(`Ethers loaded successfully from: ${cdnSources[currentSource]}`);
                                resolve(ethers);
                            } else {
                                currentSource++;
                                tryNextSource();
                            }
                        };
                        script.onerror = () => {
                            console.warn(`Failed to load ethers from: ${cdnSources[currentSource]}`);
                            currentSource++;
                            tryNextSource();
                        };
                        document.head.appendChild(script);
                    }
                    
                    tryNextSource();
                }, 500); // 500ms delay to ensure CDN script has time to load
            });
        }

        // Fallback ethers implementation - only loads if all CDN sources fail
        function loadEthersFallback() {
            console.log('Loading ethers fallback...');
            window.ethers = {
                providers: {
                    Web3Provider: function(provider) {
                        this.provider = provider;
                        this.getSigner = () => ({ 
                            getAddress: () => Promise.resolve('0x0000000000000000000000000000000000000000'),
                            sendTransaction: () => Promise.reject(new Error('Fallback ethers - no real transactions'))
                        });
                        this.getGasPrice = () => Promise.resolve({ toString: () => '20000000000' });
                        this.getBalance = () => Promise.resolve({ isZero: () => true });
                        this.getTransactionCount = () => Promise.resolve(0);
                    }
                },
                Contract: function(address, abi, signer) {
                    this.address = address;
                    this.abi = abi;
                    this.signer = signer;
                    // Add basic contract methods
                    this.startMining = () => Promise.resolve({ wait: () => Promise.resolve() });
                    this.claimRewards = () => Promise.resolve({ wait: () => Promise.resolve() });
                },
                Wallet: {
                    createRandom: function() {
                        return {
                            address: '0x' + Math.random().toString(16).substr(2, 40),
                            privateKey: '0x' + Math.random().toString(16).substr(2, 64),
                            connect: function(provider) { return this; },
                            sendTransaction: function(tx) { 
                                return Promise.resolve({ 
                                    hash: '0x' + Math.random().toString(16).substr(2, 64),
                                    wait: () => Promise.resolve()
                                }); 
                            }
                        };
                    }
                },
                utils: {
                    formatEther: (wei) => (parseInt(wei) / 1e18).toString(),
                    parseEther: (ether) => (parseFloat(ether) * 1e18).toString(),
                    id: (text) => '0x' + Math.random().toString(16).substr(2, 64),
                    defaultAbiCoder: {
                        decode: () => ['0x0000000000000000000000000000000000000000', '1000000000000000000', '1']
                    },
                    hexDataSlice: (data, start) => data
                }
            };
            console.log('Ethers fallback loaded successfully');
        }

        class OmegaMinerTerminal {
            constructor() {
                        // VERSION CHECK - This should be visible in terminal if updated code is loaded
                        console.log('🚀 OMEGA TERMINAL CONSTRUCTOR VERSION 1.5.9');
                this.version = '1.5.9';
                this.tabs = [{ id: 0, name: 'Terminal 1', history: [], output: [] }];
                this.activeTab = 0;
                console.log('[DEBUG] OmegaMinerTerminal constructor called');
                if (window && window.terminal) {
                    console.log('[DEBUG] Previous terminal instance found, overwriting');
                }
                this.provider = null;
                this.signer = null;
                this.contract = null;
                this.isMining = false;
                this.miningInterval = null;
                this.currentNonce = 0;
                this.ethers = null;
                this.isDarkTheme = true; // Default to dark theme
                
                // Load saved theme preference
                const savedTheme = localStorage.getItem('omega-terminal-theme');
                if (savedTheme) {
                    this.isDarkTheme = savedTheme === 'dark';
                }
                
                // New mining system properties
                this.pendingClaimableBalance = 0;
                this.totalEarned = 0; // Track total earned during session
                this.waitingForContinueResponse = false;
                
                // Stress test properties
                this.isStressTesting = false;
                this.stressTestInterval = null;
                this.stressTestStats = {
                    walletsCreated: 0,
                    transactionsSent: 0,
                    successfulTxs: 0,
                    failedTxs: 0,
                    startTime: 0
                };
                this.stressWallet = null;
                this.stressNonce = 0;
                
                // Contract properties
                this.contractAddress = "0x54c731627f2d2b55267b53e604c869ab8e6a323b"; // SimpleMiner contract with claimTo
                this.faucetAddress = "0xf8e00f8cfaccf9b95f703642ec589d1c6ceee1a9"; // Update faucet contract address
                this.minerFaucetAddress = '0x1c4ffffcc804ba265f6cfccffb94d0ae28b36207'; // Deployed OmegaMinerFaucet contract
                this.contractABI = [
                    "function mineBlock(uint256 nonce, bytes32 solution) external",
                    "function claimRewards() external",
                    "function claimTo(address recipient) external",
                    "function getMinerInfo(address miner) external view returns (uint256 _totalMined, uint256 _lastMineTime, uint256 _pendingRewards)",
                    "function calculateReward(address miner, uint256 nonce, bytes32 solution) external view returns (uint256)",
                    "function cooldownPeriod() external view returns (uint256)",
                    "function totalRewardsDistributed() external view returns (uint256)",
                    "function owner() external view returns (address)",
                    "function setCooldownPeriod(uint256 _cooldown) external",
                    "function withdrawExcess() external",
                    "event BlockMined(address indexed miner, uint256 nonce, bytes32 solution, uint256 reward)",
                    "event RewardsClaimed(address indexed miner, uint256 amount)"
                ];
                this.faucetABI = [
                    {
                        "inputs": [],
                        "name": "claim",
                        "outputs": [],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    },
                    {
                        "inputs": [
                            { "internalType": "address", "name": "user", "type": "address" }
                        ],
                        "name": "getFaucetStatus",
                        "outputs": [
                            { "internalType": "bool", "name": "canClaimNow", "type": "bool" },
                            { "internalType": "uint256", "name": "lastClaim", "type": "uint256" },
                            { "internalType": "uint256", "name": "timeUntilNextClaim", "type": "uint256" },
                            { "internalType": "uint256", "name": "claimAmount", "type": "uint256" },
                            { "internalType": "uint256", "name": "faucetBalance", "type": "uint256" },
                            { "internalType": "uint256", "name": "totalClaims_", "type": "uint256" }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "emergencyWithdraw",
                        "outputs": [],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "stateMutability": "nonpayable",
                        "type": "constructor"
                    },
                    {
                        "anonymous": false,
                        "inputs": [
                            {
                                "indexed": false,
                                "internalType": "uint256",
                                "name": "amount",
                                "type": "uint256"
                            }
                        ],
                        "name": "FaucetRefilled",
                        "type": "event"
                    },
                    {
                        "inputs": [],
                        "name": "refillFaucet",
                        "outputs": [],
                        "stateMutability": "payable",
                        "type": "function"
                    },
                    {
                        "anonymous": false,
                        "inputs": [
                            {
                                "indexed": true,
                                "internalType": "address",
                                "name": "user",
                                "type": "address"
                            },
                            {
                                "indexed": false,
                                "internalType": "uint256",
                                "name": "amount",
                                "type": "uint256"
                            },
                            {
                                "indexed": false,
                                "internalType": "uint256",
                                "name": "timestamp",
                                "type": "uint256"
                            }
                        ],
                        "name": "TokensClaimed",
                        "type": "event"
                    },
                    {
                        "inputs": [],
                        "name": "withdrawFaucet",
                        "outputs": [],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    },
                    {
                        "stateMutability": "payable",
                        "type": "receive"
                    },
                    {
                        "inputs": [
                            {
                                "internalType": "address",
                                "name": "user",
                                "type": "address"
                            }
                        ],
                        "name": "canClaim",
                        "outputs": [
                            {
                                "internalType": "bool",
                                "name": "",
                                "type": "bool"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "CLAIM_AMOUNT",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "CLAIM_COOLDOWN",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "faucetBalance",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [
                            {
                                "internalType": "address",
                                "name": "user",
                                "type": "address"
                            }
                        ],
                        "name": "getClaimInfo",
                        "outputs": [
                            {
                                "internalType": "bool",
                                "name": "canClaimNow",
                                "type": "bool"
                            },
                            {
                                "internalType": "uint256",
                                "name": "lastClaim",
                                "type": "uint256"
                            },
                            {
                                "internalType": "uint256",
                                "name": "timeUntilNextClaim",
                                "type": "uint256"
                            },
                            {
                                "internalType": "uint256",
                                "name": "claimAmount",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "getFaucetBalance",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [
                            {
                                "internalType": "address",
                                "name": "user",
                                "type": "address"
                            }
                        ],
                        "name": "getTimeUntilNextClaim",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [
                            {
                                "internalType": "address",
                                "name": "",
                                "type": "address"
                            }
                        ],
                        "name": "lastClaimTime",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "totalClaims",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    }
                ];
                this.minerFaucetABI = [
                    {
                        "inputs": [],
                        "name": "mine",
                        "outputs": [],
                        "stateMutability": "payable",
                        "type": "function"
                    },
                    {
                        "inputs": [{"internalType": "address", "name": "", "type": "address"}],
                        "name": "totalMined",
                        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [{"internalType": "address", "name": "", "type": "address"}],
                        "name": "lastMineTime",
                        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                        "stateMutability": "view",
                        "type": "function"
                    }
                ];
                
                this.loadTheme();
                console.log('[DEBUG] Calling init() from constructor');
                this.init();

                // In the OmegaMinerTerminal class:
                // 1. Add DM prompt state variables to the constructor
                this.awaitingDMRecipient = false;
                this.awaitingDMMessage = false;
                this.tempDMRecipient = '';
                this.solanaAddress = null;
            }
            
            async init() {
                this.log('🚀 OMEGA TERMINAL v1.5.9 INITIALIZING', 'info');
                // Show boot animation first
                await this.showBootAnimation();
                // Always set up event listeners immediately after boot
                this.setupEventListeners();
                try {
                    this.ethers = await loadEthers();
                    const hasMetaMask = await this.isRealMetaMask();
                    let walletReady = false;
                    if (!hasMetaMask) {

                        this.log('Error checking wallet connection: MetaMask not detected', 'error');
                        this.logHtml('<span class="omega-test-wallet-prompt">Type "yes" to create an Omega Wallet or "import" to import existing wallet</span>', 'info');
                        let resolved = false;
                        while (!resolved) {

                            const input = await this.promptTerminalInput();
                            const choice = input.trim().toLowerCase();
                            if (choice === 'yes') {

                                // Set up a public RPC provider (Aurora mainnet as example)
                                const OMEGA_RPC_URL = 'https://0x4e454228.rpc.aurora-cloud.dev';
                                this.provider = new this.ethers.providers.JsonRpcProvider(OMEGA_RPC_URL);
                                this.sessionOmegaWallet = this.ethers.Wallet.createRandom();
                                this.signer = this.sessionOmegaWallet.connect(this.provider);
                                // Connect mining contract for session wallet
                                if (this.contractAddress && this.contractABI) {
                                    this.contract = new this.ethers.Contract(this.contractAddress, this.contractABI, this.signer);
                                    this.log('Mining contract connected for Omega Test Wallet.', 'success');
                                }
                                this.log('DEBUG: Omega wallet created and provider set', 'info');
                                this.logHtml('<span style="color:#ff3333;font-weight:bold;">This is currently in beta. We recommend you transfer any OMEGA tokens you receive to a MetaMask wallet for safekeeping. Do NOT use this wallet for large amounts or long-term storage.</span>', 'error');
                                const addr = this.sessionOmegaWallet.address;
                                const privKey = this.sessionOmegaWallet.privateKey;
                                this.logHtml(`<span style='color:#33bbff'>Omega Wallet Address:</span> <span style='color:#fff'>${addr}</span> <button onclick=\"navigator.clipboard.writeText('${addr}')\">Copy</button>`, 'info');
                                // Add private key reveal below address
                                this.logHtml(`<span style='color:#ff3333'>Omega Private Key [Never Share]:</span> <span id='privkey-reveal' style='color:#fff'><button onclick=\"this.style.display='none';document.getElementById('privkey-value').style.display='inline'\">Click to Reveal</button><span id='privkey-value' style='display:none;'>${privKey} <button onclick=\"navigator.clipboard.writeText('${privKey}')\">Copy</button></span></span>`, 'error');
                                this.log('Requesting funds for your Omega Test Wallet from the relayer...', 'info');
                                await fundOmegaWallet(addr);
                                this.log('If you do not see a funding confirmation above, please check your relayer or network connection.', 'info');
                                resolved = true;
                                walletReady = true;
                                this.log('Type "help" to get started', 'info');
                            } else if (choice === 'import') {

                                this.log('Enter your Omega Wallet private key:', 'info');
                                const privateKeyInput = await this.promptTerminalInput();
                                const privateKey = privateKeyInput.trim();
                                
                                try {
                                    // Validate private key format
                                    if (!privateKey.startsWith('0x') || privateKey.length !== 66) {
                                        throw new Error('Invalid private key format. Must start with 0x and be 66 characters long.');
                                    }
                                    
                                    // Set up RPC provider
                                    const OMEGA_RPC_URL = 'https://0x4e454228.rpc.aurora-cloud.dev';
                                    this.provider = new this.ethers.providers.JsonRpcProvider(OMEGA_RPC_URL);
                                    
                                    // Create wallet from private key
                                    this.sessionOmegaWallet = new this.ethers.Wallet(privateKey, this.provider);
                                    this.signer = this.sessionOmegaWallet;
                                    
                                    // Connect mining contract for imported wallet
                                    if (this.contractAddress && this.contractABI) {
                                        this.contract = new this.ethers.Contract(this.contractAddress, this.contractABI, this.signer);
                                        this.log('Mining contract connected for imported Omega Wallet.', 'success');
                                    }
                                    
                                    this.log('DEBUG: Omega wallet imported and provider set', 'info');
                                    this.logHtml('<span style="color:#ff3333;font-weight:bold;">This is currently in beta. We recommend you transfer any OMEGA tokens you receive to a MetaMask wallet for safekeeping. Do NOT use this wallet for large amounts or long-term storage.</span>', 'error');
                                    
                                    const addr = this.sessionOmegaWallet.address;
                                    this.logHtml(`<span style='color:#33bbff'>Imported Omega Wallet Address:</span> <span style='color:#fff'>${addr}</span> <button onclick=\"navigator.clipboard.writeText('${addr}')\">Copy</button>`, 'info');
                                    this.log('✅ Omega Wallet imported successfully!', 'success');
                                    
                                    resolved = true;
                                    walletReady = true;
                                    this.log('Type "help" to get started', 'info');
                                    
                                } catch (error) {
                                    this.log('❌ Failed to import wallet: ' + error.message, 'error');
                                    this.log('Please check your private key and try again.', 'warning');
                                }
                            } else {
                                this.log('DEBUG: Invalid input, prompting again', 'info');
                                console.log('[DEBUG] Invalid input, prompting again');
                                this.log('Please type "yes" to create an Omega Wallet or "import" to import existing wallet.', 'warning');
                            }
                        }
                    } else {

                        walletReady = true;
                    }
                    // Only proceed if a wallet is set up
                    if (walletReady) {
                        if (hasMetaMask) {
                            // Disable automatic wallet connection to prevent duplicate output
                            this.logHtml('<span style="color:#ffffff; font-size: 16px; font-weight: bold;">Type "connect" to get started</span>', 'output');
    
                            // this.checkWalletConnection(); // Disabled to prevent duplicate output
                        }
                    }
                } catch (error) {
                    this.log('DEBUG: Error in init() catch block', 'error');
                    console.log('[DEBUG] Error in init() catch block', error);
                    console.error('Failed to load ethers:', error);
                    this.log('Failed to load ethers library: ' + error.message, 'error');
                    this.log('Please check your internet connection and refresh the page', 'error');
                }
            }
            
            loadTheme() {
                const theme = localStorage.getItem('omega-terminal-theme') || 'dark';
                document.body.classList.remove('theme-dark', 'theme-light', 'theme-matrix', 'theme-retro');
                document.body.classList.add('theme-' + theme);
                const terminal = document.getElementById('terminal');
                if (terminal) {
                    terminal.classList.remove('theme-dark', 'theme-light', 'theme-matrix', 'theme-retro');
                    terminal.classList.add('theme-' + theme);
                }
                localStorage.setItem('omega-terminal-theme', theme);
                this.log(`Theme set to ${theme} mode`, 'success');
            }
            
            async showBootAnimation() {
                this.log('DEBUG: showBootAnimation() called', 'info');
                console.log('[DEBUG] showBootAnimation() called');
                return new Promise((resolve) => {
                    setTimeout(() => {
                        document.getElementById('bootAnimation').style.display = 'none';
                        document.getElementById('terminal').style.display = 'flex';
                        this.applyTheme();
                        // Clean startup - no debug messages
                        this.log('Type "connect" to get started', 'info');
                        resolve();
                    }, 1000); // Faster boot
                });
            }

            showGettingStartedModal() {
                // Create modal HTML
                const modalHTML = `
                    <div class="modal-overlay" id="gettingStartedModal">
                        <div class="modal-content">
                            <div class="modal-title">🚀 How To Get Started</div>
                            <div class="modal-steps">
                                <div class="modal-step">
                                    <span class="modal-step-number">1.</span>
                                    Type <span style="color:#33bbff;font-weight:bold;">connect</span> for MetaMask, <span style="color:#33bbff;font-weight:bold;">yes</span> for new Omega Wallet, or <span style="color:#33bbff;font-weight:bold;">import</span> for existing wallet
                                </div>
                                <div class="modal-step">
                                    <span class="modal-step-number">2.</span>
                                    Type <span style="color:#33bbff;font-weight:bold;">help</span> for a list of commands
                                </div>
                            </div>
                            <button class="modal-button" onclick="document.getElementById('gettingStartedModal').remove(); document.getElementById('commandInput').focus();">
                                Let's Get Started!
                            </button>
                        </div>
                    </div>
                `;
                
                // Add modal to page
                document.body.insertAdjacentHTML('beforeend', modalHTML);
                
                // Focus on the button for accessibility
                setTimeout(() => {
                    const button = document.querySelector('.modal-button');
                    if (button) button.focus();
                }, 100);
            }
            
            setupEventListeners() {
                const input = document.getElementById('commandInput');
                if (input) {
                    input.focus();
                    // Command history and autocomplete state
                    this.commandHistory = [];
                    this.historyIndex = -1;
                    this.lastInputValue = '';
                    this.availableCommands = [
                        'help', 'clear', 'connect', 'disconnect', 'balance', 'faucet', 'mine', 'claim', 'status', 'stats',
                        'send', 'ens', 'mixer', 'stress', 'stopstress', 'stressstats', 'theme', 'rickroll', 'fortune', 'matrix', 'hack', 'disco', 'stop', 'tab',
                        'email', 'inbox', 'dexscreener', 'geckoterminal', 'stock', 'alphakey', 'ds', 'cg', 'alpha', 'airdrop',
                        'solana', 'eclipse', 'hyperliquid', 'polymarket', 'magiceden', 'import', 'ambassador', 'profile', 'gui'
                    ];
                    input.addEventListener('keydown', (e) => {
                        // Up arrow: previous command
                        if (e.key === 'ArrowUp') {
                            if (this.commandHistory.length > 0) {
                                if (this.historyIndex === -1) {
                                    this.historyIndex = this.commandHistory.length - 1;
                                    this.lastInputValue = input.value;
                                } else if (this.historyIndex > 0) {
                                    this.historyIndex--;
                                }
                                input.value = this.commandHistory[this.historyIndex];
                                setTimeout(() => input.setSelectionRange(input.value.length, input.value.length), 0);
                            }
                            e.preventDefault();
                        }
                        // Down arrow: next command or clear
                        if (e.key === 'ArrowDown') {
                            if (this.commandHistory.length > 0 && this.historyIndex !== -1) {
                                if (this.historyIndex < this.commandHistory.length - 1) {
                                    this.historyIndex++;
                                    input.value = this.commandHistory[this.historyIndex];
                                } else {
                                    this.historyIndex = -1;
                                    input.value = this.lastInputValue || '';
                                }
                                setTimeout(() => input.setSelectionRange(input.value.length, input.value.length), 0);
                            }
                            e.preventDefault();
                        }
                        // Tab: autocomplete
                        if (e.key === 'Tab') {
                            e.preventDefault();
                            const val = input.value.trim();
                            if (!val) return;
                            const matches = this.availableCommands.filter(cmd => cmd.startsWith(val));
                            if (matches.length === 1) {
                                input.value = matches[0] + ' ';
                            } else if (matches.length > 1) {
                                this.logHtml('<span style="color:#cccccc">' + matches.join('    ') + '</span>', 'info');
                            }
                        }
                    });
                    input.addEventListener('keypress', async (e) => {
                        if (e.key === 'Enter') {
                            const val = input.value;
                            input.value = '';
                            if (this.awaitingPromptInput && this.promptResolver) {
                                const value = val.trim();
                                this.awaitingPromptInput = false;
                                this.promptResolver(value);
                                this.promptResolver = null;
                            } else {
                                if (val.trim()) {
                                    this.commandHistory.push(val.trim());
                                    if (this.commandHistory.length > 100) this.commandHistory.shift();
                                }
                                this.historyIndex = -1;
                                this.lastInputValue = '';
                                await this.executeCommand(val);
                            }
                        }
                        // Ctrl+C to stop stress test
                        if (e.key === 'c' && e.ctrlKey) {
                            // 'this' is not needed here, as isStressTesting is not used in this context
                        }
                    });
                    // Fallback: refocus input if user clicks anywhere in the terminal
                    document.getElementById('terminal').addEventListener('click', function() {
                        input.focus();
                    });
                }
                // Setup AI toggle
                const aiToggle = document.querySelector('.ai-toggle');
                if (aiToggle) {
                    aiToggle.addEventListener('click', () => {
                        this.toggleAIMode();
                    });
                }

                // Setup theme toggle
                const themeToggle = document.querySelector('.theme-toggle');
                if (themeToggle) {
                    themeToggle.addEventListener('click', () => {
                        this.toggleTheme();
                    });
                    // Remove emoji/text, just hollow circle
                    themeToggle.textContent = '';
                }

                // Setup tab system
                const addTabBtn = document.getElementById('addTabBtn');
                if (addTabBtn) {
                    addTabBtn.addEventListener('click', () => {
                        const newId = this.tabs.length;
                        this.tabs.push({ id: newId, name: `Terminal ${newId + 1}`, history: [], output: [] });
                        this.activeTab = newId;
                        this.renderTabs();
                        this.clearTerminalContent();
                    });
                }
            }
            
            async checkWalletConnection() {
                if (typeof window.ethereum !== 'undefined') {
                    try {
                        // Force MetaMask selection before checking accounts
                        if (window.ethereum.providers && Array.isArray(window.ethereum.providers)) {
                            const metamaskProvider = window.ethereum.providers.find(p => p.isMetaMask);
                            if (metamaskProvider) {
                                window.ethereum = metamaskProvider;
                                console.log('MetaMask provider forced in checkWalletConnection');
                            }
                        }
                        
                        // Check if we have a valid MetaMask provider after forcing
                        if (window.ethereum && window.ethereum.isMetaMask) {
                            const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                            if (accounts.length > 0) {
                                await this.connectWallet();
                            }
                        } else {
                            console.log('MetaMask not available after provider selection');
                        }
                    } catch (error) {
                        this.log('Error checking wallet connection: ' + error.message, 'error');
                    }
                }
            }
            
            async connectWallet() {
                try {
                    if (!this.ethers) {
                        this.log('Ethers library not loaded. Please refresh the page.', 'error');
                        return;
                    }

                    // Smart MetaMask detection and Phantom handling
                    let provider;
                    let providerName = 'Unknown';
                    
                    if (window.ethereum) {
                        // If we already have MetaMask selected, use it
                        if (window.ethereum.isMetaMask) {
                            provider = window.ethereum;
                            providerName = 'MetaMask';
                            this.log('✅ Using MetaMask provider', 'success');
                        }
                        // Check if we have multiple providers and can find MetaMask
                        else if (window.ethereum.providers && Array.isArray(window.ethereum.providers)) {
                            const metamaskProvider = window.ethereum.providers.find(p => p.isMetaMask);
                            if (metamaskProvider) {
                                // Force MetaMask
                                window.ethereum = metamaskProvider;
                                provider = metamaskProvider;
                                providerName = 'MetaMask';
                                this.log('✅ MetaMask provider found and forced', 'success');
                            } else if (window.ethereum.isPhantom) {
                                // Only Phantom available - reject
                                this.log('❌ Only Phantom EVM detected - blocking connection', 'error');
                                this.log('💡 Please install MetaMask for Omega network support', 'info');
                                return;
                            } else {
                                // Other provider - try to use it but warn
                                provider = window.ethereum;
                                providerName = 'Other';
                                this.log('⚠️ Using non-MetaMask provider - may not support Omega network', 'warning');
                            }
                        }
                        // Single provider case
                        else {
                            if (window.ethereum.isPhantom) {
                                this.log('❌ Phantom EVM detected - blocking connection', 'error');
                                this.log('💡 Please disable Phantom EVM or use MetaMask for Omega network', 'info');
                                return;
                            } else {
                                provider = window.ethereum;
                                providerName = window.ethereum.isMetaMask ? 'MetaMask' : 'Other';
                                if (!window.ethereum.isMetaMask) {
                                    this.log('⚠️ Using non-MetaMask provider - may not support Omega network', 'warning');
                                }
                            }
                        }
                    } else {
                        this.log('No EVM wallet found. Please install MetaMask.', 'error');
                        return;
                    }
                    
                    this.log(`🔗 Connecting to ${providerName}...`, 'info');

                    // Request account access
                    try {
                        await provider.request({ method: 'eth_requestAccounts' });
                        this.log('✅ Account access granted', 'success');
                    } catch (requestError) {
                        this.log('❌ Connection denied by user', 'error');
                        return;
                    }

                    this.provider = new this.ethers.providers.Web3Provider(provider);
                    this.signer = this.provider.getSigner();

                    this.log('🔍 Getting wallet address...', 'info');
                    const address = await this.signer.getAddress();
                    this.userAddress = address;
                    
                    // CRITICAL: Check if this is actually MetaMask by testing network switching
                    try {
                        const currentNetwork = await this.provider.getNetwork();
                        this.log(`🔍 Current network: Chain ID ${currentNetwork.chainId}`, 'info');
                        
                        // Try to switch to Omega network - this will fail with Phantom EVM
                        try {
                            await provider.request({
                                method: 'wallet_switchEthereumChain',
                                params: [{ chainId: '0x4e454228' }], // Omega chain ID
                            });
                            this.log('✅ Successfully switched to Omega network - this is MetaMask!', 'success');
                        } catch (switchError) {
                            if (switchError.code === 4902) {
                                // Chain not added, try to add it
                                try {
                                    const networkConfig = {
                                        chainId: '0x4e454228',
                                        chainName: 'Omega Network',
                                        nativeCurrency: { name: 'OMEGA', symbol: 'OMEGA', decimals: 18 },
                                        rpcUrls: ['https://0x4e454228.rpc.aurora-cloud.dev'],
                                        blockExplorerUrls: ['https://0x4e454228.explorer.aurora-cloud.dev/']
                                    };
                                    
                                    this.log('🔍 Adding network with config:', 'info');
                                    this.log(`   Chain ID: ${networkConfig.chainId} (${parseInt(networkConfig.chainId, 16)} decimal)`, 'info');
                                    this.log(`   RPC URL: ${networkConfig.rpcUrls[0]}`, 'info');
                                    this.log(`   Explorer: ${networkConfig.blockExplorerUrls[0]}`, 'info');
                                    
                                    // Debug: Log the exact request being sent
                                    console.log('[DEBUG] Sending wallet_addEthereumChain request:', {
                                        method: 'wallet_addEthereumChain',
                                        params: [networkConfig]
                                    });
                                    
                                    await provider.request({
                                        method: 'wallet_addEthereumChain',
                                        params: [networkConfig]
                                    });
                                    this.log('✅ Successfully added Omega network - this is MetaMask!', 'success');
                                } catch (addError) {
                                    this.log('❌ Failed to add Omega network - this might be Phantom EVM', 'error');
                                    this.log('💡 Phantom EVM does not support custom networks like Omega', 'info');
                                    return;
                                }
                            } else {
                                this.log('❌ Failed to switch to Omega network - this might be Phantom EVM', 'error');
                                this.log('💡 Phantom EVM does not support custom networks like Omega', 'info');
                                return;
                            }
                        }
                    } catch (networkError) {
                        this.log('❌ Failed to check network - this might be Phantom EVM', 'error');
                        return;
                    }

                    // Check if we're using fallback ethers (which would return 0x000... address)
                    if (address === '0x0000000000000000000000000000000000000000') {
                        this.log('⚠️ Using fallback ethers - real transactions not available', 'warning');
                        this.log('💡 Please check your internet connection and refresh the page', 'info');
                        return;
                    }

                    this.log(`✅ Wallet connected: ${address}`, 'success');
                    this.updateConnectionStatus('CONNECTED');

                    if (this.contractAddress !== '0x0000000000000000000000000000000000000000') {
                        this.contract = new this.ethers.Contract(this.contractAddress, this.contractABI, this.signer);
                        this.log('✅ Mining contract connected', 'success');
                    }

                } catch (error) {
                    console.error('Connect wallet error:', error);
                    this.log('❌ Failed to connect wallet: ' + error.message, 'error');
                    this.log('💡 Make sure MetaMask is unlocked and you approve the connection', 'info');
                }
            }
            
            async disconnectWallet() {
                try {
                    if (!this.signer) {
                        this.log('No wallet connected to disconnect.', 'warning');
                        return;
                    }
                    
                    // Get the address before disconnecting for the message
                    const address = await this.signer.getAddress();
                    
                    // Clear all wallet-related properties
                    this.provider = null;
                    this.signer = null;
                    this.contract = null;
                    this.pendingClaimableBalance = 0;
                    
                    this.log(`🔌 Wallet disconnected: ${address}`, 'success');
                    this.updateConnectionStatus('DISCONNECTED');
                    this.log('💡 Use "connect" command to reconnect your wallet', 'info');
                    
                } catch (error) {
                    console.error('Disconnect wallet error:', error);
                    this.log('❌ Error disconnecting wallet: ' + error.message, 'error');
                }
            }
            
            async executeCommand(command) {
                // Handle custom swap direction first!
                if (this.awaitingCustomSwapDirection) {
                    const dir = command.trim();
                    if (dir === '1') {
                        this.customSwapDirection = 1;
                        this.awaitingCustomSwapDirection = false;
                        this.awaitingCustomSwapAmount = true;
                        this.log(`Enter amount of SOL to swap (e.g. 0.001, you have X SOL):`, 'info');
                    } else if (dir === '2') {
                        this.customSwapDirection = 2;
                        this.awaitingCustomSwapDirection = false;
                        this.awaitingCustomSwapAmount = true;
                        this.log(`Enter amount of ${this.customSwapTokenSymbol} to swap (e.g. 1000, you have X):`, 'info');
                    } else {
                        this.log('Please type 1 or 2.', 'warning');
                    }
                    return;
                }
                if (this.awaitingCustomSwapAmount) {
                    const amtStr = command.trim();
                    this.awaitingCustomSwapAmount = false;
                    let amountLamports;
                    let fromMint, toMint;
                    if (this.customSwapDirection === 1) {
                        // SOL → Token
                        fromMint = 'So11111111111111111111111111111111111111112';
                        toMint = this.customSwapTokenMint;
                        amountLamports = Math.round(parseFloat(amtStr) * 1e9).toString();
                    } else {
                        // Token → SOL (assume 6 decimals for most SPL tokens)
                        fromMint = this.customSwapTokenMint;
                        toMint = 'So11111111111111111111111111111111111111112';
                        amountLamports = Math.round(parseFloat(amtStr) * 1e6).toString();
                    }
                    this.log(`Executing custom swap: ${amtStr} ${this.customSwapDirection === 1 ? 'SOL' : this.customSwapTokenSymbol}...`, 'info');
                    await this.executeSolanaSwap(amountLamports, fromMint, toMint);
                    this.customSwapTokenMint = null;
                    this.customSwapTokenSymbol = null;
                    this.customSwapDirection = null;
                    return;
                }
                if (this.awaitingPromptInput) return;
                
                // Profile registration input handling
                if (this.awaitingInput && this.inputType && this.inputType.startsWith('profile_')) {
                    await this.handleProfileRegistrationInput(command.trim());
                    return;
                }
                
                // At the top of executeCommand, before command parsing:
                if (this.awaitingDMRecipient) {
                    this.tempDMRecipient = command.trim();
                    this.awaitingDMRecipient = false;
                    this.awaitingDMMessage = true;
                    this.logHtml('<span style="color:#99ccff">Recipient:</span> <span style="color:#fff">' + this.tempDMRecipient + '</span>', 'info');
                    this.log('Enter your message:', 'info');
                    return;
                }
                if (this.awaitingDMMessage) {
                    const message = command.trim();
                    const recipient = this.tempDMRecipient;
                    this.awaitingDMMessage = false;
                    this.tempDMRecipient = '';
                    if (!recipient || !message) {
                        this.log('Recipient and message required.', 'error');
                        return;
                    }
                    this.logHtml('<span style="color:#99ccff">Message:</span> <span style="color:#fff">' + message + '</span>', 'info');
                    await this.sendDirectMessage(recipient, message);
                    this.log('✅ Email sent!', 'success');
                    return;
                }

                this.logCommand(command);
                // Hide faucet info box after first command
                try {
                    const infoBox = document.getElementById('faucetInfoBox');
                    if (infoBox && infoBox.style.display !== 'none') {
                        infoBox.style.display = 'none';
                    }
                } catch (e) {}
                const args = command.trim().split(/\s+/);
                const cmd = args[0].toLowerCase();
                
                // Debug logging
                

                if (cmd === 'email' && args[1] === 'clearkey') {
                    this.e2eePrivateKey = null;
                    this.log('E2EE private key cleared from memory.', 'success');
                        return;
                }

                // --- Handle awaiting input states before command parsing ---
                if (this.awaitingMixerDirectInput && args.length === 2) {
                    this.awaitingMixerDirectInput = false;
                    const privateKeyInput = args[0];
                    const amountStr = args[1];
                    try {
                        const mixerABI = [
                            "function deposit(bytes32 commitment) external payable"
                        ];
                        // Always use a JsonRpcProvider for direct private key flows
                        const OMEGA_RPC_URL = 'https://0x4e454228.rpc.aurora-cloud.dev';
                        const provider = new this.ethers.providers.JsonRpcProvider(OMEGA_RPC_URL);
                        const privateKey = privateKeyInput.startsWith('0x') ? privateKeyInput : '0x' + privateKeyInput;
                        const wallet = new this.ethers.Wallet(privateKey, provider);
                        // Debug: print wallet address
                        this.log(`Using wallet address: ${wallet.address}`, 'info');
                        // Debug: print provider network
                        const network = await provider.getNetwork();
                        this.log(`Provider network: ${network.name} (chainId: ${network.chainId})`, 'info');
                        // Debug: print wallet balance
                        const balance = await wallet.getBalance();
                        this.log(`Wallet balance: ${this.ethers.utils.formatEther(balance)} OMEGA`, 'info');
                        const mixerContract = new this.ethers.Contract('0xc57824b37a7fc769871075103c4dd807bfb3fd3e', mixerABI, wallet);
                        const depositAmount = this.ethers.utils.parseEther(amountStr);
                        const array = window.crypto.getRandomValues(new Uint8Array(32));
                        const secret = Array.from(array).map(b => b.toString(16).padStart(2, '0')).join('');
                        const commitment = this.ethers.utils.keccak256('0x' + secret);
                        this.logHtml(`1. Generated secret: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('${secret}').then(() => window.terminal.log('✅ Secret copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy secret', 'error'))\">${secret}</span>`, 'info');
                        this.log(`2. Commitment: ${commitment}`, 'info');
                        this.log(`3. Deposit amount: ${amountStr} OMEGA`, 'info');
                        this.log('4. Creating wallet and calling contract...', 'info');
                        const tx = await mixerContract.deposit(commitment, { value: depositAmount });
                        this.log(`✅ Deposit transaction submitted! Hash: ${tx.hash}`, 'success');
                        this.log('Waiting for confirmation...', 'info');
                        try {
                            const receipt = await tx.wait();
                            this.log(`✅ Deposit confirmed! Block: ${receipt.blockNumber}`, 'success');
                            this.log('Your funds are now in the mixer. Use your secret to withdraw later.', 'info');
                        } catch (err) {
                            this.log('⚠️ Transaction was submitted but confirmation could not be detected in time.', 'warning');
                            this.log('You can check the status manually on the block explorer:', 'info');
                            this.logHtml(`<a href=\"https://0x4e454228.explorer.aurora-cloud.dev/tx/${tx.hash}\" target=\"_blank\">${tx.hash}</a>`, 'info');
                        }
                    } catch (error) {
                        this.log(`❌ Deposit failed: ${error.message}`, 'error');
                        this.log('Make sure you have enough OMEGA and a valid private key.', 'info');
                    }
                        return;
                    }
                if (this.awaitingMixerDirectAmount && args.length === 1) {
                    this.awaitingMixerDirectAmount = false;
                    const amountStr = args[0];
                    try {
                        // Mixer contract ABI (updated for new contract)
                        const mixerABI = [
                            "function deposit(bytes32 commitment) external payable"
                        ];
                        const privateKey = this.storedPrivateKey.startsWith('0x') ? this.storedPrivateKey : '0x' + this.storedPrivateKey;
                        const wallet = new this.ethers.Wallet(privateKey, this.provider);
                        const mixerContract = new this.ethers.Contract('0xc57824b37a7fc769871075103c4dd807bfb3fd3e', mixerABI, wallet);
                        const depositAmount = this.ethers.utils.parseEther(amountStr);
                        // Generate secret and commitment
                        const array = window.crypto.getRandomValues(new Uint8Array(32));
                        const secret = Array.from(array).map(b => b.toString(16).padStart(2, '0')).join('');
                        const commitment = this.ethers.utils.keccak256('0x' + secret);
                        this.logHtml(`1. Generated secret: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('${secret}').then(() => window.terminal.log('✅ Secret copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy secret', 'error'))\">${secret}</span>`, 'info');
                        this.log(`2. Commitment: ${commitment}`, 'info');
                        this.log(`3. Deposit amount: ${amountStr} OMEGA`, 'info');
                        this.log('4. Creating wallet and calling contract...', 'info');
                        const tx = await mixerContract.deposit(commitment, { value: depositAmount });
                        this.log(`✅ Deposit transaction submitted! Hash: ${tx.hash}`, 'success');
                        this.log('Waiting for confirmation...', 'info');
                        try {
                            const receipt = await tx.wait();
                            this.log(`✅ Deposit confirmed! Block: ${receipt.blockNumber}`, 'success');
                            this.log('Your funds are now in the mixer. Use your secret to withdraw later.', 'info');
                        } catch (err) {
                            this.log('⚠️ Transaction was submitted but confirmation could not be detected in time.', 'warning');
                            this.log('You can check the status manually on the block explorer:', 'info');
                            this.logHtml(`<a href=\"https://0x4e454228.explorer.aurora-cloud.dev/tx/${tx.hash}\" target=\"_blank\">${tx.hash}</a>`, 'info');
                        }
                        // Clear stored private key
                        this.storedPrivateKey = null;
                    } catch (error) {
                        this.log(`❌ Deposit failed: ${error.message}`, 'error');
                        this.log('Make sure you have enough OMEGA and a valid private key.', 'info');
                        this.storedPrivateKey = null;
                    }
                    return;
                }
                if (this.awaitingPrivateKey && this.awaitingMixerWithdrawDirect && args.length === 1) {
                    // Withdraw-direct: received private key
                    this.awaitingPrivateKey = false;
                    this.awaitingMixerWithdrawDirect = false;
                    this.storedPrivateKey = args[0];
                    this.log('Now enter your secret and withdrawal address separated by a space:', 'info');
                    this.awaitingMixerWithdrawDirectParams = true;
                    return;
                }
                if (this.awaitingMixerWithdrawDirectParams && args.length === 2) {
                    // Withdraw-direct: received secret and address
                    this.awaitingMixerWithdrawDirectParams = false;
                    try {
                        this.log('=== Omega Mixer Withdraw (Direct) ===', 'info');
                        this.log('Withdrawing funds directly from contract...', 'info');
                        // Validate secret
                        let secretHex = args[0];
                        if (!secretHex.startsWith('0x')) secretHex = '0x' + secretHex;
                        if (secretHex.length !== 66) { // 2 for '0x' + 64 hex chars
                            this.log('❌ Secret must be 32 bytes (64 hex characters).', 'error');
                            this.storedPrivateKey = null;
                            return;
                        }
                        // Create wallet from private key (stored from previous step)
                        const privateKey = this.storedPrivateKey.startsWith('0x') ? this.storedPrivateKey : '0x' + this.storedPrivateKey;
                        const wallet = new this.ethers.Wallet(privateKey, this.provider);
                        // Mixer contract ABI
                        const mixerABI = [
                            "function withdraw(bytes32 secret, address to) external"
                        ];
                        const mixerContract = new this.ethers.Contract('0xc57824b37a7fc769871075103c4dd807bfb3fd3e', mixerABI, wallet);
                        const tx = await mixerContract.withdraw(secretHex, args[1]);
                        this.log(`✅ Withdrawal transaction submitted! Hash: ${tx.hash}`, 'success');
                        this.log('Waiting for confirmation...', 'info');
                        const receipt = await tx.wait();
                        this.log(`✅ Withdrawal confirmed! Block: ${receipt.blockNumber}`, 'success');
                        this.log(`✅ Funds withdrawn to: ${args[1]}`, 'success');
                        // Clear stored private key
                        this.storedPrivateKey = null;
                    } catch (error) {
                        this.log(`❌ Withdrawal failed: ${error.message}`, 'error');
                        this.log('Make sure you have a valid private key and the secret is correct.', 'info');
                        this.storedPrivateKey = null;
                    }
                    return;
                }
                
                // Handle custom swap input
                if (this.awaitingCustomSwap && args.length === 2) {
                    const amount = args[0];
                    const toMint = args[1];
                    await this.handleCustomSwapInput(amount, toMint);
                    return;
                }
                
                // --- End awaiting input checks ---

                // --- Handle command parsing ---
                switch (cmd) {
                    case 'connect':
    
                        await this.connectWallet();
                        break;
                    case 'disconnect':
                        this.disconnectWallet();
                        break;
                    case 'balance':
                        await this.showBalance();
                        break;
                    case 'theme':
                        this.setTheme(args[1]);
                        break;
                    case 'mine':
                        this.mine();
                        break;
                    case 'faucet':
                        if (args[1] === 'status') {
                            await this.showFaucetStatus();
                        } else {
                            this.faucetClaim();
                        }
                        break;
                    case 'status':
                        this.showStatus();
                        break;
                    case 'stats':
                        this.showStats();
                        break;
                    case 'send':
                        this.sendOmega(command);
                        break;
                    case 'clear':
                        this.clearTerminal();
                        break;
                    case 'help':
                        this.showHelp();
                        break;
                    case 'network':
                        await this.checkNetwork();
                        break;
                    case 'forceadd':
                        await this.forceAddNetwork();
                        break;
                    case 'rpccheck':
                        await this.checkRpcChainId();
                        break;
                    case 'rickroll':
                        this.rickroll();
                        break;
                    case 'fortune':
                        this.fortune();
                        break;
                    case 'matrix':
                        this.matrix();
                        break;
                    case 'hack':
                        this.hack();
                        break;
                    case 'disco':
                        this.disco();
                        break;
                    case 'sudo':
                        this.sudoMine();
                        break;
                    case 'fund':
                        this.fundMiningWallet(args[1]);
                        break;
                    case 'stress':
                        this.startStressTest();
                        break;
                    case 'stopstress':
                        this.stopStressTest();
                        break;
                    case 'stressstats':
                        this.showStressStats();
                        break;
                    case 'mixer':
                        if (args[1] === '-help') {
                            this.log('=== Omega Mixer Help ===', 'info');
                            this.log('The Omega Mixer allows you to privately send OMEGA tokens by breaking the on-chain link between sender and receiver.', 'info');
                            this.log('How it works:', 'info');
                            this.log('1. Use "mixer deposit" to generate a secret and commitment, then manually call the contract.', 'info');
                            this.log('2. Use "mixer deposit-execute" to generate secret and call contract via MetaMask.', 'info');
                            this.log('3. Use "mixer deposit-direct" to generate secret and call contract directly (requires private key).', 'info');
                            this.log('4. Wait for the mixing round to complete (more users = more privacy).', 'info');
                            this.log('5. Use "mixer withdraw" to prepare your withdrawal. Enter your secret and the new address you want to receive funds at.', 'info');
                            this.log('6. In MetaMask (or via a relayer), call the withdraw function on the mixer contract with your secret and new address.', 'info');
                            this.log('7. For maximum privacy, use a relayer to submit the withdrawal transaction.', 'info');
                            this.log('NEVER share your secret. Anyone with the secret can withdraw your funds!', 'warning');
                            this.log('WARNING: Using deposit-direct requires entering your private key. Use at your own risk!', 'warning');
                        } else if (args[1] === 'deposit') {
                            // Generate secret and commitment
                            const array = window.crypto.getRandomValues(new Uint8Array(32));
                            const secret = Array.from(array).map(b => b.toString(16).padStart(2, '0')).join('');
                            const commitment = this.ethers.utils.keccak256('0x' + secret);
                            this.log('=== Omega Mixer Deposit ===', 'info');
                            this.logHtml(`1. Save this secret for withdrawal: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('${secret}').then(() => window.terminal.log('✅ Secret copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy secret', 'error'))\">${secret}</span>`, 'info');
                            this.log(`2. Commitment (for deposit): ${commitment}`, 'info');
                            this.log(`3. In MetaMask, interact with the mixer contract:`, 'info');
                            this.logHtml(`   Contract: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('0xc57824b37a7fc769871075103c4dd807bfb3fd3e').then(() => window.terminal.log('✅ Address copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy address', 'error'))\">0xc57824b37a7fc769871075103c4dd807bfb3fd3e</span>`, 'info');
                            this.log(`   IMPORTANT: Do NOT send a plain transaction to this address!`, 'warning');
                            this.log(`   Instead, call the deposit function:`, 'info');
                            this.log(`   - Go to the contract in MetaMask`, 'info');
                            this.log(`   - Click "Write Contract"`, 'info');
                            this.log(`   - Find the "deposit" function`, 'info');
                            this.log(`   - Enter commitment: ${commitment}`, 'info');
                            this.log(`   - Set value to your desired OMEGA amount`, 'info');
                            this.log(`   - Submit the transaction`, 'info');
                            this.log('4. After mixing, use your secret to withdraw to a new address.', 'info');
                        } else if (args[1] === 'deposit-execute') {
                            // Generate secret and commitment, then prompt for amount
                            const array = window.crypto.getRandomValues(new Uint8Array(32));
                            const secret = Array.from(array).map(b => b.toString(16).padStart(2, '0')).join('');
                            const commitment = this.ethers.utils.keccak256('0x' + secret);
                            this.storedMixerSecret = secret;
                            this.storedMixerCommitment = commitment;
                            this.awaitingMixerExecuteAmount = true;
                            this.log('=== Omega Mixer Deposit (Auto-Execute) ===', 'info');
                            this.logHtml(`1. Generated secret: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('${secret}').then(() => window.terminal.log('✅ Secret copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy secret', 'error'))\">${secret}</span>`, 'info');
                            this.log(`2. Commitment: ${commitment}`, 'info');
                            this.log('3. Enter deposit amount in OMEGA (e.g. 0.1):', 'info');
                            return;
                        }
                        // Add handler for awaitingMixerExecuteAmount
                        if (this.awaitingMixerExecuteAmount && args.length === 1) {
                            this.awaitingMixerExecuteAmount = false;
                            const amountStr = args[0];
                            try {
                                const mixerABI = [
                                    "function deposit(bytes32 commitment) external payable"
                                ];
                                const mixerContract = new this.ethers.Contract('0xc57824b37a7fc769871075103c4dd807bfb3fd3e', mixerABI, this.provider.getSigner());
                                const depositAmount = this.ethers.utils.parseEther(amountStr);
                                const commitment = this.storedMixerCommitment;
                                const tx = await mixerContract.deposit(commitment, { value: depositAmount });
                                this.log(`✅ Deposit transaction submitted! Hash: ${tx.hash}`, 'success');
                                this.log('Waiting for confirmation...', 'info');
                                try {
                                    const receipt = await tx.wait();
                                    this.log(`✅ Deposit confirmed! Block: ${receipt.blockNumber}`, 'success');
                                    this.log('Your funds are now in the mixer. Use your secret to withdraw later.', 'info');
                                } catch (err) {
                                    this.log('⚠️ Transaction was submitted but confirmation could not be detected in time.', 'warning');
                                    this.log('You can check the status manually on the block explorer:', 'info');
                                    this.logHtml(`<a href=\"https://0x4e454228.explorer.aurora-cloud.dev/tx/${tx.hash}\" target=\"_blank\">${tx.hash}</a>`, 'info');
                                }
                                // Clear stored secret/commitment
                                this.storedMixerSecret = null;
                                this.storedMixerCommitment = null;
                            } catch (error) {
                                this.log(`❌ Deposit failed: ${error.message}`, 'error');
                                this.log('Make sure you have enough OMEGA in your wallet.', 'info');
                                this.storedMixerSecret = null;
                                this.storedMixerCommitment = null;
                            }
                            return;
                        }
                        else if (args[1] === 'deposit-direct') {
                            this.log('=== Omega Mixer Deposit (Direct) ===', 'warning');
                            this.log('WARNING: This will require your private key. Use at your own risk!', 'warning');
                            this.log('Enter your private key and deposit amount separated by a space (e.g. <privatekey> 0.1):', 'info');
                            this.awaitingMixerDirectInput = true;
                            return;
                        } else if (args[1] === 'withdraw') {
                            this.log('=== Omega Mixer Withdraw ===', 'info');
                            this.log('Enter your secret (hex) and withdrawal address separated by a space:', 'info');
                            this.awaitingMixerWithdraw = true;
                        } else if (this.awaitingMixerWithdraw && args.length === 3) {
                            // args[1] = secret, args[2] = to_address
                            this.awaitingMixerWithdraw = false;
                            this.log('=== Omega Mixer Withdraw ===', 'info');
                            this.log('In MetaMask (or via relayer), call the withdraw function on the mixer contract:', 'info');
                            this.logHtml('   Contract: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText(\'0xc57824b37a7fc769871075103c4dd807bfb3fd3e\').then(() => window.terminal.log(\'✅ Address copied to clipboard!\', \'success\')).catch(() => window.terminal.log(\'❌ Failed to copy address\', \'error\'))\">0xc57824b37a7fc769871075103c4dd807bfb3fd3e</span>', 'info');
                            this.log('   Function: withdraw(bytes32 secret, address to)', 'info');
                            this.log(`   Secret: ${args[1]}`, 'info');
                            this.log(`   To: ${args[2]}`, 'info');
                            this.log('You can use a relayer to submit this transaction for extra privacy.', 'info');
                        } else if (args[1] === 'withdraw-direct') {
                            this.log('=== Omega Mixer Withdraw (Direct) ===', 'warning');
                            this.log('WARNING: This will require your private key. Use at your own risk!', 'warning');
                            this.log('Enter your private key (without 0x prefix):', 'info');
                            this.awaitingPrivateKey = true;
                            this.awaitingMixerWithdrawDirect = true;
                        } else {
                            this.log('Usage: mixer deposit | mixer deposit-execute | mixer deposit-direct | mixer withdraw | mixer withdraw-direct | mixer -help', 'info');
                        }
                        break;
                    case 'claim':
                        await this.claim();
                        break;
                    case 'stop':
                        this.stopAll();
                        break;
                    case 'tab':
                        const newId = this.tabs.length;
                        this.tabs.push({ id: newId, name: `Terminal ${newId + 1}`, history: [], output: [] });
                        this.activeTab = newId;
                        this.renderTabs();
                        this.clearTerminalContent();
                        return;
                    case 'ens':
                        if (!args[1]) {
                            this.log('Usage: ens register <name> | ens resolve <name>', 'info');
                        break;
                        }
                        if (args[1] === 'register' && args[2]) {
                            if (!this.signer) {
                                this.log('Please connect your wallet first using: connect', 'error');
                        break;
                            }
                            const name = args[2];
                            this.log(`Registering ENS name: ${name}...`, 'info');
                            try {
                                const ens = this.getENSContract(this.signer);
                                const tx = await ens.register(name);
                                this.log(`✅ Registration transaction sent: ${tx.hash}`, 'success');
                                this.log('Waiting for confirmation...', 'info');
                                await tx.wait();
                                this.log(`✅ Name registered: ${name}`, 'success');
                            } catch (err) {
                                this.log(`❌ Registration failed: ${err.message}`, 'error');
                            }
                        break;
                        } else if (args[1] === 'resolve' && args[2]) {
                            const name = args[2];
                            this.log(`Resolving ENS name: ${name}...`, 'info');
                            try {
                                const ens = this.getENSContract();
                                const address = await ens.resolve(name);
                                if (address && address !== '0x0000000000000000000000000000000000000000') {
                                    this.logHtml(`✅ <b>${name}</b> resolves to <span class="copyable" onclick="navigator.clipboard.writeText('${address}').then(() => window.terminal.log('✅ Address copied!', 'success'))">${address}</span>`, 'success');
                                } else {
                                    this.log(`❌ Name not found: ${name}`, 'error');
                                }
                            } catch (err) {
                                this.log(`❌ Resolve failed: ${err.message}`, 'error');
                            }
                        break;
                        } else if (args[1] === 'search' && args[2]) {
                            const name = args[2];
                            this.log(`Searching for ENS name: ${name}...`, 'info');
                            try {
                                const ens = this.getENSContract();
                                const address = await ens.resolve(name);
                                if (address && address !== '0x0000000000000000000000000000000000000000') {
                                    this.logHtml(`✅ <b>${name}</b> is owned by <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('${address}').then(() => window.terminal.log('✅ Address copied!', 'success'))\">${address}</span>`, 'success');
                                } else {
                                    this.log(`❌ Name not found: ${name}`, 'error');
                                }
                            } catch (err) {
                                this.log(`❌ ENS search failed: ${err.message}`, 'error');
                            }
                        break;
                        } else {
                            this.log('Usage: ens register <name> | ens resolve <name>', 'info');
                        }
                        break;
                    case 'dm':
                        if (!args[1]) {
                            this.log('Usage: dm <recipient> <message>', 'info');
                        break;
                        }
                        if (args.length < 3) {
                            this.log('Usage: dm <recipient> <message>', 'info');
                        break;
                        }
                        const recipient = args[1];
                        const dmMessage = args.slice(2).join(' ');
                        await this.sendDirectMessage(recipient, dmMessage);
                        break;
                                    case 'inbox':
                case 'messages':
                    if (args[1] === 'all') {
                        await this.showInbox(true); // Show all messages
                    } else {
                        await this.showInbox(false); // Show limited messages
                    }
                        break;
                    case 'email':
                        this.awaitingDMRecipient = true;
                        this.awaitingDMMessage = false;
                        this.tempDMRecipient = '';
                        this.log('Enter recipient (address or ENS):', 'info');
                        break;
                    case 'dexscreener':
                        await this.handleDexScreenerCommand(args);
                        break;
                    case 'geckoterminal':
                        await this.handleGeckoTerminalCommand(args);
                        break;
                    case 'stock':
                        await this.handleStockCommand(args);
                        break;
                    case 'alphakey':
                        await this.handleAlphaKeyCommand(args);
                        break;
                    case 'ds':
                        await this.handleDexScreenerAlias(args);
                        break;
                    case 'cg':
                        await this.handleGeckoTerminalAlias(args);
                        break;
                    case 'alpha':
                        await this.handleAlphaAlias(args);
                        break;
                    case 'create':
                        await this.handleCreateCommand(args);
                        break;
                    case 'url':
                    case 'urls':
                        this.logHtml('Helpful URLs:', 'info');
                        this.logHtml('Gitbook: <a href="https://omega-6.gitbook.io/omega" target="_blank" style="color:#fff;">https://omega-6.gitbook.io/omega</a>', 'info');
                        this.logHtml('Block Explorer: <a href="https://0x4e454228.explorer.aurora-cloud.dev/" target="_blank" style="color:#fff;">https://0x4e454228.explorer.aurora-cloud.dev/</a>', 'info');
                        this.logHtml('Website: <a href="https://omeganetwork.co" target="_blank" style="color:#fff;">omeganetwork.co</a>', 'info');
                        break;
                    case 'airdrop':
                        this.airdrop();
                        break;
                    case 'solana':
                        if (args[1] === 'help') {
                            this.log('=== Solana/Jupiter Commands ===', 'info');
                            this.log('solana connect - Connect Phantom wallet', 'output');
                            this.log('solana search <query> - Search for Solana tokens', 'output');
                            this.log('solana quote <amount> <fromMint> <toMint> - Get swap quote', 'output');
                            this.log('solana swap - Open interactive swap interface', 'output');
                            this.log('solana swap <amount> <fromMint> <toMint> - Execute swap', 'output');
                            this.log('', 'output');
                            this.log('Examples:', 'output');
                            this.log('solana search bonk', 'output');
                            this.log('solana quote 1000000 DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263 So11111111111111111111111111111111111111112', 'output');
                            this.log('solana swap', 'output');
                            this.log('solana swap 1000000 DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263 So11111111111111111111111111111111111111112', 'output');
                            return;
                        }
                        if (args[1] === 'connect') {
                            if (window.solana && window.solana.isPhantom) {
                                try {
                                    const resp = await window.solana.connect();
                                    const address = resp.publicKey.toString();
                                    this.solanaAddress = address;
                                    // Fetch SOL balance using direct fetch to Helius
                                    try {
                                        const body = {
                                            "jsonrpc": "2.0",
                                            "id": 1,
                                            "method": "getBalance",
                                            "params": [address]
                                        };
                                        const res = await fetch('https://mainnet.helius-rpc.com/?api-key=94a04704-448e-45a8-82e5-8f4c63b25082', {
                                            method: 'POST',
                                            headers: { 'Content-Type': 'application/json' },
                                            body: JSON.stringify(body)
                                        });
                                        const data = await res.json();
                                        let sol = 'N/A';
                                        if (data && data.result && typeof data.result.value === 'number') {
                                            sol = data.result.value / 1e9;
                                        }
                                        this.logHtml(`<span style='color:#33bbff'>Phantom Wallet Connected:</span> <span style='color:#fff'>${address}</span> <button onclick=\"navigator.clipboard.writeText('${address}')\">Copy</button><br><span style='color:#99ff99'>Balance:</span> <b>${sol} SOL</b>`, 'success');
                                    } catch (err) {
                                        this.logHtml(`<span style='color:#33bbff'>Phantom Wallet Connected:</span> <span style='color:#fff'>${address}</span> <button onclick=\"navigator.clipboard.writeText('${address}')\">Copy</button><br><span style='color:#ff3333'>Failed to fetch balance</span>`, 'success');
                                    }
                                } catch (e) {
                                    this.log('User rejected the connection request.', 'error');
                                }
                            } else {
                                this.logHtml("<span style='color:#ff3333'>Phantom wallet not detected. <a href='https://phantom.app/download' target='_blank' style='color:#33bbff'>Install Phantom</a></span>", 'error');
                            }
                            return;
                        }
                        if (args[1] === 'search' && args[2]) {
                            const query = args.slice(2).join(' ');
                            this.log(`Searching Solana tokens for: ${query}`, 'info');
                            try {
                                const res = await fetch(`${RELAYER_URL}/jupiter/search?q=${encodeURIComponent(query)}`);
                                const data = await res.json();
                                if (Array.isArray(data) && data.length > 0) {
                                    data.forEach((token, idx) => {
                                        // Card-like top section: logo | name (symbol) | mint | price
                                        let cardTop = `<div style='display:flex;align-items:center;justify-content:space-between;gap:14px;margin-bottom:4px;'>`;
                                        // Left: logo, name, symbol, mint, price, volume, holders
                                        cardTop += `<div style='display:flex;align-items:center;gap:14px;'>`;
                                        if (token.logoURI || token.icon) {
                                            const logo = token.logoURI || token.icon;
                                            cardTop += `<img src='${logo}' alt='icon' style='width:40px;height:40px;border-radius:50%;background:#fff;padding:2px;'>`;
                                        }
                                        cardTop += `<div><span style='font-size:1.2em;font-weight:bold;'>${token.name || ''}</span> <span style='color:#99ccff;'>(${token.symbol || ''})</span><br>`;
                                        cardTop += `Mint: <span class='copyable' onclick=\"navigator.clipboard.writeText('${token.address || token.id}')\">${token.address || token.id}</span><br>`;
                                        if (token.usdPrice !== undefined) cardTop += `Price: <b>$${Number(token.usdPrice).toLocaleString(undefined, {maximumFractionDigits:8})}</b><br>`;
                                        if (token.volume24h !== undefined || token.stats24h?.buyVolume !== undefined || token.stats24h?.sellVolume !== undefined) {
                                            let vol = token.volume24h;
                                            if (vol === undefined && token.stats24h) {
                                                const buy = Number(token.stats24h.buyVolume || 0);
                                                const sell = Number(token.stats24h.sellVolume || 0);
                                                vol = buy + sell;
                                            }
                                            if (vol !== undefined) cardTop += `24h Volume: <b>$${Number(vol).toLocaleString(undefined, {maximumFractionDigits:2})}</b><br>`;
                                        }
                                        if (token.holderCount !== undefined) cardTop += `Holders: <b>${Number(token.holderCount).toLocaleString()}</b><br>`;
                                        cardTop += `</div></div>`;
                                        // Middle: audit and CEXes
                                        cardTop += `<div style='min-width:200px;text-align:center;'>`;
                                        if (token.audit) {
                                            cardTop += `<div style='margin-bottom:4px;'><b>Audit</b><br>`;
                                            if (token.audit.mintAuthorityDisabled !== undefined) cardTop += `Mint Authority: <b>${token.audit.mintAuthorityDisabled ? 'Disabled' : 'Enabled'}</b><br>`;
                                            if (token.audit.freezeAuthorityDisabled !== undefined) cardTop += `Freeze Authority: <b>${token.audit.freezeAuthorityDisabled ? 'Disabled' : 'Enabled'}</b><br>`;
                                            if (token.audit.topHoldersPercentage !== undefined) cardTop += `Top Holders: <b>${Number(token.audit.topHoldersPercentage).toLocaleString(undefined, {maximumFractionDigits:2})}%</b><br>`;
                                            cardTop += `</div>`;
                                        }
                                        if (token.cexes && Array.isArray(token.cexes) && token.cexes.length > 0) {
                                            cardTop += `<div><b>CEXs</b><br><span style='font-size:0.95em;'>${token.cexes.join(', ')}</span></div>`;
                                        }
                                        cardTop += `</div>`;
                                        // Right: mcap and fdv
                                        cardTop += `<div style='text-align:right;min-width:180px;'>`;
                                        if (token.mcap !== undefined) cardTop += `Market Cap:<br><b>$${Number(token.mcap).toLocaleString(undefined, {maximumFractionDigits:2})}</b><br>`;
                                        if (token.fdv !== undefined) cardTop += `FDV:<br><b>$${Number(token.fdv).toLocaleString(undefined, {maximumFractionDigits:2})}</b><br>`;
                                        cardTop += `</div>`;
                                        cardTop += `</div>`;
                                        
                                        // Add swap buttons section
                                        let swapSection = `<div style='margin-top:8px;padding:8px;background:rgba(0,255,0,0.1);border:1px solid #00ff00;border-radius:4px;'>`;
                                        swapSection += `<div style='font-weight:bold;margin-bottom:4px;'>Quick Swap Actions:</div>`;
                                        swapSection += `<div style='display:flex;gap:8px;flex-wrap:wrap;'>`;
                                        
                                        // Swap from SOL to this token (use 1 SOL = 1,000,000,000 lamports)
                                        swapSection += `<button onclick=\"window.terminal.executeSolanaSwap('1000000000', 'So11111111111111111111111111111111111111112', '${token.address || token.id}')\" style='background:#00ff00;color:#000;border:none;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:12px;'>Swap 1 SOL → ${token.symbol || 'Token'}</button>`;
                                        
                                        // Swap from this token to SOL (use 1,000,000 units; adjust decimals as needed)
                                        swapSection += `<button onclick=\"window.terminal.executeSolanaSwap('1000000', '${token.address || token.id}', 'So11111111111111111111111111111111111111112')\" style='background:#ff6600;color:#fff;border:none;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:12px;'>Swap 1M ${token.symbol || 'Token'} → SOL</button>`;
                                        
                                        // Custom swap button
                                        swapSection += `<button onclick=\"window.terminal.promptCustomSwap('${token.address || token.id}', '${token.symbol || 'Token'}')\" style='background:#0066ff;color:#fff;border:none;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:12px;'>Custom Swap</button>`;
                                        
                                        swapSection += `</div></div>`;
                                        
                                        this.logHtml(cardTop + swapSection, 'output');
                                        this.logHtml('<hr>', 'output');
                                    });
                                } else {
                                    this.logHtml('<span style="color:#ff3333">No results found.</span>', 'error');
                                }
                            } catch (e) {
                                this.log('Solana token search failed: ' + e.message, 'error');
                            }
                            return;
                        }
                        if (args[1] === 'quote' && args.length === 5) {
                            const amount = args[2];
                            const fromMint = args[3];
                            const toMint = args[4];
                            this.log(`Getting quote for ${amount} (mint: ${fromMint}) to (mint: ${toMint})`, 'info');
                            try {
                                const res = await fetch(`${RELAYER_URL}/jupiter/quote?amount=${encodeURIComponent(amount)}&fromMint=${encodeURIComponent(fromMint)}&toMint=${encodeURIComponent(toMint)}`);
                                const data = await res.json();
                                if (data && data.outAmount) {
                                    this.logHtml(`<b>Quote:</b> ${amount} → ${data.outAmount} (route: ${data.marketInfos?.map(m=>m.label).join(', ') || 'N/A'})`, 'success');
                                } else if (data && data.error) {
                                    this.logHtml(`<span style='color:#ff3333'>${data.error}</span>`, 'error');
                                } else {
                                    this.logHtml('<span style="color:#ff3333">No quote found.</span>', 'error');
                                }
                            } catch (e) {
                                this.log('Solana quote failed: ' + e.message, 'error');
                            }
                            return;
                        }
                        if (args[1] === 'swap' && args.length === 2) {
                            this.showSolanaSwapInterface();
                            return;
                        }
                        if (args[1] === 'swap' && args.length === 5) {
                            if (!this.solanaAddress) {
                                this.log('Please connect your Phantom wallet first using: solana connect', 'error');
                                return;
                            }
                            const amount = args[2];
                            const fromMint = args[3];
                            const toMint = args[4];
                            this.log(`Swapping ${amount} (mint: ${fromMint}) to (mint: ${toMint})`, 'info');
                            try {
                                const res = await fetch(`${RELAYER_URL}/jupiter/swap`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        inputMint: fromMint,
                                        outputMint: toMint,
                                        amount,
                                        userPublicKey: this.solanaAddress
                                    })
                                });
                                const data = await res.json();
                                this.log('DEBUG: Full relayer response: ' + JSON.stringify(data), 'info');
                                if (data && data.transaction) {
                                    // Ask Phantom to sign and send the transaction
                                    if (window.solana && window.solana.isPhantom) {
                                        try {
                                            const txBuf = Uint8Array.from(atob(data.transaction), c => c.charCodeAt(0));
                                            this.log('DEBUG: About to send transaction to Phantom', 'info');
                                            this.log('DEBUG: User address: ' + this.solanaAddress, 'info');
                                            this.log('DEBUG: Transaction buffer (base64): ' + data.transaction, 'info');
                                            this.log('DEBUG: Transaction buffer (Uint8Array length): ' + txBuf.length, 'info');
                                            let signed;
                                            if (window.solanaWeb3 && window.solanaWeb3.VersionedTransaction) {
                                                try {
                                                    const transaction = window.solanaWeb3.VersionedTransaction.deserialize(txBuf);
                                                    this.log('DEBUG: Deserialized VersionedTransaction:', 'info');
                                                    this.log(JSON.stringify(transaction), 'info');
                                                    signed = await window.solana.signAndSendTransaction(transaction);
                                                    this.log('DEBUG: Used VersionedTransaction object for signing.', 'info');
                                                } catch (err) {
                                                    this.log('DEBUG: Failed to deserialize VersionedTransaction, falling back to buffer. Error: ' + (err && err.message ? err.message : err), 'warning');
                                                    signed = await window.solana.signAndSendTransaction({ message: txBuf });
                                                    this.log('DEBUG: Used buffer for signing.', 'info');
                                                }
                                            } else {
                                                signed = await window.solana.signAndSendTransaction({ message: txBuf });
                                                this.log('DEBUG: Used buffer for signing (no VersionedTransaction available).', 'info');
                                            }
                                            this.log('DEBUG: Phantom signAndSendTransaction result: ' + JSON.stringify(signed), 'info');
                                            this.logHtml(`<b>Swap transaction sent!</b> Signature: <span class='copyable' onclick="navigator.clipboard.writeText('${signed.signature}')">${signed.signature}</span>`, 'success');
                                        } catch (e) {
                                            this.log('DEBUG: Error from Phantom signAndSendTransaction: ' + (e && e.message ? e.message : e), 'error');
                                            this.log('User rejected or failed to sign the swap transaction.', 'error');
                                        }
                                    } else {
                                        this.log('Phantom wallet not available for signing.', 'error');
                                    }
                                } else if (data && data.error) {
                                    this.logHtml(`<span style='color:#ff3333'>${data.error}</span>`, 'error');
                                } else {
                                    this.logHtml('<span style="color:#ff3333">Swap failed.</span>', 'error');
                                }
                            } catch (e) {
                                this.log('Solana swap failed: ' + e.message, 'error');
                            }
                            return;
                        }
                    case 'near':
                        this.log('Near Intents command detected!', 'info');
                        
                        // near-tokens
                        if (args[1] === 'tokens') {
                            this.log('Fetching Near Intents supported tokens...', 'info');
                            try {
                                const response = await fetch('https://1click.chaindefuser.com/v0/tokens');
                                if (!response.ok) {
                                    this.log(`Failed to fetch tokens: HTTP ${response.status}`, 'error');
                                    return;
                                }
                                
                                const tokens = await response.json();
                                let html = `<b>Near Intents Supported Tokens (${tokens.length} total):</b><br>`;
                                html += `<table style='width:100%;font-size:0.9em;'><tr><th>Symbol</th><th>Blockchain</th><th>Asset ID</th><th>Price (USD)</th><th>Decimals</th></tr>`;
                                
                                tokens.forEach(token => {
                                    html += `<tr><td>${token.symbol}</td><td>${token.blockchain}</td><td>${token.assetId}</td><td>$${token.price}</td><td>${token.decimals}</td></tr>`;
                                });
                                
                                html += `</table>`;
                                this.logHtml(html, 'output');
                                
                            } catch (e) {
                                this.log('Failed to fetch Near Intents tokens: ' + e.message, 'error');
                            }
                            return;
                        }
                        
                        // near-quote
                        if (args[1] === 'quote') {
                            if (args.length < 6) {
                                this.log('Usage: near quote <originAsset> <destinationAsset> <amount> <slippageBps> <recipient>', 'info');
                                this.log('Example: near quote "nep141:wrap.near" "nep141:sol-5ce3bf3a31af18be40ba30f721101b4341690186.omft.near" "1000000000000000000000000" 100 "your-recipient-address"', 'info');
                                return;
                            }
                            
                            const originAsset = args[2];
                            const destinationAsset = args[3];
                            const amount = args[4];
                            const slippageBps = parseInt(args[5]);
                            const recipient = args[6];
                            
                            this.log(`Getting Near Intents quote for ${amount} ${originAsset} → ${destinationAsset}...`, 'info');
                            
                            try {
                                const quotePayload = {
                                    dry: true, // Dry run for quote
                                    swapType: 'EXACT_INPUT',
                                    slippageTolerance: slippageBps,
                                    originAsset,
                                    depositType: 'ORIGIN_CHAIN',
                                    destinationAsset,
                                    amount,
                                    refundTo: recipient, // Use recipient as refund address for now
                                    refundType: 'ORIGIN_CHAIN',
                                    recipient,
                                    recipientType: 'DESTINATION_CHAIN',
                                    deadline: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(), // 24 hours from now
                                    quoteWaitingTimeMs: 3000
                                };
                                
                                const response = await fetch('https://1click.chaindefuser.com/v0/quote', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify(quotePayload)
                                });
                                
                                if (!response.ok) {
                                    const errorText = await response.text();
                                    this.log(`Quote failed: HTTP ${response.status}`, 'error');
                                    this.log(`Error details: ${errorText}`, 'error');
                                    return;
                                }
                                
                                const data = await response.json();
                                let html = `<b>Near Intents Quote:</b><br>`;
                                html += `Input: <b>${data.quote.amountInFormatted} ${originAsset}</b> ($${data.quote.amountInUsd})<br>`;
                                html += `Output: <b>${data.quote.amountOutFormatted} ${destinationAsset}</b> ($${data.quote.amountOutUsd})<br>`;
                                html += `Min Output: <b>${data.quote.minAmountOutFormatted} ${destinationAsset}</b><br>`;
                                html += `Slippage: <b>${slippageBps/100}%</b><br>`;
                                html += `Time Estimate: <b>${data.quote.timeEstimate} seconds</b><br>`;
                                html += `Deposit Address: <b>${data.quote.depositAddress}</b><br>`;
                                html += `Deadline: <b>${new Date(data.quote.deadline).toLocaleString()}</b><br>`;
                                this.logHtml(html, 'output');
                                
                            } catch (e) {
                                this.log(`Quote failed: ${e.message}`, 'error');
                            }
                            return;
                        }
                        
                        // near-swap
                        if (args[1] === 'swap') {
                            // Show interactive swap interface
                            this.showNearSwapInterface();
                            return;
                        }
                        
                        // near-status
                        if (args[1] === 'status') {
                            let depositAddress;
                            if (args[2]) {
                                depositAddress = args[2];
                            } else if (window.nearSwapInfo) {
                                depositAddress = window.nearSwapInfo.depositAddress;
                            } else {
                                this.log('Usage: near status <depositAddress>', 'info');
                                this.log('Or use: near status (if you have a recent swap)', 'info');
                                return;
                            }
                            
                            this.log(`Checking Near Intents swap status for: ${depositAddress}`, 'info');
                            
                            try {
                                const response = await fetch(`https://1click.chaindefuser.com/v0/status?depositAddress=${depositAddress}`);
                                
                                if (!response.ok) {
                                    if (response.status === 404) {
                                        this.log('Swap not found. Make sure the deposit address is correct.', 'warning');
                                    } else {
                                        const errorText = await response.text();
                                        this.log(`Status check failed: HTTP ${response.status}`, 'error');
                                        this.log(`Error details: ${errorText}`, 'error');
                                    }
                                    return;
                                }
                                
                                const data = await response.json();
                                let html = `<b>Near Intents Swap Status:</b><br>`;
                                html += `Status: <b>${data.status}</b><br>`;
                                html += `Updated: <b>${new Date(data.updatedAt).toLocaleString()}</b><br>`;
                                
                                if (data.swapDetails) {
                                    html += `<br><b>Swap Details:</b><br>`;
                                    html += `Input: <b>${data.swapDetails.amountInFormatted} ${data.quoteResponse.quoteRequest.originAsset}</b><br>`;
                                    html += `Output: <b>${data.swapDetails.amountOutFormatted} ${data.quoteResponse.quoteRequest.destinationAsset}</b><br>`;
                                    html += `Slippage: <b>${data.swapDetails.slippage/100}%</b><br>`;
                                    
                                    if (data.swapDetails.originChainTxHashes && data.swapDetails.originChainTxHashes.length > 0) {
                                        html += `<br><b>Origin Chain Transactions:</b><br>`;
                                        data.swapDetails.originChainTxHashes.forEach(tx => {
                                            html += `<a href="${tx.explorerUrl}" target="_blank">${tx.hash}</a><br>`;
                                        });
                                    }
                                    
                                    if (data.swapDetails.destinationChainTxHashes && data.swapDetails.destinationChainTxHashes.length > 0) {
                                        html += `<br><b>Destination Chain Transactions:</b><br>`;
                                        data.swapDetails.destinationChainTxHashes.forEach(tx => {
                                            html += `<a href="${tx.explorerUrl}" target="_blank">${tx.hash}</a><br>`;
                                        });
                                    }
                                    
                                    if (data.swapDetails.refundedAmount) {
                                        html += `<br><b>Refunded Amount:</b> ${data.swapDetails.refundedAmountFormatted}<br>`;
                                    }
                                }
                                
                                this.logHtml(html, 'output');
                                
                            } catch (e) {
                                this.log(`Status check failed: ${e.message}`, 'error');
                            }
                            return;
                        }
                        
                        // near help
                        if (args[1] === 'help') {
                            let html = `<b>Near Intents Commands:</b><br>`;
                            html += `<ul style='margin-left:1em;'>`;
                            html += `<li><b>near tokens</b> — List all supported tokens for cross-chain swaps</li>`;
                            html += `<li><b>near quote &lt;originAsset&gt; &lt;destinationAsset&gt; &lt;amount&gt; &lt;slippageBps&gt; &lt;recipient&gt;</b> — Get a quote for a cross-chain swap</li>`;
                            html += `<li><b>near swap</b> — Show interactive cross-chain swap interface</li>`;
                            html += `<li><b>near status [depositAddress]</b> — Check swap status (uses recent swap if no address provided)</li>`;
                            html += `<li><b>near help</b> — Show this help</li>`;
                            html += `</ul>`;
                            html += `<br><b>Examples:</b><br>`;
                            html += `<code>near quote "nep141:wrap.near" "nep141:sol-5ce3bf3a31af18be40ba30f721101b4341690186.omft.near" "1000000000000000000000000" 100 "your-address"</code><br>`;
                            html += `<code>near swap "nep141:wrap.near" "nep141:sol-5ce3bf3a31af18be40ba30f721101b4341690186.omft.near" "1000000000000000000000000" 100 "your-address"</code><br>`;
                            html += `<code>near status 0x123abc456def789</code><br>`;
                            this.logHtml(html, 'output');
                            return;
                        }
                        
                        // Default Near help
                        this.log('Near Intents commands: tokens | quote | swap | status | help', 'info');
                        return;
                        
                    case 'eclipse':
                        this.log('Eclipse command detected!', 'info');
                        if (args[1] === '-help' || args[1] === 'help') {
                            let html = `<b>Eclipse (SVM) Commands:</b><br>`;
                            html += `<ul style='margin-left:1em;'>`;
                            html += `<li><b>eclipse gen-wallet</b> — Generate a new Eclipse (SVM) wallet</li>`;
                            html += `<li><b>eclipse wallet-info</b> — Show current Eclipse wallet details</li>`;
                            html += `<li><b>eclipse balance</b> — Check Eclipse wallet balance</li>`;
                            html += `<li><b>eclipse swap &lt;inputMint&gt; &lt;outputMint&gt; &lt;amount&gt; &lt;slippageBps&gt;</b> — Execute a swap on Solar DEX</li>`;
                            html += `<li><b>eclipse quote &lt;inputMint&gt; &lt;outputMint&gt; &lt;amount&gt; &lt;slippageBps&gt;</b> — Get swap quote without executing</li>`;
                            html += `<li><b>eclipse tokens</b> — List available tokens on Eclipse</li>`;
                            html += `<li><b>eclipse price &lt;mint&gt;</b> — Get token price from Solar DEX</li>`;
                            html += `</ul>`;
                            html += `<br><b>Examples:</b><br>`;
                            html += `<code>eclipse swap So11111111111111111111111111111111111111112 CwrZKtPiZJrAK3tTjNPP22rD9VzeoxQv8iHd6EeyNoze 0.1 100</code><br>`;
                            html += `<code>eclipse quote So11111111111111111111111111111111111111112 CwrZKtPiZJrAK3tTjNPP22rD9VzeoxQv8iHd6EeyNoze 0.1 100</code><br>`;
                            html += `<code>eclipse price CwrZKtPiZJrAK3tTjNPP22rD9VzeoxQv8iHd6EeyNoze</code><br>`;
                            html += `<br><b>Note:</b> Slippage is in basis points (100 = 1%, 50 = 0.5%)<br>`;
                            this.logHtml(html, 'output');
                            return;
                        }
                        
                        // eclipse gen-wallet
                        if (args[1] === 'gen-wallet') {
                            if (!window.solanaWeb3) {
                                this.log('Solana Web3 library not loaded. Cannot generate Eclipse wallet.', 'error');
                                return;
                            }
                            
                            try {
                                // Generate Solana keypair
                                const keypair = window.solanaWeb3.Keypair.generate();
                                const publicKey = keypair.publicKey.toString();
                                const privateKey = Array.from(keypair.secretKey).map(b => b.toString(16).padStart(2, '0')).join('');
                                
                                // Store in session
                                window.eclipseWallet = { 
                                    publicKey, 
                                    privateKey, 
                                    keypair,
                                    network: 'Eclipse (SVM)',
                                    rpcUrl: 'https://mainnetbeta-rpc.eclipse.xyz'
                                };
                                
                                let html = `<b>New Eclipse (SVM) Wallet Generated!</b><br>`;
                                html += `<span style='color:#ff3333'>SECURITY WARNING: Save your private key securely. Anyone with this key can access your funds!</span><br>`;
                                html += `<b>Public Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${publicKey}')">${publicKey}</span><br>`;
                                html += `<b>Private Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${privateKey}')">${privateKey}</span><br>`;
                                html += `<b>Network:</b> Eclipse (SVM)<br>`;
                                html += `<b>RPC URL:</b> https://mainnetbeta-rpc.eclipse.xyz<br>`;
                                html += `<button onclick="(() => { const blob = new Blob(['Public Key: ${publicKey}\\nPrivate Key: ${privateKey}\\nNetwork: Eclipse (SVM)\\nRPC URL: https://mainnetbeta-rpc.eclipse.xyz'], {type: 'text/plain'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'eclipse-wallet.txt'; a.click(); setTimeout(() => URL.revokeObjectURL(url), 1000); })()">Download Wallet Info</button><br>`;
                                html += `<br>💡 Use this wallet with Backpack, Phantom, or any Solana wallet that supports Eclipse network.<br>`;
                                this.logHtml(html, 'output');
                                return;
                            } catch (e) {
                                this.log('Failed to generate Eclipse wallet: ' + e.message, 'error');
                                return;
                            }
                        }
                        
                        // eclipse wallet-info
                        if (args[1] === 'wallet-info') {
                            if (window.eclipseWallet && window.eclipseWallet.publicKey) {
                                let html = `<b>Current Eclipse (SVM) Wallet:</b><br>`;
                                html += `<b>Public Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.eclipseWallet.publicKey}')">${window.eclipseWallet.publicKey}</span><br>`;
                                html += `<b>Private Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.eclipseWallet.privateKey}')">${window.eclipseWallet.privateKey}</span><br>`;
                                html += `<b>Network:</b> ${window.eclipseWallet.network}<br>`;
                                html += `<b>RPC URL:</b> ${window.eclipseWallet.rpcUrl}<br>`;
                                this.logHtml(html, 'output');
                            } else {
                                this.log('No Eclipse wallet generated in this session. Use: eclipse gen-wallet', 'warning');
                            }
                            return;
                        }
                        
                        // eclipse balance
                        if (args[1] === 'balance') {
                            if (!window.eclipseWallet) {
                                this.log('No Eclipse wallet generated. Use: eclipse gen-wallet', 'warning');
                                return;
                            }
                            
                            try {
                                const connection = new window.solanaWeb3.Connection(window.eclipseWallet.rpcUrl, 'confirmed');
                                const publicKey = new window.solanaWeb3.PublicKey(window.eclipseWallet.publicKey);
                                const balance = await connection.getBalance(publicKey);
                                const balanceInSol = balance / window.solanaWeb3.LAMPORTS_PER_SOL;
                                
                                this.logHtml(`<b>Eclipse Wallet Balance:</b>`, 'output');
                                this.logHtml(`<b>Address:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.eclipseWallet.publicKey}')">${window.eclipseWallet.publicKey}</span>`, 'output');
                                this.logHtml(`<b>Balance:</b> <b>${balanceInSol.toFixed(9)} SOL</b>`, 'output');
                                this.logHtml(`<b>Network:</b> Eclipse (SVM)`, 'output');
                            } catch (e) {
                                this.log('Failed to fetch Eclipse wallet balance: ' + e.message, 'error');
                            }
                            return;
                        }
                        
                        // eclipse import-wallet
                        if (args[1] === 'import-wallet') {
                            if (!window.solanaWeb3) {
                                this.log('Solana Web3 library not loaded. Cannot import Eclipse wallet.', 'error');
                                return;
                            }
                            
                            if (args.length < 3) {
                                this.log('Usage: eclipse import-wallet <private_key>', 'info');
                                this.log('Example: eclipse import-wallet 1234567890abcdef...', 'info');
                                this.log('Note: Private key should be a 64-character hex string', 'info');
                                return;
                            }
                            
                            try {
                                const privateKeyInput = args[2];
                                let keypair;
                                
                                // Try to detect format and handle accordingly
                                this.log(`Debug: Private key length: ${privateKeyInput.length}`, 'info');
                                
                                if (/^[0-9a-fA-F]{64}$/.test(privateKeyInput)) {
                                    // Hex format (64 characters)
                                    const privateKeyBytes = new Uint8Array(privateKeyInput.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                                    keypair = window.solanaWeb3.Keypair.fromSecretKey(privateKeyBytes);
                                    this.log('✅ Detected hex format private key', 'success');
                                } else if (/^[1-9A-HJ-NP-Za-km-z]{80,88}$/.test(privateKeyInput)) {
                                    // Base58 format (80-88 characters) - standard Solana format
                                    this.log('✅ Base58 pattern matched, attempting decode...', 'success');
                                    try {
                                        // Use our custom base58 decoder
                                        this.log('Debug: Using custom base58 decoder', 'info');
                                        const privateKeyBytes = base58Decode(privateKeyInput);
                                        
                                        // Handle different private key formats
                                        if (privateKeyBytes.length === 32) {
                                            // 32 bytes: Just the private key
                                            this.log('Debug: Detected 32-byte private key format', 'info');
                                            keypair = window.solanaWeb3.Keypair.fromSecretKey(privateKeyBytes);
                                        } else if (privateKeyBytes.length === 64) {
                                            // 64 bytes: Private key + public key (keypair format)
                                            this.log('Debug: Detected 64-byte keypair format, using full keypair data', 'info');
                                            // Use the full 64-byte array directly - Solana expects this format
                                            keypair = window.solanaWeb3.Keypair.fromSecretKey(privateKeyBytes);
                                        } else {
                                            this.log(`❌ Invalid private key length: ${privateKeyBytes.length} bytes (expected 32 or 64)`, 'error');
                                            return;
                                        }
                                        this.log('✅ Detected base58 format private key', 'success');
                                    } catch (e) {
                                        this.log('❌ Invalid base58 private key format', 'error');
                                        this.log(`Debug: base58 decode error: ${e.message}`, 'error');
                                        return;
                                    }
                                } else {
                                    this.log('❌ Invalid private key format.', 'error');
                                    this.log(`Debug: Hex pattern match: ${/^[0-9a-fA-F]{64}$/.test(privateKeyInput)}`, 'info');
                                    this.log(`Debug: Base58 pattern match: ${/^[1-9A-HJ-NP-Za-km-z]{80,88}$/.test(privateKeyInput)}`, 'info');
                                    this.log('Supported formats:', 'info');
                                    this.log('- Hex: 64-character hex string', 'info');
                                    this.log('- Base58: 80-88 character base58 string (standard Solana format)', 'info');
                                    this.log('Example hex: eclipse import-wallet 1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef', 'info');
                                    this.log('Example base58: eclipse import-wallet 4dmKkXNHJm1RX4bqrLHBg4m5vMwSrERmyi6CgbdW54BL2ktHvH6zJpFGz7kq8r8WNz1E1LJHaFUztcJLdDFD5xUy', 'info');
                                    return;
                                }
                                const publicKey = keypair.publicKey.toString();
                                
                                // Store in session
                                window.eclipseWallet = { 
                                    publicKey, 
                                    privateKey: privateKeyInput, // Store the original input format
                                    keypair,
                                    network: 'Eclipse (SVM)',
                                    rpcUrl: 'https://mainnetbeta-rpc.eclipse.xyz'
                                };
                                
                                let html = `<b>Eclipse (SVM) Wallet Imported Successfully!</b><br>`;
                                html += `<span style='color:#ff3333'>SECURITY WARNING: Your private key is now stored in session memory!</span><br>`;
                                html += `<b>Public Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${publicKey}')">${publicKey}</span><br>`;
                                html += `<b>Network:</b> Eclipse (SVM)<br>`;
                                html += `<b>RPC URL:</b> https://mainnetbeta-rpc.eclipse.xyz<br>`;
                                html += `<br>✅ Wallet imported and ready to use!<br>`;
                                html += `<br>💡 Use <b>eclipse balance</b> to check your funds.<br>`;
                                this.logHtml(html, 'output');
                                return;
                            } catch (e) {
                                this.log('Failed to import Eclipse wallet: ' + e.message, 'error');
                                this.log('Make sure your private key is correct and in hex format.', 'info');
                                return;
                            }
                        }
                        
                        // eclipse swap
                        if (args[1] === 'swap') {
                            if (!window.eclipseWallet) {
                                this.log('No Eclipse wallet generated. Use: eclipse gen-wallet', 'warning');
                                return;
                            }
                            
                            // Show interactive swap interface
                            this.showEclipseSwapInterface();
                            return;
                        }
                        
                        // eclipse quote
                        if (args[1] === 'quote') {
                            if (!window.eclipseWallet) {
                                this.log('No Eclipse wallet generated. Use: eclipse gen-wallet', 'warning');
                                return;
                            }
                            
                            if (args.length < 5) {
                                this.log('Usage: eclipse quote <inputMint> <outputMint> <amount> <slippageBps>', 'info');
                                this.log('Example: eclipse quote So11111111111111111111111111111111111111112 CwrZKtPiZJrAK3tTjNPP22rD9VzeoxQv8iHd6EeyNoze 0.1 100', 'info');
                                return;
                            }
                            
                            const inputMint = args[2];
                            const outputMint = args[3];
                            const amount = parseFloat(args[4]);
                            const slippageBps = parseInt(args[5]);
                            
                            this.log(`Getting quote for ${amount} ${inputMint} → ${outputMint}...`, 'info');
                            
                            try {
                                // Ensure we have the correct SOL mint address
                                const solMintAddress = 'So11111111111111111111111111111111111111112';
                                const actualInputMint = inputMint === '11111111111111111111111111111111' ? solMintAddress : inputMint;
                                
                                // Get compute unit price from Solar API
                                let computeUnitPrice = 'auto';
                                try {
                                    const feeResponse = await fetch('https://api.solarstudios.co/main/auto-fee');
                                    if (feeResponse.ok) {
                                        const feeData = await feeResponse.json();
                                        computeUnitPrice = String(feeData.data.default.h); // Use high priority
                                        this.log(`Using compute unit price: ${computeUnitPrice}`, 'info');
                                    }
                                } catch (e) {
                                    this.log('Using default compute unit price', 'info');
                                }
                                
                                const quotePayload = {
                                    inputMint: actualInputMint,
                                    outputMint,
                                    amount: amount * 1e9, // Convert to lamports
                                    slippageBps,
                                    version: 'LEGACY',
                                    wallet: window.eclipseWallet.keypair.publicKey.toString(),
                                    computeUnitPriceMicroLamports: computeUnitPrice,
                                    wrapSol: actualInputMint === 'So11111111111111111111111111111111111111112' ? true : false
                                };
                                
                                this.log(`Quote payload: ${JSON.stringify(quotePayload)}`, 'info');
                                
                                // Build query parameters for GET request
                                const queryParams = new URLSearchParams({
                                    inputMint: actualInputMint,
                                    outputMint: outputMint,
                                    amount: (amount * 1e9).toString(),
                                    slippageBps: slippageBps.toString(),
                                    txVersion: 'LEGACY'
                                });
                                
                                const response = await fetch(`https://api.solarstudios.co/compute/swap-base-in?${queryParams.toString()}`, {
                                    method: 'GET',
                                    headers: { 'Content-Type': 'application/json' }
                                });
                                
                                if (!response.ok) {
                                    const errorText = await response.text();
                                    this.log(`Quote failed: HTTP ${response.status}`, 'error');
                                    this.log(`Error details: ${errorText}`, 'error');
                                    return;
                                }
                                
                                const data = await response.json();
                                let html = `<b>Eclipse Swap Quote:</b><br>`;
                                html += `Input: <b>${amount} ${inputMint}</b><br>`;
                                html += `Output: <b>${(data.outAmount / 1e9).toFixed(9)} ${outputMint}</b><br>`;
                                html += `Price Impact: <b>${data.priceImpactPct}%</b><br>`;
                                html += `Minimum Output: <b>${(data.otherAmountThreshold / 1e9).toFixed(9)} ${outputMint}</b><br>`;
                                html += `Slippage: <b>${slippageBps/100}%</b><br>`;
                                this.logHtml(html, 'output');
                                
                            } catch (e) {
                                this.log(`Quote failed: ${e.message}`, 'error');
                            }
                            return;
                        }
                        
                        // eclipse tokens
                        if (args[1] === 'tokens') {
                            this.log('Fetching Eclipse token lists...', 'info');
                            try {
                                // Fetch Solar tokens
                                this.log('Fetching Solar DEX tokens...', 'info');
                                const solarResponse = await fetch('https://api.solarstudios.co/mint/list');
                                let solarTokens = [];
                                if (solarResponse.ok) {
                                    const solarData = await solarResponse.json();
                                    if (solarData.success && solarData.data && solarData.data.mintList) {
                                        solarTokens = solarData.data.mintList;
                                    }
                                }
                                
                                // Fetch Deserialize tokens
                                this.log('Fetching Deserialize tokens...', 'info');
                                const deserializeResponse = await fetch('https://api.deserialize.xyz/tokenList');
                                let deserializeTokens = [];
                                if (deserializeResponse.ok) {
                                    const deserializeData = await deserializeResponse.json();
                                    if (deserializeData.data && Array.isArray(deserializeData.data)) {
                                        deserializeTokens = deserializeData.data;
                                    }
                                }
                                
                                // Merge tokens and remove duplicates
                                const allTokens = new Map();
                                
                                // Add Solar tokens
                                solarTokens.forEach(token => {
                                    allTokens.set(token.address, {
                                        address: token.address,
                                        symbol: token.symbol,
                                        name: token.name,
                                        decimals: token.decimals,
                                        source: 'Solar'
                                    });
                                });
                                
                                // Add Deserialize tokens (will override if duplicate address)
                                deserializeTokens.forEach(token => {
                                    allTokens.set(token.address, {
                                        address: token.address,
                                        symbol: token.metadata?.symbol || 'N/A',
                                        name: token.metadata?.name || 'N/A',
                                        decimals: token.decimals,
                                        source: allTokens.has(token.address) ? 'Both' : 'Deserialize'
                                    });
                                });
                                
                                const tokens = Array.from(allTokens.values());
                                
                                let html = `<b>Eclipse Tokens (${tokens.length} total):</b><br>`;
                                html += `<table style='width:100%;font-size:0.9em;'><tr><th>Symbol</th><th>Name</th><th>Mint Address</th><th>Source</th><th>Solar DEX</th><th>Deserialize Agg</th></tr>`;
                                
                                // Show all tokens
                                const displayTokens = tokens;
                                
                                // Fetch Solar prices for all tokens
                                this.log('Fetching Solar DEX prices...', 'info');
                                const mintAddresses = displayTokens.map(token => token.address).join(',');
                                const solarPriceResponse = await fetch(`https://api.solarstudios.co/mint/price?mints=${mintAddresses}`);
                                const solarPriceData = solarPriceResponse.ok ? await solarPriceResponse.json() : { data: {} };
                                
                                // Fetch Deserialize prices for all tokens
                                this.log('Fetching Deserialize prices...', 'info');
                                const deserializePrices = {};
                                
                                // Fetch prices one by one for Deserialize (since it doesn't support batch)
                                for (const token of displayTokens) {
                                    try {
                                        const deserializeResponse = await fetch(`https://api.deserialize.xyz/tokenPrice/${token.address}`);
                                        if (deserializeResponse.ok) {
                                            const deserializeData = await deserializeResponse.json();
                                            deserializePrices[token.address] = deserializeData.price;
                                        }
                                    } catch (e) {
                                        // Continue if one fails
                                    }
                                }
                                
                                displayTokens.forEach(token => {
                                    const solarPrice = solarPriceData.data?.[token.address];
                                    const deserializePrice = deserializePrices[token.address];
                                    
                                    const solarPriceDisplay = solarPrice ? `$${parseFloat(solarPrice).toFixed(6)}` : 'N/A';
                                    const deserializePriceDisplay = deserializePrice ? `$${parseFloat(deserializePrice).toFixed(6)}` : 'N/A';
                                    
                                    // Color code the source
                                    let sourceColor = '#ffffff';
                                    if (token.source === 'Solar') sourceColor = '#99ccff';
                                    if (token.source === 'Deserialize') sourceColor = '#ffcc99';
                                    if (token.source === 'Both') sourceColor = '#ccff99';
                                    
                                    html += `<tr><td>${token.symbol || 'N/A'}</td><td>${token.name || 'N/A'}</td><td style='font-size:0.8em;'>${token.address || 'N/A'}</td><td style='color:${sourceColor}'>${token.source}</td><td>${solarPriceDisplay}</td><td>${deserializePriceDisplay}</td></tr>`;
                                });
                                
                                // No need for "more tokens" message since we're showing all
                                
                                html += `</table>`;
                                this.logHtml(html, 'output');
                                
                            } catch (e) {
                                this.log(`Failed to fetch tokens: ${e.message}`, 'error');
                            }
                            return;
                        }
                        
                        // eclipse price
                        if (args[1] === 'price' && args[2]) {
                            const mint = args[2];
                            this.log(`Fetching price for ${mint}...`, 'info');
                            try {
                                const response = await fetch(`https://api.solarstudios.co/mint/price?mints=${mint}`);
                                if (!response.ok) {
                                    this.log('Failed to fetch price', 'error');
                                    return;
                                }
                                
                                const data = await response.json();
                                const price = data.data?.[mint];
                                
                                if (price) {
                                    this.log(`✅ Price: $${price}`, 'success');
                                } else {
                                    this.log('❌ Price not found', 'error');
                                }
                                
                            } catch (e) {
                                this.log(`Failed to fetch price: ${e.message}`, 'error');
                            }
                            return;
                        }
                        
                        // Default Eclipse help
                        this.log('Eclipse (SVM) commands: gen-wallet | import-wallet | wallet-info | balance | swap | quote | tokens | price | help', 'info');
                        this.log('Near Intents commands: near-tokens | near-quote | near-swap | near-status | help', 'info');
                        this.log('Solana Web3 available: ' + (window.solanaWeb3 ? 'Yes' : 'No'), 'info');
                        return;
                        
                    case 'hyperliquid':
                        if (args[1] === '-help' || args[1] === 'help') {
                            let html = `<b>Hyperliquid Commands:</b><br>`;
                            html += `<ul style='margin-left:1em;'>`;
                            html += `<li><b>hyperliquid perps</b> — List all perps with mark price and open interest</li>`;
                            html += `<li><b>hyperliquid perp &lt;COIN&gt;</b> — Show detailed info for a single perp (mark price, OI, funding, leverage, recent trades)</li>`;
                            html += `<li><b>hyperliquid funding &lt;COIN&gt;</b> — Show current and historical funding rates for a perp</li>`;
                            html += `<li><b>hyperliquid positions &lt;ADDRESS&gt;</b> — Show all open perp positions for a given address</li>`;
                            html += `<li><b>hyperliquid orderbook &lt;COIN&gt;</b> — Show top bids/asks for a perp</li>`;
                            html += `<li><b>hyperliquid trades &lt;COIN&gt;</b> — Show recent trades for a perp</li>`;
                            html += `<li><b>hyperliquid oi-cap</b> — Show perps at open interest cap</li>`;
                            html += `</ul>`;
                            this.logHtml(html, 'output');
                            return;
                        }
                        // 0. hyperliquid perps
                        if (args[1] === 'perps') {
                            this.log('Fetching Hyperliquid perps...', 'info');
                            try {
                                const res = await fetch('https://api.hyperliquid.xyz/info', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ type: 'metaAndAssetCtxs' })
                                });
                                const data = await res.json();
                                if (Array.isArray(data) && data.length === 2 && Array.isArray(data[0].universe) && Array.isArray(data[1])) {
                                    const universe = data[0].universe;
                                    const ctxs = data[1];
                                    let html = `<b>Hyperliquid Perps</b><br>`;
                                    html += `<table style='width:100%;font-size:0.95em;'><tr><th>Coin</th><th>Mark Price</th><th>Open Interest</th><th>24h Volume</th><th>Funding</th></tr>`;
                                    for (let i = 0; i < universe.length; ++i) {
                                        const meta = universe[i];
                                        const ctx = ctxs[i];
                                        html += `<tr><td><b>${meta.name}</b></td><td>${ctx.markPx}</td><td>${ctx.openInterest}</td><td>${ctx.dayNtlVlm}</td><td>${ctx.funding}</td></tr>`;
                                    }
                                    html += `</table>`;
                                    this.logHtml(html, 'output');
                                } else {
                                    this.log('Failed to parse Hyperliquid perps data.', 'error');
                                }
                            } catch (e) {
                                this.log('Failed to fetch Hyperliquid perps: ' + e.message, 'error');
                            }
                            return;
                        }
                        // 1. hyperliquid perp <COIN>
                        if (args[1] === 'perp' && args[2]) {
                            const coin = args[2].toUpperCase();
                            this.log(`Fetching Hyperliquid perp info for ${coin}...`, 'info');
                            try {
                                const res = await fetch('https://api.hyperliquid.xyz/info', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ type: 'metaAndAssetCtxs' })
                                });
                                const data = await res.json();
                                if (Array.isArray(data) && data.length === 2 && Array.isArray(data[0].universe) && Array.isArray(data[1])) {
                                    const universe = data[0].universe;
                                    const ctxs = data[1];
                                    const idx = universe.findIndex(x => x.name.toUpperCase() === coin);
                                    if (idx === -1) {
                                        this.log(`Perp ${coin} not found.`, 'error');
                                        return;
                                    }
                                    const meta = universe[idx];
                                    const ctx = ctxs[idx];
                                    let html = `<b>${coin} Perp</b><br>`;
                                    html += `Mark Price: <b>${ctx.markPx}</b><br>`;
                                    html += `Open Interest: <b>${ctx.openInterest}</b><br>`;
                                    html += `Funding: <b>${ctx.funding}</b><br>`;
                                    html += `Max Leverage: <b>${meta.maxLeverage}</b><br>`;
                                    html += `Size Decimals: <b>${meta.szDecimals}</b><br>`;
                                    html += `24h Volume: <b>${ctx.dayNtlVlm}</b><br>`;
                                    html += `Prev Day Price: <b>${ctx.prevDayPx}</b><br>`;
                                    html += `Premium: <b>${ctx.premium}</b><br>`;
                                    html += `<hr>`;
                                    // Recent trades
                                    html += `<b>Recent Trades:</b><br>`;
                                    const tradesRes = await fetch('https://api.hyperliquid.xyz/info', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ type: 'recentTrades', coin })
                                    });
                                    if (!tradesRes.ok) {
                                        const text = await tradesRes.text();
                                        this.log(`Failed to fetch trades: HTTP ${tradesRes.status} - ${text}`, 'error');
                                        return;
                                    }
                                    const trades = await tradesRes.json();
                                    if (Array.isArray(trades) && trades.length > 0) {
                                        html += `<table style='width:100%;font-size:0.95em;'><tr><th>Px</th><th>Sz</th><th>Side</th><th>Time</th></tr>`;
                                        for (let i = 0; i < Math.min(trades.length, 10); ++i) {
                                            const t = trades[i];
                                            html += `<tr><td>${t.px}</td><td>${t.sz}</td><td>${t.side}</td><td>${new Date(t.time).toLocaleTimeString()}</td></tr>`;
                                        }
                                        html += `</table>`;
                                    } else {
                                        html += 'No recent trades.';
                                    }
                                    this.logHtml(html, 'output');
                                } else {
                                    this.log('Failed to parse Hyperliquid perp data.', 'error');
                                }
                            } catch (e) {
                                this.log('Failed to fetch Hyperliquid perp info: ' + e.message, 'error');
                            }
                            return;
                        }
                        // 2. hyperliquid funding <COIN>
                        if (args[1] === 'funding' && args[2]) {
                            const coin = args[2].toUpperCase();
                            this.log(`Fetching Hyperliquid funding rates for ${coin}...`, 'info');
                            try {
                                const now = Date.now();
                                const weekAgo = now - 7 * 24 * 60 * 60 * 1000;
                                const res = await fetch('https://api.hyperliquid.xyz/info', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ type: 'fundingHistory', coin, startTime: weekAgo, endTime: now })
                                });
                                const data = await res.json();
                                if (Array.isArray(data) && data.length > 0) {
                                    let html = `<b>${coin} Funding Rates (last 7d):</b><br>`;
                                    html += `<table style='width:100%;font-size:0.95em;'><tr><th>Time</th><th>Funding Rate</th><th>Premium</th></tr>`;
                                    for (let i = 0; i < Math.min(data.length, 20); ++i) {
                                        const f = data[i];
                                        html += `<tr><td>${new Date(f.time).toLocaleString()}</td><td>${f.fundingRate}</td><td>${f.premium}</td></tr>`;
                                    }
                                    html += `</table>`;
                                    this.logHtml(html, 'output');
                                } else {
                                    this.log('No funding history found.', 'warning');
                                }
                            } catch (e) {
                                this.log('Failed to fetch funding history: ' + e.message, 'error');
                            }
                            return;
                        }
                        // 3. hyperliquid positions <ADDRESS>
                        if (args[1] === 'positions' && args[2]) {
                            const user = args[2];
                            this.log(`Fetching Hyperliquid perp positions for ${user}...`, 'info');
                            try {
                                const res = await fetch('https://api.hyperliquid.xyz/info', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ type: 'clearinghouseState', user })
                                });
                                const data = await res.json();
                                if (data && Array.isArray(data.assetPositions) && data.assetPositions.length > 0) {
                                    let html = `<b>Perp Positions for ${user}:</b><br>`;
                                    html += `<table style='width:100%;font-size:0.95em;'><tr><th>Coin</th><th>Sz</th><th>Entry Px</th><th>Leverage</th><th>Unrealized PnL</th><th>ROE</th></tr>`;
                                    for (const pos of data.assetPositions) {
                                        const p = pos.position;
                                        html += `<tr><td>${p.coin}</td><td>${p.szi}</td><td>${p.entryPx}</td><td>${p.leverage.value}x</td><td>${p.unrealizedPnl}</td><td>${(parseFloat(p.returnOnEquity) * 100).toFixed(2)}%</td></tr>`;
                                    }
                                    html += `</table>`;
                                    this.logHtml(html, 'output');
                                } else {
                                    this.log('No open perp positions found.', 'warning');
                                }
                            } catch (e) {
                                this.log('Failed to fetch perp positions: ' + e.message, 'error');
                            }
                            return;
                        }
                        // 4. hyperliquid orderbook <COIN>
                        if (args[1] === 'orderbook' && args[2]) {
                            const coin = args[2].toUpperCase();
                            this.log(`Fetching Hyperliquid orderbook for ${coin}...`, 'info');
                            try {
                                const metaRes = await fetch('https://api.hyperliquid.xyz/info', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ type: 'metaAndAssetCtxs' })
                                });
                                const metaData = await metaRes.json();
                                if (Array.isArray(metaData) && metaData.length === 2 && Array.isArray(metaData[0].universe)) {
                                    const universe = metaData[0].universe;
                                    const idx = universe.findIndex(x => x.name.toUpperCase() === coin);
                                    if (idx === -1) {
                                        this.log(`Perp ${coin} not found.`, 'error');
                                        return;
                                    }
                                    const orderbookRes = await fetch('https://api.hyperliquid.xyz/v1/orderbook', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ coin })
                                    });
                                    const ob = await orderbookRes.json();
                                    if (ob && ob.bids && ob.asks) {
                                        let html = `<b>${coin} Orderbook</b><br>`;
                                        html += `<table style='width:100%;font-size:0.95em;'><tr><th>Bid Px</th><th>Bid Sz</th><th>Ask Px</th><th>Ask Sz</th></tr>`;
                                        for (let i = 0; i < Math.max(ob.bids.length, ob.asks.length, 10); ++i) {
                                            const bid = ob.bids[i] || [ '', '' ];
                                            const ask = ob.asks[i] || [ '', '' ];
                                            html += `<tr><td>${bid[0]}</td><td>${bid[1]}</td><td>${ask[0]}</td><td>${ask[1]}</td></tr>`;
                                        }
                                        html += `</table>`;
                                        this.logHtml(html, 'output');
                                    } else {
                                        this.log('No orderbook data found.', 'warning');
                                    }
                                } else {
                                    this.log('Failed to fetch meta for orderbook.', 'error');
                                }
                            } catch (e) {
                                this.log('Failed to fetch orderbook: ' + e.message, 'error');
                            }
                            return;
                        }
                        // 5. hyperliquid trades <COIN>
                        if (args[1] === 'trades' && args[2]) {
                            const coin = args[2].toUpperCase();
                            this.log(`Fetching Hyperliquid trades for ${coin}...`, 'info');
                            try {
                                const tradesRes = await fetch('https://api.hyperliquid.xyz/info', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ type: 'recentTrades', coin })
                                });
                                if (!tradesRes.ok) {
                                    const text = await tradesRes.text();
                                    this.log(`Failed to fetch trades: HTTP ${tradesRes.status} - ${text}`, 'error');
                                    return;
                                }
                                const trades = await tradesRes.json();
                                if (Array.isArray(trades) && trades.length > 0) {
                                    let html = `<b>Recent Trades for ${coin}:</b><br>`;
                                    html += `<table style='width:100%;font-size:0.95em;'><tr><th>Px</th><th>Sz</th><th>Side</th><th>Time</th></tr>`;
                                    for (let i = 0; i < Math.min(trades.length, 20); ++i) {
                                        const t = trades[i];
                                        html += `<tr><td>${t.px}</td><td>${t.sz}</td><td>${t.side}</td><td>${new Date(t.time).toLocaleTimeString()}</td></tr>`;
                                    }
                                    html += `</table>`;
                                    this.logHtml(html, 'output');
                                } else {
                                    this.log('No recent trades found.', 'warning');
                                }
                            } catch (e) {
                                this.log('Failed to fetch trades: ' + e.message, 'error');
                            }
                            return;
                        }
                        // 6. hyperliquid oi-cap
                        if (args[1] === 'oi-cap') {
                            this.log('Fetching perps at open interest cap...', 'info');
                            try {
                                const res = await fetch('https://api.hyperliquid.xyz/info', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ type: 'perpsAtOpenInterestCap' })
                                });
                                const data = await res.json();
                                if (Array.isArray(data) && data.length > 0) {
                                    this.logHtml(`<b>Perps at Open Interest Cap:</b> ${data.join(', ')}`, 'output');
                                } else {
                                    this.log('No perps at open interest cap.', 'info');
                                }
                            } catch (e) {
                                this.log('Failed to fetch perps at open interest cap: ' + e.message, 'error');
                            }
                            return;
                        }
                        // hyperliquid gen-wallet
                        if (args[1] === 'gen-wallet') {
                            const array = new Uint8Array(32);
                            window.crypto.getRandomValues(array);
                            const privHex = Array.from(array).map(b => b.toString(16).padStart(2, '0')).join('');
                            let address = '';
                            try {
                                if (window.ethers) {
                                    const wallet = new window.ethers.Wallet('0x' + privHex);
                                    address = wallet.address;
                                } else {
                                    this.log('Ethers.js not loaded. Cannot generate address.', 'error');
                                    return;
                                }
                            } catch (e) {
                                this.log('Failed to generate wallet: ' + e.message, 'error');
                                return;
                            }
                            window.hyperliquidApiWallet = { privHex, address };
                            let html = `<b>New Hyperliquid API Wallet Generated!</b><br>`;
                            html += `<span style='color:#ff3333'>SECURITY WARNING: Save your private key securely. Anyone with this key can trade on your behalf!</span><br>`;
                            html += `<b>Address:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${address}')">${address}</span><br>`;
                            html += `<b>Private Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${privHex}')">${privHex}</span><br>`;
                            html += `<button onclick="(() => { const blob = new Blob(['${privHex}'], {type: 'text/plain'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'hyperliquid-api-wallet.txt'; a.click(); setTimeout(() => URL.revokeObjectURL(url), 1000); })()">Download Private Key</button><br>`;
                            html += `<br>Register this address as an API wallet in your Hyperliquid account.<br>`;
                            this.logHtml(html, 'output');
                            return;
                        }
                        // hyperliquid wallet-info
                        if (args[1] === 'wallet-info') {
                            if (window.hyperliquidApiWallet && window.hyperliquidApiWallet.address) {
                                let html = `<b>Current Hyperliquid API Wallet:</b><br>`;
                                html += `<b>Address:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.hyperliquidApiWallet.address}')">${window.hyperliquidApiWallet.address}</span><br>`;
                                html += `<b>Private Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.hyperliquidApiWallet.privHex}')">${window.hyperliquidApiWallet.privHex}</span><br>`;
                                this.logHtml(html, 'output');
                            } else {
                                this.log('No Hyperliquid API wallet generated in this session. Use: hyperliquid gen-wallet', 'warning');
                            }
                            return;
                        }
                        
                        // eclipse gen-wallet
                        if (args[1] === 'gen-wallet') {
                            if (!window.solanaWeb3) {
                                this.log('Solana Web3 library not loaded. Cannot generate Eclipse wallet.', 'error');
                                return;
                            }
                            
                            try {
                                // Generate Solana keypair
                                const keypair = window.solanaWeb3.Keypair.generate();
                                const publicKey = keypair.publicKey.toString();
                                const privateKey = Array.from(keypair.secretKey).map(b => b.toString(16).padStart(2, '0')).join('');
                                
                                // Store in session
                                window.eclipseWallet = { 
                                    publicKey, 
                                    privateKey, 
                                    keypair,
                                    network: 'Eclipse (SVM)',
                                    rpcUrl: 'https://mainnetbeta-rpc.eclipse.xyz'
                                };
                                
                                let html = `<b>New Eclipse (SVM) Wallet Generated!</b><br>`;
                                html += `<span style='color:#ff3333'>SECURITY WARNING: Save your private key securely. Anyone with this key can access your funds!</span><br>`;
                                html += `<b>Public Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${publicKey}')">${publicKey}</span><br>`;
                                html += `<b>Private Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${privateKey}')">${privateKey}</span><br>`;
                                html += `<b>Network:</b> Eclipse (SVM)<br>`;
                                html += `<b>RPC URL:</b> https://mainnetbeta-rpc.eclipse.xyz<br>`;
                                html += `<button onclick="(() => { const blob = new Blob(['Public Key: ${publicKey}\\nPrivate Key: ${privateKey}\\nNetwork: Eclipse (SVM)\\nRPC URL: https://mainnetbeta-rpc.eclipse.xyz'], {type: 'text/plain'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'eclipse-wallet.txt'; a.click(); setTimeout(() => URL.revokeObjectURL(url), 1000); })()">Download Wallet Info</button><br>`;
                                html += `<br>💡 Use this wallet with Backpack, Phantom, or any Solana wallet that supports Eclipse network.<br>`;
                                this.logHtml(html, 'output');
                                return;
                            } catch (e) {
                                this.log('Failed to generate Eclipse wallet: ' + e.message, 'error');
                                return;
                            }
                        }
                        
                        // eclipse wallet-info
                        if (args[1] === 'wallet-info') {
                            if (window.eclipseWallet && window.eclipseWallet.publicKey) {
                                let html = `<b>Current Eclipse (SVM) Wallet:</b><br>`;
                                html += `<b>Public Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.eclipseWallet.publicKey}')">${window.eclipseWallet.publicKey}</span><br>`;
                                html += `<b>Private Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.eclipseWallet.privateKey}')">${window.eclipseWallet.privateKey}</span><br>`;
                                html += `<b>Network:</b> ${window.eclipseWallet.network}<br>`;
                                html += `<b>RPC URL:</b> ${window.eclipseWallet.rpcUrl}<br>`;
                                this.logHtml(html, 'output');
                            } else {
                                this.log('No Eclipse wallet generated in this session. Use: eclipse gen-wallet', 'warning');
                            }
                            return;
                        }
                        
                        // eclipse balance
                        if (args[1] === 'balance') {
                            if (!window.eclipseWallet) {
                                this.log('No Eclipse wallet generated. Use: eclipse gen-wallet', 'warning');
                                return;
                            }
                            
                            try {
                                const connection = new window.solanaWeb3.Connection(window.eclipseWallet.rpcUrl, 'confirmed');
                                const publicKey = new window.solanaWeb3.PublicKey(window.eclipseWallet.publicKey);
                                const balance = await connection.getBalance(publicKey);
                                const balanceInSol = balance / window.solanaWeb3.LAMPORTS_PER_SOL;
                                
                                this.logHtml(`<b>Eclipse Wallet Balance:</b>`, 'output');
                                this.logHtml(`<b>Address:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.eclipseWallet.publicKey}')">${window.eclipseWallet.publicKey}</span>`, 'output');
                                this.logHtml(`<b>Balance:</b> <b>${balanceInSol.toFixed(9)} SOL</b>`, 'output');
                                this.logHtml(`<b>Network:</b> Eclipse (SVM)`, 'output');
                            } catch (e) {
                                this.log('Failed to fetch Eclipse wallet balance: ' + e.message, 'error');
                            }
                            return;
                        }
                        
                        this.log('Unknown Hyperliquid command. Type "hyperliquid help" for available commands.', 'error');
                        return;
                    case 'polymarket':
                    case 'pm':
                        if (args[1] === 'help') {
                            this.log('=== Polymarket Prediction Markets ===', 'info');
                            this.log('polymarket help - Show this help', 'output');
                            this.log('polymarket markets - Get all prediction markets', 'output');
                            this.log('polymarket active - Get active markets only', 'output');
                            this.log('polymarket search <query> - Search markets', 'output');
                            this.log('polymarket market <id> - Get specific market details', 'output');
                            this.log('', 'output');
                            this.log('Examples:', 'output');
                            this.log('polymarket markets', 'output');
                            this.log('polymarket search "election"', 'output');
                            this.log('polymarket active', 'output');
                            return;
                        }
                        
                        if (args[1] === 'markets') {
                            await this.getPolymarketMarkets();
                            return;
                        }
                        
                        if (args[1] === 'active') {
                            await this.getPolymarketActiveMarkets();
                            return;
                        }
                        
                        if (args[1] === 'recent') {
                            await this.getPolymarketRecentMarkets();
                            return;
                        }
                        
                        if (args[1] === 'live') {
                            await this.getPolymarketLiveMarkets();
                            return;
                        }
                        
                        if (args[1] === 'search' && args.length >= 3) {
                            const query = args.slice(2).join(' ');
                            await this.searchPolymarketMarkets(query);
                            return;
                        }
                        
                        if (args[1] === 'market' && args.length >= 3) {
                            const marketId = args[2];
                            await this.getPolymarketMarketDetails(marketId);
                            return;
                        }
                        
                        this.log('Unknown Polymarket command. Type "polymarket help" for available commands.', 'error');
                        return;
                    case 'magiceden':
                    case 'me':
                        if (args[1] === 'help') {
                            this.log('=== Magic Eden NFT Marketplace ===', 'info');
                            this.log('magiceden help - Show this help', 'output');
                            this.log('magiceden collections - Get all collections', 'output');
                            this.log('magiceden popular - Get popular collections', 'output');
                            this.log('magiceden activities <symbol> - Get collection activities', 'output');
                            this.log('', 'output');
                            this.log('Examples:', 'output');
                            this.log('magiceden collections', 'output');
                            this.log('magiceden popular', 'output');
                            this.log('magiceden activities okay_bears', 'output');
                            return;
                        }
                        
                        if (args[1] === 'collections') {
                            await this.getMagicEdenCollections();
                            return;
                        }
                        
                        if (args[1] === 'popular') {
                            await this.getMagicEdenPopularCollections();
                            return;
                        }
                        
                        if (args[1] === 'activities' && args.length >= 3) {
                            const symbol = args[2];
                            await this.getMagicEdenCollectionActivities(symbol);
                            return;
                        }
                        
                        this.log('Unknown Magic Eden command. Type "magiceden help" for available commands.', 'error');
                        return;
                    case 'ambassador':
                        await this.handleAmbassadorCommand(args);
                        break;
                    case 'profile':
                        await this.handleProfileCommand(args);
                        break;
                    case 'gui':
                        this.handleGuiCommand(args);
                        break;
                    default:
                        if (cmd) {
                            this.log(`Command not found: ${command}`, 'error');
                            this.log('Type "help" for available commands', 'info');
                        }
                }
                // --- End command parsing ---
            }

            // Solana swap helper methods
            async executeSolanaSwap(amount, fromMint, toMint) {
                if (!this.solanaAddress) {
                    this.log('Please connect your Phantom wallet first using: solana connect', 'error');
                    return;
                }
                
                try {
                    const res = await fetch(`${RELAYER_URL}/jupiter/swap`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            inputMint: fromMint,
                            outputMint: toMint,
                            amount,
                            userPublicKey: this.solanaAddress
                        })
                    });
                    const data = await res.json();
                    if (data && (data.swapTransaction || data.transaction)) {
                        // Ask Phantom to sign and send the transaction
                        if (window.solana && window.solana.isPhantom) {
                            try {
                                // Convert base64 transaction to Uint8Array
                                const transactionBase64 = data.swapTransaction || data.transaction;
                                const transactionBuffer = Uint8Array.from(atob(transactionBase64), c => c.charCodeAt(0));
                                
                                // Create a VersionedTransaction from the buffer
                                const transaction = solanaWeb3.VersionedTransaction.deserialize(transactionBuffer);
                                
                                // Sign the transaction with Phantom
                                const signedTx = await window.solana.signTransaction(transaction);
                                
                                // Send the signed transaction using Helius RPC endpoint
                                const connection = new solanaWeb3.Connection('https://mainnet.helius-rpc.com/?api-key=94a04704-448e-45a8-82e5-8f4c63b25082');
                                const signature = await connection.sendRawTransaction(signedTx.serialize(), {
                                    maxRetries: 3,
                                    skipPreflight: false
                                });
                                
                                // Wait for confirmation
                                this.log('Transaction sent! Waiting for confirmation...', 'info');
                                
                                try {
                                    const confirmation = await connection.confirmTransaction(signature, 'confirmed');
                                    
                                    if (confirmation.value.err) {
                                        this.log(`Transaction failed: ${JSON.stringify(confirmation.value.err)}`, 'error');
                                    } else {
                                        this.logHtml(`<b>Swap transaction successful!</b> Signature: <span class='copyable' onclick="navigator.clipboard.writeText('${signature}')">${signature}</span>`, 'success');
                                        this.logHtml(`<a href="https://solscan.io/tx/${signature}" target="_blank">View on Solscan</a>`, 'success');
                                    }
                                } catch (confirmError) {
                                    this.log(`Transaction sent but confirmation failed: ${confirmError.message}`, 'warning');
                                    this.logHtml(`<b>Transaction sent!</b> Signature: <span class='copyable' onclick="navigator.clipboard.writeText('${signature}')">${signature}</span>`, 'success');
                                    this.logHtml(`<a href="https://solscan.io/tx/${signature}" target="_blank">View on Solscan</a>`, 'success');
                                }
                            } catch (e) {
                                this.log('User rejected or failed to sign the swap transaction: ' + e.message, 'error');
                            }
                        } else {
                            this.log('Phantom wallet not available for signing.', 'error');
                        }
                    } else if (data && data.error) {
                        this.logHtml(`<span style='color:#ff3333'>${data.error}</span>`, 'error');
                    } else {
                        this.logHtml('<span style="color:#ff3333">Swap failed: No transaction received from relayer.</span>', 'error');
                    }
                } catch (e) {
                    this.log('Solana swap failed: ' + e.message, 'error');
                }
            }

            async updateSolanaQuote() {
                const fromToken = document.getElementById('solanaFromToken');
                const toToken = document.getElementById('solanaToToken');
                const amountInput = document.getElementById('solanaAmount');
                const quoteDisplay = document.getElementById('solanaQuoteDisplay');
                const quoteAmount = document.getElementById('solanaQuoteAmount');
                const quotePrice = document.getElementById('solanaQuotePrice');
                
                if (!fromToken || !toToken || !amountInput || !quoteDisplay || !quoteAmount || !quotePrice) {
                    return;
                }
                
                const fromMint = fromToken.value;
                const toMint = toToken.value;
                const amount = parseFloat(amountInput.value);
                
                if (!fromMint || !toMint || isNaN(amount) || amount <= 0) {
                    quoteDisplay.style.display = 'none';
                    return;
                }
                
                // Convert amount to lamports for SOL
                let amountLamports;
                if (fromMint === 'So11111111111111111111111111111111111111112') {
                    amountLamports = Math.floor(amount * 1000000000).toString();
                } else {
                    // For other tokens, assume 6 decimals (like USDC)
                    amountLamports = Math.floor(amount * 1000000).toString();
                }
                
                try {
                    const res = await fetch(`${RELAYER_URL}/jupiter/quote`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            inputMint: fromMint,
                            outputMint: toMint,
                            amount: amountLamports,
                            slippageBps: 50
                        })
                    });
                    
                    const data = await res.json();
                    
                    if (data && data.outAmount) {
                        // Convert output amount to human readable
                        let outputAmount;
                        let outputSymbol;
                        
                        if (toMint === 'So11111111111111111111111111111111111111112') {
                            outputAmount = (parseInt(data.outAmount) / 1000000000).toFixed(6);
                            outputSymbol = 'SOL';
                        } else {
                            outputAmount = (parseInt(data.outAmount) / 1000000).toFixed(6);
                            outputSymbol = toMint === 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v' ? 'USDC' : 
                                         toMint === 'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB' ? 'USDT' : 'Token';
                        }
                        
                        quoteAmount.textContent = `${outputAmount} ${outputSymbol}`;
                        
                        // Calculate and show price impact if available
                        if (data.priceImpactPct) {
                            const priceImpact = parseFloat(data.priceImpactPct);
                            if (priceImpact > 0.1) {
                                quotePrice.textContent = `Price Impact: ${priceImpact.toFixed(2)}%`;
                                quotePrice.style.color = '#ff6b6b';
                            } else {
                                quotePrice.textContent = `Price Impact: ${priceImpact.toFixed(2)}%`;
                                quotePrice.style.color = '#51cf66';
                            }
                        } else {
                            quotePrice.textContent = '';
                        }
                        
                        quoteDisplay.style.display = 'block';
                    } else {
                        quoteDisplay.style.display = 'none';
                    }
                } catch (e) {
                    quoteDisplay.style.display = 'none';
                }
            }

            async promptCustomSwap(tokenMint, tokenSymbol) {
                if (!this.solanaAddress) {
                    this.log('Please connect your Phantom wallet first using: solana connect', 'error');
                    return;
                }
                this.customSwapTokenMint = tokenMint;
                this.customSwapTokenSymbol = tokenSymbol;
                this.awaitingCustomSwapDirection = true;
                this.log(`Custom Swap: Choose direction:`, 'info');
                this.log('1) SOL → ' + tokenSymbol, 'info');
                this.log('2) ' + tokenSymbol + ' → SOL', 'info');
                this.log('Type 1 or 2:', 'info');
            }

            async showSolanaSwapInterface() {
                this.log('🟣 Solana Swap Interface', 'info');
                this.log('Loading popular tokens...', 'info');
                
                try {
                    // Create swap interface with searchable dropdowns
                    let html = `<div style="background: rgba(255,255,255,0.05); border: 1px solid #ffffff; padding: 15px; border-radius: 5px; margin: 10px 0;">`;
                    html += `<h3 style="margin: 0 0 15px 0; color: #ffffff;">🟣 Solana Swap</h3>`;
                    
                    // From token selection with searchable dropdown
                    html += `<div style="margin-bottom: 15px;">`;
                    html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">From Token:</label>`;
                    html += `<div class="custom-dropdown" style="position: relative; width: 100%;">`;
                    html += `<div class="dropdown-header" id="solanaFromTokenHeader" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; cursor: pointer;">`;
                    html += `<span id="solanaFromTokenDisplay">🟣 SOL (Native)</span>`;
                    html += `<span style="color: #666;">▼</span>`;
                    html += `</div>`;
                    html += `<div class="dropdown-content" id="solanaFromTokenDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #111; border: 1px solid #333; border-top: none; border-radius: 0 0 3px 3px; max-height: 300px; overflow-y: auto; z-index: 1000;">`;
                    html += `<div style="padding: 8px; border-bottom: 1px solid #333;">`;
                    html += `<input type="text" id="solanaFromSearch" placeholder="Search tokens..." style="width: 100%; padding: 6px; background: #222; color: #fff; border: 1px solid #444; border-radius: 3px; box-sizing: border-box;">`;
                    html += `</div>`;
                    html += `<div id="solanaFromTokenList">`;
                    // Default tokens
                    html += `<div class="dropdown-item" data-value="So11111111111111111111111111111111111111112" data-symbol="SOL" data-name="Solana" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">🟣 SOL (Solana)</div>`;
                    html += `<div class="dropdown-item" data-value="EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" data-symbol="USDC" data-name="USD Coin" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">💙 USDC (USD Coin)</div>`;
                    html += `<div class="dropdown-item" data-value="Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB" data-symbol="USDT" data-name="Tether USD" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">💚 USDT (Tether USD)</div>`;
                    html += `<div class="dropdown-item" data-value="DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263" data-symbol="BONK" data-name="Bonk" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">🐕 BONK (Bonk)</div>`;
                    html += `</div>`;
                    html += `</div>`;
                    html += `<input type="hidden" id="solanaFromToken" value="So11111111111111111111111111111111111111112">`;
                    html += `</div>`;
                    html += `</div>`;
                    
                    // To token selection with searchable dropdown
                    html += `<div style="margin-bottom: 15px;">`;
                    html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">To Token:</label>`;
                    html += `<div class="custom-dropdown" style="position: relative; width: 100%;">`;
                    html += `<div class="dropdown-header" id="solanaToTokenHeader" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; cursor: pointer;">`;
                    html += `<span id="solanaToTokenDisplay">💙 USDC (USD Coin)</span>`;
                    html += `<span style="color: #666;">▼</span>`;
                    html += `</div>`;
                    html += `<div class="dropdown-content" id="solanaToTokenDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #111; border: 1px solid #333; border-top: none; border-radius: 0 0 3px 3px; max-height: 300px; overflow-y: auto; z-index: 1000;">`;
                    html += `<div style="padding: 8px; border-bottom: 1px solid #333;">`;
                    html += `<input type="text" id="solanaToSearch" placeholder="Search tokens..." style="width: 100%; padding: 6px; background: #222; color: #fff; border: 1px solid #444; border-radius: 3px; box-sizing: border-box;">`;
                    html += `</div>`;
                    html += `<div id="solanaToTokenList">`;
                    // Default tokens
                    html += `<div class="dropdown-item" data-value="So11111111111111111111111111111111111111112" data-symbol="SOL" data-name="Solana" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">🟣 SOL (Solana)</div>`;
                    html += `<div class="dropdown-item" data-value="EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" data-symbol="USDC" data-name="USD Coin" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">💙 USDC (USD Coin)</div>`;
                    html += `<div class="dropdown-item" data-value="Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB" data-symbol="USDT" data-name="Tether USD" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">💚 USDT (Tether USD)</div>`;
                    html += `<div class="dropdown-item" data-value="DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263" data-symbol="BONK" data-name="Bonk" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">🐕 BONK (Bonk)</div>`;
                    html += `</div>`;
                    html += `</div>`;
                    html += `<input type="hidden" id="solanaToToken" value="EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v">`;
                    html += `</div>`;
                    html += `</div>`;
                    
                    // Amount input
                    html += `<div style="margin-bottom: 15px;">`;
                    html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">Amount:</label>`;
                    html += `<input type="number" id="solanaAmount" placeholder="Enter amount" step="0.000001" style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; box-sizing: border-box;">`;
                    html += `</div>`;
                    
                    // Swap button
                    html += `<button id="solanaSwapBtn" style="width: 100%; padding: 12px; background: linear-gradient(45deg, #9945ff, #7c3aed); color: white; border: none; border-radius: 5px; font-size: 16px; font-weight: bold; cursor: pointer; margin-bottom: 10px;">🟣 Execute Solana Swap</button>`;
                    
                    // Quote display section
                    html += `<div id="solanaQuoteDisplay" style="margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.05); border: 1px solid #333; border-radius: 3px; display: none;">`;
                    html += `<div style="font-size: 12px; color: #999; margin-bottom: 5px;">Estimated Output:</div>`;
                    html += `<div id="solanaQuoteAmount" style="font-size: 16px; color: #fff; font-weight: bold;"></div>`;
                    html += `<div id="solanaQuotePrice" style="font-size: 12px; color: #999; margin-top: 3px;"></div>`;
                    html += `</div>`;
                    
                    html += `</div>`;
                    
                    this.logHtml(html, 'output');
                    
                    // Add event listeners for custom dropdowns
                    setTimeout(() => {
                        this.setupSolanaDropdowns();
                        const swapBtn = document.getElementById('solanaSwapBtn');
                        if (swapBtn) {
                            swapBtn.addEventListener('click', () => this.executeSolanaSwapFromInterface());
                        }
                        
                        // Fix input event handling and add quote functionality
                        const amountInput = document.getElementById('solanaAmount');
                        if (amountInput) {
                            amountInput.addEventListener('click', (e) => e.stopPropagation());
                            amountInput.addEventListener('focus', (e) => e.stopPropagation());
                            amountInput.addEventListener('input', (e) => {
                                e.stopPropagation();
                                this.updateSolanaQuote();
                            });
                        }
                        
                        // Add quote update on token changes
                        const fromToken = document.getElementById('solanaFromToken');
                        const toToken = document.getElementById('solanaToToken');
                        if (fromToken) fromToken.addEventListener('change', () => this.updateSolanaQuote());
                        if (toToken) toToken.addEventListener('change', () => this.updateSolanaQuote());
                    }, 100);
                    
                } catch (e) {
                    this.log(`Failed to load Solana swap interface: ${e.message}`, 'error');
                }
            }

            async handleCustomSwapInput(amount, toMint) {
                this.awaitingCustomSwap = false;
                await this.executeSolanaSwap(amount, this.customSwapFromMint, toMint);
                this.customSwapFromMint = null;
                this.customSwapSymbol = null;
            }

            async handleDexScreenerCommand(args) {
                if (!args[1]) {
                    this.log('Usage: dexscreener <search|trending|pair> [query]', 'info');
                    return;
                }
                const sub = args[1];
                if (sub === 'search' && args[2]) {
                    const q = args.slice(2).join(' ');
                    this.log(`Searching DexScreener for: ${q}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/dex/search?q=${encodeURIComponent(q)}`);
                        const data = await res.json();
                        if (Array.isArray(data) && data.length > 0) {
                            data.forEach((item, idx) => {
                                this.logHtml(`<b>${idx + 1}. ${item.symbol || ''} (${item.chainId || ''})</b>`, 'output');
                                this.logHtml(`Name: <b>${item.name || ''}</b>`, 'output');
                                this.logHtml(`Price: <b>${item.priceUsd || item.price || 'N/A'}</b>`, 'output');
                                this.logHtml(`Token Address: <span class='copyable' onclick="navigator.clipboard.writeText('${item.tokenAddress || ''}')">${item.tokenAddress || ''}</span>`, 'output');
                                if (item.url) this.logHtml(`<a href="${item.url}" target="_blank">View on DexScreener</a>`, 'output');
                                this.logHtml('<hr>', 'output');
                            });
                        } else if (data.pairs && Array.isArray(data.pairs)) {
                            data.pairs.forEach((pair, idx) => {
                                this.logHtml(`<b>${idx + 1}. ${pair.baseToken?.symbol || ''} (${pair.chainId || ''})</b>`, 'output');
                                this.logHtml(`Name: <b>${pair.baseToken?.name || ''}</b>`, 'output');
                                this.logHtml(`Price: <b>${pair.priceUsd || pair.price || 'N/A'}</b>`, 'output');
                                this.logHtml(`Token Address: <span class='copyable' onclick="navigator.clipboard.writeText('${pair.baseToken?.address || ''}')">${pair.baseToken?.address || ''}</span>`, 'output');
                                if (pair.url) this.logHtml(`<a href="${pair.url}" target="_blank">View on DexScreener</a>`, 'output');
                                this.logHtml('<hr>', 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No results found.</span>', 'error');
                        }
                    } catch (e) {
                        this.log('DexScreener search failed: ' + e.message, 'error');
                    }
                } else if (sub === 'trending') {
                    this.log('Fetching DexScreener trending tokens...', 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/dex/trending`);
                        const data = await res.json();
                        if (Array.isArray(data) && data.length > 0) {
                            data.forEach((item, idx) => {
                                this.logHtml(`<b>${idx + 1}. ${item.symbol || ''} (${item.chainId || ''})</b>`, 'output');
                                this.logHtml(`Name: <b>${item.name || ''}</b>`, 'output');
                                this.logHtml(`Price: <b>${item.priceUsd || item.price || 'N/A'}</b>`, 'output');
                                this.logHtml(`Token Address: <span class='copyable' onclick="navigator.clipboard.writeText('${item.tokenAddress || ''}')">${item.tokenAddress || ''}</span>`, 'output');
                                if (item.url) this.logHtml(`<a href="${item.url}" target="_blank">View on DexScreener</a>`, 'output');
                                this.logHtml('<hr>', 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No trending tokens found.</span>', 'error');
                        }
                    } catch (e) {
                        this.log('DexScreener trending failed: ' + e.message, 'error');
                    }
                } else {
                    this.log('Usage: dexscreener <search|trending|pair> [query]', 'info');
                }
            }

            async handleGeckoTerminalCommand(args) {
                if (!args[1]) {
                    this.log('Usage: geckoterminal <search|trending|token> [network] [query]', 'info');
                    return;
                }
                // Define show404Suggestion at the top so it is always in scope
                const show404Suggestion = (data) => {
                    if (data && data.errors && Array.isArray(data.errors)) {
                        const is404 = data.errors.some(e => e.status === '404' || e.title === 'Not Found');
                        if (is404) {
                            this.logHtml('<span style="color:#ff3333">Not Found. Try <b>cg networks</b> to see available networks and use the correct slug.</span>', 'error');
                        }
                    }
                };
                const sub = args[1];
                if (sub === 'search' && args[2]) {
                    const q = args.slice(2).join(' ');
                    this.log(`Searching GeckoTerminal for: ${q}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/search?q=${encodeURIComponent(q)}`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            data.data.forEach((item, idx) => {
                                const pair = item.attributes;
                                this.logHtml(`<b>${idx + 1}. ${pair.name || ''}</b>`, 'output');
                                this.logHtml(`DEX: <b>${pair.dex_name || ''}</b> | Network: <b>${pair.network || ''}</b>`, 'output');
                                this.logHtml(`Base: <b>${pair.base_token_symbol || ''}</b> | Quote: <b>${pair.quote_token_symbol || ''}</b>`, 'output');
                                this.logHtml(`Price: <b>${pair.price_usd || 'N/A'}</b> | Volume 24h: <b>${pair.volume_usd_24h || 'N/A'}</b>`, 'output');
                                if (pair.gecko_terminal_url) this.logHtml(`<a href="${pair.gecko_terminal_url}" target="_blank">View on GeckoTerminal</a>`, 'output');
                                this.logHtml('<hr>', 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No results found.</span>', 'error');
                            this.logHtml('<span style="color:#cccccc">Tip: GeckoTerminal search only returns results for exact or popular pair names.</span>', 'info');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal search failed: ' + e.message, 'error');
                    }
                } else if (sub === 'trending' && args[2]) {
                    const network = args[2];
                    this.log(`Fetching GeckoTerminal trending tokens for network: ${network}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/trending`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            data.data.forEach((item, idx) => {
                                const pair = item.attributes;
                                this.logHtml(`<b>${idx + 1}. ${pair.name || ''}</b>`, 'output');
                                this.logHtml(`DEX: <b>${pair.dex_name || ''}</b> | Network: <b>${pair.network || ''}</b>`, 'output');
                                this.logHtml(`Base: <b>${pair.base_token_symbol || ''}</b> | Quote: <b>${pair.quote_token_symbol || ''}</b>`, 'output');
                                this.logHtml(`Price: <b>${pair.price_usd || 'N/A'}</b> | Volume 24h: <b>${pair.volume_usd_24h || 'N/A'}</b>`, 'output');
                                if (pair.gecko_terminal_url) this.logHtml(`<a href="${pair.gecko_terminal_url}" target="_blank">View on GeckoTerminal</a>`, 'output');
                                this.logHtml('<hr>', 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No trending tokens found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal trending failed: ' + e.message, 'error');
                    }
                } else if (sub === 'networks') {
                    this.log('Fetching GeckoTerminal networks...', 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            this.logHtml('<b>Available Networks:</b>', 'output');
                            data.data.forEach((item) => {
                                const net = item.attributes;
                                const id = item.id;
                                const cg = net.coingecko_asset_platform_id ? ` | Coingecko: <b>${net.coingecko_asset_platform_id}</b>` : '';
                                this.logHtml(`<b>${net.name}</b> (<span style='color:#99ccff'>${id}</span>)${cg}`, 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No networks found.</span>', 'error');
                        }
                    } catch (e) {
                        this.log('GeckoTerminal networks fetch failed: ' + e.message, 'error');
                    }
                } else if (sub === 'dexes' && args[2]) {
                    const network = args[2];
                    this.log(`Fetching GeckoTerminal dexes for network: ${network}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/dexes`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            this.logHtml(`<b>DEXes for ${network}:</b>`, 'output');
                            data.data.forEach((item) => {
                                const dex = item.attributes;
                                const id = item.id;
                                this.logHtml(`<b>${dex.name}</b> (<span style='color:#99ccff'>${id}</span>)`, 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No DEXes found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal dexes fetch failed: ' + e.message, 'error');
                    }
                } else if (sub === 'pools' && args[2]) {
                    const network = args[2];
                    this.log(`Fetching GeckoTerminal pools for network: ${network}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/pools`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            this.logHtml(`<b>Pools for ${network}:</b>`, 'output');
                            data.data.forEach((item) => {
                                const pool = item.attributes;
                                this.logHtml(`<b>${pool.name}</b> | DEX: <b>${pool.dex_name}</b> | TVL: <b>${pool.tvl_usd || 'N/A'}</b>`, 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No pools found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal pools fetch failed: ' + e.message, 'error');
                    }
                } else if (sub === 'token' && args[2] && args[3]) {
                    const network = args[2];
                    const address = args[3];
                    this.log(`Fetching GeckoTerminal token info for network: ${network}, address: ${address}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/tokens/${address}`);
                        const data = await res.json();
                        if (data && data.data && data.data.attributes) {
                            const token = data.data.attributes;
                            this.logHtml(`<b>${token.name} (${token.symbol})</b>`, 'output');
                            this.logHtml(`Price: <b>${token.price_usd || 'N/A'}</b> | TVL: <b>${token.tvl_usd || 'N/A'}</b>`, 'output');
                            this.logHtml(`DEX Count: <b>${token.dex_count || 'N/A'}</b> | Pool Count: <b>${token.pool_count || 'N/A'}</b>`, 'output');
                            if (token.gecko_terminal_url) this.logHtml(`<a href="${token.gecko_terminal_url}" target="_blank">View on GeckoTerminal</a>`, 'output');
                        } else {
                            this.logHtml('<span style="color:#ff3333">No token info found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal token fetch failed: ' + e.message, 'error');
                    }
                } else if (sub === 'tokenpools' && args[2] && args[3]) {
                    const network = args[2];
                    const tokenAddress = args[3];
                    this.log(`Fetching GeckoTerminal pools for token: ${tokenAddress} on network: ${network}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/tokens/${tokenAddress}/pools`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            this.logHtml(`<b>Pools for token ${tokenAddress} on ${network}:</b>`, 'output');
                            data.data.forEach((item) => {
                                const pool = item.attributes;
                                this.logHtml(`<b>${pool.name}</b> | DEX: <b>${pool.dex_name}</b> | TVL: <b>${pool.tvl_usd || 'N/A'}</b>`, 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No pools found for this token.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal tokenpools fetch failed: ' + e.message, 'error');
                    }
                } else if (sub === 'poolinfo' && args[2] && args[3]) {
                    const network = args[2];
                    const poolAddress = args[3];
                    this.log(`Fetching GeckoTerminal pool info for network: ${network}, pool: ${poolAddress}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/pools/${poolAddress}/info`);
                        const data = await res.json();
                        if (data && data.data && data.data.attributes) {
                            const pool = data.data.attributes;
                            this.logHtml(`<b>${pool.name}</b> | DEX: <b>${pool.dex_name}</b> | TVL: <b>${pool.tvl_usd || 'N/A'}</b>`, 'output');
                            this.logHtml(`Base: <b>${pool.base_token_symbol}</b> | Quote: <b>${pool.quote_token_symbol}</b>`, 'output');
                            this.logHtml(`Price: <b>${pool.price_usd || 'N/A'}</b> | Volume 24h: <b>${pool.volume_usd_24h || 'N/A'}</b>`, 'output');
                            if (pool.gecko_terminal_url) this.logHtml(`<a href="${pool.gecko_terminal_url}" target="_blank">View on GeckoTerminal</a>`, 'output');
                        } else {
                            this.logHtml('<span style="color:#ff3333">No pool info found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal poolinfo fetch failed: ' + e.message, 'error');
                    }
                } else if (sub === 'ohlcv' && args[2] && args[3] && args[4]) {
                    const network = args[2];
                    const poolAddress = args[3];
                    const timeframe = args[4];
                    this.log(`Fetching GeckoTerminal OHLCV for network: ${network}, pool: ${poolAddress}, timeframe: ${timeframe}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/pools/${poolAddress}/ohlcv/${timeframe}`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            this.logHtml(`<b>OHLCV (${timeframe}) for pool ${poolAddress}:</b>`, 'output');
                            data.data.forEach((item) => {
                                this.logHtml(`<b>${item.timestamp}</b>: O: <b>${item.open}</b>, H: <b>${item.high}</b>, L: <b>${item.low}</b>, C: <b>${item.close}</b>, V: <b>${item.volume}</b>`, 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No OHLCV data found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal ohlcv fetch failed: ' + e.message, 'error');
                    }
                } else if (sub === 'trades' && args[2] && args[3]) {
                    const network = args[2];
                    const poolAddress = args[3];
                    this.log(`Fetching GeckoTerminal trades for network: ${network}, pool: ${poolAddress}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/pools/${poolAddress}/trades`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            this.logHtml(`<b>Recent trades for pool ${poolAddress}:</b>`, 'output');
                            data.data.slice(0, 10).forEach((item) => {
                                const trade = item.attributes;
                                this.logHtml(`<b>${trade.timestamp}</b>: <b>${trade.amount_usd || 'N/A'} USD</b> | Type: <b>${trade.trade_type}</b> | Price: <b>${trade.price_usd || 'N/A'}</b>`, 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No trades found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal trades fetch failed: ' + e.message, 'error');
                    }
                } else {
                    this.log('Usage: geckoterminal <search|trending|token> [network] [query]', 'info');
                }
            }

            async handleStockCommand(args) {
                if (!args[1]) {
                    this.log('Usage: stock <quote|search|daily|overview|inflation|cpi|gdp> [symbol]', 'info');
                    return;
                }
                const sub = args[1];
                if (sub === 'quote' && args[2]) {
                    const symbol = args[2];
                    this.log(`Fetching stock quote for: ${symbol}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/stock/quote/${encodeURIComponent(symbol)}`);
                        const data = await res.json();
                        if (data && data.price) {
                            this.logHtml(`<b>${symbol} Stock Quote</b>`, 'output');
                            this.logHtml(`Price: <b>${data.price}</b>`, 'output');
                            this.logHtml(`Change: <b>${data.change}</b> (${data.changePercent})`, 'output');
                            this.logHtml(`Open: <b>${data["02. open"] || ''}</b> | High: <b>${data["03. high"] || ''}</b> | Low: <b>${data["04. low"] || ''}</b>`, 'output');
                            this.logHtml(`Volume: <b>${data["06. volume"] || ''}</b> | Previous Close: <b>${data["08. previous close"] || ''}</b>`, 'output');
                            this.logHtml(`Latest Trading Day: <b>${data["07. latest trading day"] || ''}</b>`, 'output');
                        } else if (data && data.error) {
                            this.logHtml(`<span style='color:#ff3333'>${data.error}</span>`, 'error');
                        } else {
                            this.logHtml('<span style="color:#ff3333">No quote found.</span>', 'error');
                        }
                    } catch (e) {
                        this.log('Stock quote failed: ' + e.message, 'error');
                    }
                } else if (sub === 'search' && args[2]) {
                    const q = args.slice(2).join(' ');
                    this.log(`Searching stocks for: ${q}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/stock/search?q=${encodeURIComponent(q)}`);
                        const data = await res.json();
                        if (data && data.bestMatches && Array.isArray(data.bestMatches) && data.bestMatches.length > 0) {
                            data.bestMatches.forEach((match, idx) => {
                                this.logHtml(`<b>${idx + 1}. ${match['2. name']} (${match['1. symbol']})</b>`, 'output');
                                this.logHtml(`Type: <b>${match['3. type']}</b> | Region: <b>${match['4. region']}</b>`, 'output');
                                this.logHtml(`Currency: <b>${match['8. currency']}</b> | Match Score: <b>${match['9. matchScore']}</b>`, 'output');
                                this.logHtml('<hr>', 'output');
                            });
                        } else if (data && data.error) {
                            this.logHtml(`<span style='color:#ff3333'>${data.error}</span>`, 'error');
                        } else {
                            this.logHtml('<span style="color:#ff3333">No results found.</span>', 'error');
                        }
                    } catch (e) {
                        this.log('Stock search failed: ' + e.message, 'error');
                    }
                } else if (sub === 'daily' && args[2]) {
                    const symbol = args[2];
                    this.log(`Fetching daily stock data for: ${symbol}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/stock/daily/${encodeURIComponent(symbol)}`);
                        const data = await res.json();
                        if (data && data['Time Series (Daily)']) {
                            const series = data['Time Series (Daily)'];
                            const dates = Object.keys(series).slice(0, 5); // Show last 5 days
                            this.logHtml(`<b>${symbol} - Last 5 Days</b>`, 'output');
                            dates.forEach(date => {
                                const d = series[date];
                                this.logHtml(`<b>${date}</b>: Open: <b>${d['1. open']}</b>, High: <b>${d['2. high']}</b>, Low: <b>${d['3. low']}</b>, Close: <b>${d['4. close']}</b>, Volume: <b>${d['5. volume']}</b>`, 'output');
                            });
                        } else if (data && data.error) {
                            this.logHtml(`<span style='color:#ff3333'>${data.error}</span>`, 'error');
                        } else {
                            this.logHtml('<span style="color:#ff3333">No daily data found.</span>', 'error');
                        }
                    } catch (e) {
                        this.log('Stock daily failed: ' + e.message, 'error');
                    }
                } else if (sub === 'overview' && args[2]) {
                    const symbol = args[2];
                    this.log(`Fetching stock overview for: ${symbol}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/stock/overview/${encodeURIComponent(symbol)}`);
                        const data = await res.json();
                        if (data && data.Symbol) {
                            this.logHtml(`<b>${data.Name} (${data.Symbol})</b>`, 'output');
                            this.logHtml(`Sector: <b>${data.Sector}</b> | Industry: <b>${data.Industry}</b>`, 'output');
                            this.logHtml(`Market Cap: <b>${data.MarketCapitalization}</b> | EPS: <b>${data.EPS}</b>`, 'output');
                            this.logHtml(`PE Ratio: <b>${data.PERatio}</b> | Dividend Yield: <b>${data.DividendYield}</b>`, 'output');
                            this.logHtml(`Description: <span style='color:#cccccc'>${data.Description}</span>`, 'output');
                        } else if (data && data.error) {
                            this.logHtml(`<span style='color:#ff3333'>${data.error}</span>`, 'error');
                        } else {
                            this.logHtml('<span style="color:#ff3333">No overview found.</span>', 'error');
                        }
                    } catch (e) {
                        this.log('Stock overview failed: ' + e.message, 'error');
                    }
                } else if (sub === 'inflation') {
                    this.log('Fetching US inflation data...', 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/stock/inflation`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data)) {
                            this.logHtml('<b>US Inflation (last 5 years):</b>', 'output');
                            data.data.slice(-5).forEach((item) => {
                                this.logHtml(`<b>${item.date}</b>: <b>${item.value}</b>`, 'output');
                            });
                        } else if (data && data.error) {
                            this.logHtml(`<span style='color:#ff3333'>${data.error}</span>`, 'error');
                        } else {
                            this.logHtml('<span style="color:#ff3333">No inflation data found.</span>', 'error');
                        }
                    } catch (e) {
                        this.log('Inflation fetch failed: ' + e.message, 'error');
                    }
                } else if (sub === 'cpi') {
                    this.log('Fetching US CPI data...', 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/stock/cpi`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data)) {
                            this.logHtml('<b>US CPI (last 5 years):</b>', 'output');
                            data.data.slice(-5).forEach((item) => {
                                this.logHtml(`<b>${item.date}</b>: <b>${item.value}</b>`, 'output');
                            });
                        } else if (data && data.error) {
                            this.logHtml(`<span style='color:#ff3333'>${data.error}</span>`, 'error');
                        } else {
                            this.logHtml('<span style="color:#ff3333">No CPI data found.</span>', 'error');
                        }
                    } catch (e) {
                        this.log('CPI fetch failed: ' + e.message, 'error');
                    }
                } else if (sub === 'gdp') {
                    this.log('Fetching US GDP data...', 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/stock/gdp`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data)) {
                            this.logHtml('<b>US Real GDP (last 5 years):</b>', 'output');
                            data.data.slice(-5).forEach((item) => {
                                this.logHtml(`<b>${item.date}</b>: <b>${item.value}</b>`, 'output');
                            });
                        } else if (data && data.error) {
                            this.logHtml(`<span style='color:#ff3333'>${data.error}</span>`, 'error');
                        } else {
                            this.logHtml('<span style="color:#ff3333">No GDP data found.</span>', 'error');
                        }
                    } catch (e) {
                        this.log('GDP fetch failed: ' + e.message, 'error');
                    }
                } else {
                    this.log('Usage: stock <quote|search|daily|overview|inflation|cpi|gdp> [symbol]', 'info');
                }
            }

            async handleAlphaKeyCommand(args) {
                this.log('Alpha Vantage API key is managed by the relayer. No action needed.', 'info');
            }

            async showUnifiedHelp() {
                this.logHtml('<span style="color:#33bbff">=== Omega Terminal Commands ===</span>', 'info');
                this.log('--- Wallet ----', 'output');
                this.logHtml('<span style="color:#33bbff">Commands: connect | disconnect | balance | faucet | send | network | forceadd | rpccheck</span>', 'info');
                this.log('--- Mining ---', 'output');
                this.logHtml('<span style="color:#33bbff">Commands: mine | claim | status | stats</span>', 'info');
                this.log('--- ENS / Domains ----', 'output');
                this.logHtml('<span style="color:#33bbff">Commands: send | ens register | ens resolve | ens search</span>', 'info');
                this.log('--- Mixer (Privacy) ----', 'output');
                this.logHtml('<span style="color:#33bbff">Commands: mixer deposit | mixer deposit-execute | mixer deposit-direct | mixer withdraw | mixer withdraw-direct | mixer -help</span>', 'info');
                this.log('--- Stress Test ----', 'output');
                this.logHtml('<span style="color:#33bbff">Commands: stress | stopstress | stressstats</span>', 'info');
                this.log('--- Fun & Misc ----', 'output');
                this.logHtml('<span style="color:#33bbff">Commands: theme [dark, powershell, matrix, retro] | gui [ios, chatgpt, discord, aol, windows95, limewire] | clear | help | rickroll | fortune | matrix | hack | disco | stop | tab | url</span>', 'info');
                this.log('--- On Chain Email ----', 'output');
                this.logHtml('<span style="color:#33bbff">Commands: email | inbox</span>', 'info');
                this.log('--- web3 (Beta - Full features in v2) ---', 'output');
                this.logHtml('<table style="width:100%;border:none;"><tr>' +
                  '<td style="vertical-align:top;width:16%;padding-right:16px;">' +
                  '<span style="color:#33bbff">Dexscreener:</span><br>' +
                  '<span style="color:#99ccff">commands: ds help</span>' +
                  '</td>' +
                  '<td style="vertical-align:top;width:16%;padding-right:16px;">' +
                  '<span style="color:#33bbff">GeckoTerminal:</span><br>' +
                  '<span style="color:#99ccff">commands: cg help</span>' +
                  '</td>' +
                  '<td style="vertical-align:top;width:16%;padding-right:16px;">' +
                  '<span style="color:#33bbff">Token Creator:</span><br>' +
                  '<span style="color:#99ccff">command: create</span>' +
                  '</td>' +
                  '<td style="vertical-align:top;width:16%;padding-right:16px;">' +
                  '<span style="color:#33bbff">Solana:</span><br>' +
                  '<span style="color:#99ccff">commands: solana help</span>' +
                  '</td>' +
                  '<td style="vertical-align:top;width:16%;padding-right:16px;">' +
                  '<span style="color:#33bbff">Eclipse:</span><br>' +
                  '<span style="color:#99ccff">commands: eclipse help</span>' +
                  '</td>' +
                  '<td style="vertical-align:top;width:16%;">' +
                  '<span style="color:#33bbff">Near Intents:</span><br>' +
                  '<span style="color:#99ccff">commands: near help</span>' +
                  '</td>' +
                  '</tr></table>', 'output');
                this.logHtml('<table style="width:100%;border:none;"><tr>' +
                  '<td style="vertical-align:top;width:16%;padding-right:16px;">' +
                  '<span style="color:#33bbff">Ambassador:</span><br>' +
                  '<span style="color:#99ccff">commands: ambassador help</span><br>' +
                  '<span style="color:#888888">referrals & leaderboards</span>' +
                  '</td>' +
                  '<td style="vertical-align:top;width:16%;padding-right:16px;">' +
                  '<span style="color:#33bbff">Profile:</span><br>' +
                  '<span style="color:#99ccff">commands: profile help</span><br>' +
                  '<span style="color:#888888">user registration & settings</span>' +
                  '</td>' +
                  '<td style="vertical-align:top;width:16%;">' +
                  '</td>' +
                  '<td style="vertical-align:top;width:16%;">' +
                  '</td>' +
                  '<td style="vertical-align:top;width:16%;">' +
                  '</td>' +
                  '<td style="vertical-align:top;width:16%;">' +
                  '</td>' +
                  '</tr></table>', 'output');
                this.logHtml('<table style="width:100%;border:none;"><tr>' +
                  '<td style="vertical-align:top;width:16%;padding-right:16px;">' +
                  '<span style="color:#33bbff">Hyperliquid:</span><br>' +
                  '<span style="color:#99ccff">commands: hyperliquid help</span>' +
                  '</td>' +
                  '<td style="vertical-align:top;width:16%;padding-right:16px;">' +
                  '<span style="color:#33bbff">Polymarket:</span><br>' +
                  '<span style="color:#99ccff">commands: polymarket help</span>' +
                  '</td>' +
                  '<td style="vertical-align:top;width:16%;padding-right:16px;">' +
                  '<span style="color:#33bbff">NFTs:</span><br>' +
                  '<span style="color:#99ccff">commands: nft help</span>' +
                  '</td>' +
                  '<td style="vertical-align:top;width:16%;">' +
                  '</td>' +
                  '<td style="vertical-align:top;width:16%;">' +
                  '</td>' +
                  '<td style="vertical-align:top;width:16%;">' +
                  '</td>' +
                  '</tr></table>', 'output');
                this.log('--- stocks & economy ---', 'output');
                this.logHtml('<span style="color:#33bbff">alpha</span>', 'info');
                this.logHtml('<span style="color:#99ccff">commands: alpha help</span>', 'output');
                this.log('---', 'output');
            }

            async mine() {
                if (this.isMining) {
                    this.log('Mining is already running. Use "stop" to end mining.', 'warning');
                    return;
                }
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }
                this.isMining = true;
                this.log('⛏️ Automated mining started! Use "stop" to end mining.', 'info');
                this.log('💰 IMPROVED REWARDS: 80% chance of earning OMEGA tokens!', 'success');
                this.log('🎯 Possible rewards: 0.001-1.0 OMEGA per successful mine', 'info');
                const miningAnimationFrames = ['⛏️', '🔨', '🪓', '⛏️', '🔨', '🪓'];
                let frame = 0;
                const mineLoop = async () => {
                    if (!this.isMining) return;
                    try {
                        const address = await this.signer.getAddress();
                        // Show mining animation with cool steps
                        let animSteps = [
                            { icon: '🔍', text: 'Verifying nonce...' },
                            { icon: '🔗', text: 'Connecting to Omega miners...' },
                            { icon: '💾', text: 'Loading mining algorithm...' },
                            { icon: '🔒', text: () => {
                                const lockFrames = ['/', '-', '\\', '|'];
                                let lockFrame = lockFrames[Math.floor(Math.random() * lockFrames.length)];
                                const fakeHash = this.generateFakeHash().slice(0, 32) + '...';
                                return `[${lockFrame}] Hash: ${fakeHash}`;
                            } },
                            { icon: '⚡', text: 'Crunching numbers...' },
                            { icon: '🧮', text: 'Calculating reward probability...' }
                        ];
                        for (let step of animSteps) {
                            let line = document.createElement('div');
                            line.className = 'output info';
                            line.textContent = typeof step.text === 'function' ? `${step.icon} ${step.text()}` : `${step.icon} ${step.text}`;
                            document.getElementById('terminalContent').appendChild(line);
                            document.getElementById('terminalContent').scrollTop = document.getElementById('terminalContent').scrollHeight;
                            await new Promise(r => setTimeout(r, 200));
                        }
                        // Send mining request
                        this.log('⛏️ Sending mining request to network...', 'info');
                        const res = await fetch(RELAYER_URL + '/mine', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ address })
                        });
                        const data = await res.json();
                        if (!data.success) {
                            this.log('⛏️  Block mined (no reward this time)', 'output');
                        } else {
                            this.logHtml(`📤 Mining tx sent: <span class="copyable" onclick="navigator.clipboard.writeText('${data.txHash}')">${data.txHash}</span>`, 'info');
                            if (data.reward && data.reward > 0) {
                                this.totalEarned += parseFloat(data.reward);
                                this.log(`💰 Mining reward: +${data.reward} OMEGA`, 'success');
                                this.log(`🏆 Session total: ${this.totalEarned.toFixed(4)} OMEGA`, 'info');
                                this.log('💡 Use "claim" to withdraw your rewards!', 'success');
                            } else {
                                this.log('⛏️  Block mined (no reward this time)', 'output');
                            }
                        }
                    } catch (error) {
                        // Handle mining failures gracefully - just show no block mined
                        this.log('⛏️  Block mined (no reward this time)', 'output');
                    }
                    if (this.isMining) {
                        setTimeout(mineLoop, 8000); // Faster mining - 8 seconds instead of 15
                    }
                };
                mineLoop();
            }
            
            async startAutomatedMiningLoop() {
                const mineNextBlock = async () => {
                    if (!this.isMining) return;

                    try {
                        this.mineCount++;
                        const nonce = this.miningNonce;
                        this.miningNonce++;
                        const solution = this.generateRandomSolution();
                        this.log(`⛏️  Mining block #${this.mineCount}...`, 'info');
                        this.log(`🎯 Nonce: ${nonce}`, 'output');
                        // --- Begin hashing animation ---
                        const spinnerFrames = ['|', '/', '-', '\\'];
                        let spinnerIndex = 0;
                        for (let i = 0; i < 6; i++) { // Reduced from 10 to 6 iterations
                            await new Promise(resolve => setTimeout(resolve, 50)); // Faster animation - 50ms instead of 80ms
                            this.log(`🔒 [${spinnerFrames[spinnerIndex]}] Hashing: ${this.generateFakeHash()}`, 'output');
                            spinnerIndex = (spinnerIndex + 1) % spinnerFrames.length;
                        }
                        // --- End hashing animation ---
                        this.log(`🔑 Solution: ${solution.slice(0, 16)}...`, 'output');
                        const tx = await this.contract.connect(this.miningWallet).mineBlock(nonce, solution, {
                            gasLimit: 200000,
                            gasPrice: await this.provider.getGasPrice()
                        });
                        this.logHtml(`📤 Transaction sent: <span class="copyable" onclick="navigator.clipboard.writeText('${tx.hash}').then(() => window.terminal.log('✅ Transaction hash copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy transaction hash', 'error'))">${tx.hash}</span>`, 'info');
                        const receipt = await tx.wait();
                        if (receipt.status === 1) {
                            try {
                                const minerInfo = await this.contract.getMinerInfo(this.miningWallet.address);
                                const pendingRewards = minerInfo[2];
                                const rewardInWei = pendingRewards;
                                const rewardInEther = this.ethers.utils.formatEther(rewardInWei);
                                if (rewardInWei.gt(0)) {
                                    this.totalEarned += parseFloat(rewardInEther);
                                    this.log(`💰 Mining reward: +${rewardInEther} OMEGA`, 'success');
                                    this.log(`💳 Total earned this session: ${this.totalEarned.toFixed(6)} OMEGA`, 'info');
                                } else {
                                    this.log(`⛏️  Block mined (no reward this time)`, 'output');
                                }
                            } catch (error) {
                                this.log(`⚠️ Could not fetch reward info: ${error.message}`, 'warning');
                                const simulatedReward = this.calculateMiningReward();
                                if (simulatedReward > 0) {
                                    this.totalEarned += simulatedReward;
                                    this.log(`💰 Mining reward: +${simulatedReward.toFixed(6)} OMEGA (simulated)`, 'success');
                                    this.log(`💳 Total earned this session: ${this.totalEarned.toFixed(6)} OMEGA`, 'info');
                                } else {
                                    this.log(`⛏️  Block mined (no reward this time)`, 'output');
                                }
                            }
                        } else {
                            this.log(`⛏️  Block mined (no reward this time)`, 'output');
                        }
                    } catch (error) {
                        // Handle mining failures gracefully - just show no block mined
                        this.log('⛏️  Block mined (no reward this time)', 'output');
                        
                        // Still handle nonce issues silently
                        if (error.message && (error.message.includes('nonce') || error.message.includes('replacement'))) {
                            this.miningNonce = await this.provider.getTransactionCount(this.miningWallet.address, 'latest');
                        }
                    }
                    if (this.isMining) setTimeout(mineNextBlock, 8000); // Faster mining - 8 seconds instead of 15
                };
                mineNextBlock();
            }
            
            generateRandomSolution() {
                const chars = '0123456789abcdef';
                let solution = '0x';
                for (let i = 0; i < 64; i++) {
                    solution += chars[Math.floor(Math.random() * chars.length)];
                }
                return solution;
            }
            
            calculateMiningReward() {
                const random = Math.random();
                
                // IMPROVED: Much better reward distribution for user engagement
                // 5% chance for big reward (0.5-1.0 OMEGA)
                if (random < 0.05) {
                    return parseFloat((Math.random() * 0.5 + 0.5).toFixed(4));
                }
                // 15% chance for good reward (0.1-0.5 OMEGA)
                else if (random < 0.20) {
                    return parseFloat((Math.random() * 0.4 + 0.1).toFixed(4));
                }
                // 25% chance for medium reward (0.01-0.1 OMEGA)
                else if (random < 0.45) {
                    return parseFloat((Math.random() * 0.09 + 0.01).toFixed(4));
                }
                // 35% chance for small reward (0.001-0.01 OMEGA)
                else if (random < 0.80) {
                    return parseFloat((Math.random() * 0.009 + 0.001).toFixed(4));
                }
                // 20% chance for no reward (reduced from 60%)
                else {
                    return 0;
                }
            }
            
            generateFakeHash() {
                const chars = '0123456789abcdef';
                let hash = '0x';
                for (let i = 0; i < 64; i++) {
                    hash += chars[Math.floor(Math.random() * chars.length)];
                }
                return hash;
            }
            
            // Add missing methods that are referenced in the code
            logCommand(command) {
                const terminalContent = document.getElementById('terminalContent');
                const line = document.createElement('div');
                line.className = 'terminal-line';
                line.innerHTML = `<span class="prompt">root@omega-miner:~$</span><span class="command"> ${command}</span>`;
                terminalContent.appendChild(line);
                terminalContent.scrollTop = terminalContent.scrollHeight;
                // Store in tab history
                const tab = this.tabs[this.activeTab];
                if (tab) tab.history.push({ type: 'command', content: command });
            }
            
            log(message, type = 'output') {
                const terminalContent = document.getElementById('terminalContent');
                const line = document.createElement('div');
                line.className = `output ${type}`;
                line.textContent = message;
                terminalContent.appendChild(line);
                terminalContent.scrollTop = terminalContent.scrollHeight;
                // Store in tab history
                const tab = this.tabs[this.activeTab];
                if (tab) tab.history.push({ type: 'output', content: message, logType: type });
            }
            
            logHtml(html, type = 'output') {
                const terminalContent = document.getElementById('terminalContent');
                const line = document.createElement('div');
                line.className = `terminal-line ${type}`;
                line.innerHTML = html;
                terminalContent.appendChild(line);
                terminalContent.scrollTop = terminalContent.scrollHeight;
                // Store in tab history
                const tab = this.tabs[this.activeTab];
                if (tab) tab.history.push({ type: 'output', content: html, logType: type });
            }
            
            clearTerminal() {
                const terminalContent = document.getElementById('terminalContent');
                terminalContent.innerHTML = '';
            }
            
            updateConnectionStatus(status) {
                const statusElement = document.getElementById('connectionStatus');
                if (statusElement) {
                    statusElement.textContent = status;
                }
            }
            
            // Replace old showHelp with unified version
            showHelp() { this.showUnifiedHelp(); }
            
            async checkNetwork() {
                this.log('🔍 Checking network configuration...', 'info');
                
                // Check if wallet is connected
                if (!this.provider) {
                    this.log('❌ No wallet provider available', 'error');
                    this.log('💡 Connect your wallet first using: connect', 'info');
                    return;
                }
                
                try {
                    // Get current network from provider
                    const network = await this.provider.getNetwork();
                    this.log(`📡 Current Network:`, 'info');
                    this.log(`   Chain ID: ${network.chainId} (0x${network.chainId.toString(16)})`, 'info');
                    this.log(`   Name: ${network.name || 'Unknown'}`, 'info');
                    
                    // Check if we're on the correct network
                    const expectedChainId = 1313161768; // 0x4e454228
                    if (network.chainId === expectedChainId) {
                        this.log('✅ Connected to Omega Network!', 'success');
                    } else {
                        this.log('❌ Not connected to Omega Network', 'error');
                        this.log(`💡 Expected Chain ID: ${expectedChainId} (0x4e454228)`, 'info');
                        this.log(`💡 Current Chain ID: ${network.chainId} (0x${network.chainId.toString(16)})`, 'info');
                        this.log('💡 Use "connect" to switch to Omega Network', 'info');
                    }
                    
                    // Show network configuration that would be sent to MetaMask
                    this.log('🔧 Network Configuration (for MetaMask):', 'info');
                    this.log(`   Chain ID: 0x4e454228 (${parseInt('0x4e454228', 16)} decimal)`, 'info');
                    this.log(`   RPC URL: https://0x4e454228.rpc.aurora-cloud.dev`, 'info');
                    this.log(`   Explorer: https://0x4e454228.explorer.aurora-cloud.dev/`, 'info');
                    
                    // Check what the RPC endpoint actually returns
                    this.log('🔍 Checking RPC endpoint chain ID...', 'info');
                    try {
                        const rpcResponse = await fetch('https://0x4e454228.rpc.aurora-cloud.dev', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                jsonrpc: '2.0',
                                method: 'eth_chainId',
                                params: [],
                                id: 1
                            })
                        });
                        const rpcData = await rpcResponse.json();
                        if (rpcData.result) {
                            const rpcChainId = parseInt(rpcData.result, 16);
                            this.log(`📡 RPC Endpoint Chain ID: ${rpcChainId} (${rpcData.result})`, 'info');
                            
                            if (rpcChainId === 1313161768) {
                                this.log('✅ RPC endpoint returns correct chain ID', 'success');
                            } else {
                                this.log('❌ RPC endpoint returns different chain ID than expected', 'error');
                                this.log(`💡 This explains the MetaMask mismatch warning`, 'info');
                            }
                        } else {
                            this.log('❌ Could not get chain ID from RPC endpoint', 'error');
                        }
                    } catch (rpcError) {
                        this.log(`❌ Error checking RPC endpoint: ${rpcError.message}`, 'error');
                    }
                    
                } catch (error) {
                    this.log(`❌ Error checking network: ${error.message}`, 'error');
                }
            }
            
            async forceAddNetwork() {
                this.log('🔄 Force adding Omega Network with correct configuration...', 'info');
                
                if (!this.provider) {
                    this.log('❌ No wallet provider available', 'error');
                    this.log('💡 Connect your wallet first using: connect', 'info');
                    return;
                }
                
                try {
                    // First, try to remove any existing Omega network
                    // Note: Removed old chain ID 0x330 reference to prevent conflicts
                    this.log('ℹ️ Skipping old network removal (0x330) to prevent conflicts', 'info');
                    
                    try {
                        await this.provider.request({
                            method: 'wallet_removeEthereumChain',
                            params: [{ chainId: '0x4e454228' }] // New chain ID
                        });
                        this.log('🗑️ Removed existing Omega network configuration', 'info');
                    } catch (removeError) {
                        // Ignore errors if network doesn't exist
                        this.log('ℹ️ No existing network to remove', 'info');
                    }
                    
                    // Now add the correct network configuration
                    const networkConfig = {
                        chainId: '0x4e454228',
                        chainName: 'Omega Network',
                        nativeCurrency: { name: 'OMEGA', symbol: 'OMEGA', decimals: 18 },
                        rpcUrls: ['https://0x4e454228.rpc.aurora-cloud.dev'],
                        blockExplorerUrls: ['https://0x4e454228.explorer.aurora-cloud.dev/']
                    };
                    
                    this.log('🔧 Adding network with correct configuration:', 'info');
                    this.log(`   Chain ID: ${networkConfig.chainId} (${parseInt(networkConfig.chainId, 16)} decimal)`, 'info');
                    this.log(`   RPC URL: ${networkConfig.rpcUrls[0]}`, 'info');
                    this.log(`   Explorer: ${networkConfig.blockExplorerUrls[0]}`, 'info');
                    
                    await this.provider.request({
                        method: 'wallet_addEthereumChain',
                        params: [networkConfig]
                    });
                    
                    this.log('✅ Successfully added Omega network with correct configuration!', 'success');
                    this.log('💡 You may need to manually switch to the network in MetaMask', 'info');
                    
                } catch (error) {
                    this.log(`❌ Failed to force add network: ${error.message}`, 'error');
                    this.log('💡 Try manually removing the Omega network from MetaMask and reconnecting', 'info');
                }
            }
            
            async checkRpcChainId() {
                this.log('🔍 Checking RPC endpoint chain ID directly...', 'info');
                
                try {
                    const rpcResponse = await fetch('https://0x4e454228.rpc.aurora-cloud.dev', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            jsonrpc: '2.0',
                            method: 'eth_chainId',
                            params: [],
                            id: 1
                        })
                    });
                    
                    const rpcData = await rpcResponse.json();
                    this.log('📡 RPC Response:', 'info');
                    this.log(`   Raw response: ${JSON.stringify(rpcData)}`, 'info');
                    
                    if (rpcData.result) {
                        const rpcChainId = parseInt(rpcData.result, 16);
                        this.log(`📡 RPC Endpoint Chain ID: ${rpcChainId} (${rpcData.result})`, 'info');
                        
                        const expectedChainId = 1313161768; // 0x4e454228
                        if (rpcChainId === expectedChainId) {
                            this.log('✅ RPC endpoint returns correct chain ID', 'success');
                        } else {
                            this.log('❌ RPC endpoint returns different chain ID than expected', 'error');
                            this.log(`💡 Expected: ${expectedChainId} (0x4e454228)`, 'info');
                            this.log(`💡 Actual: ${rpcChainId} (${rpcData.result})`, 'info');
                            this.log(`💡 This mismatch explains the MetaMask warning`, 'info');
                        }
                    } else {
                        this.log('❌ Could not get chain ID from RPC endpoint', 'error');
                        this.log(`💡 Error: ${rpcData.error || 'Unknown error'}`, 'error');
                    }
                } catch (rpcError) {
                    this.log(`❌ Error checking RPC endpoint: ${rpcError.message}`, 'error');
                }
            }
            
            async showBalance() {
                this.logHtml('<b>Wallets:</b>', 'output');
                
                // Omega Wallet
                this.logHtml('<b>Omega Wallet:</b>', 'output');
                if (this.signer) {
                    try {
                        const address = await this.signer.getAddress();
                        const balance = await this.provider.getBalance(address);
                        const formattedBalance = this.ethers.utils.formatEther(balance);
                        this.logHtml(`  Balance: <b>${formattedBalance} OMEGA</b>`, 'output');
                        this.logHtml(`  Address: <span style="color:#99ccff">${address}</span>`, 'output');
                        
                        // Show claimable OMEGA from relayer
                        try {
                            const claimableRes = await fetch(RELAYER_URL + '/claimable', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ address })
                            });
                            const claimableData = await claimableRes.json();
                            if (claimableData.success && claimableData.amount > 0) {
                                this.logHtml(`  🪙 <span style='color:#ffcc00'>Claimable OMEGA (Network):</span> <b>${claimableData.amount} OMEGA</b>`, 'output');
                            } else {
                                this.logHtml(`  🪙 <span style='color:#ffcc00'>Claimable OMEGA (Network):</span> <b>0 OMEGA</b>`, 'output');
                            }
                        } catch (err) {
                            this.logHtml(`  🪙 <span style='color:#ffcc00'>Claimable OMEGA (Network):</span> <b>N/A</b> (Error: ${err.message})`, 'output');
                        }
                        
                    } catch (error) {
                        this.logHtml('  Balance: <b>N/A OMEGA</b>', 'output');
                        this.logHtml('  Address: <span style="color:#ff3333">N/A</span>', 'output');
                        this.logHtml('  [Error fetching OMEGA balance: ' + (error && error.message ? error.message : error) + ']', 'error');
                    }
                } else {
                    this.logHtml('  Balance: <b>N/A OMEGA</b>', 'output');
                    this.logHtml('  Address: <span style="color:#ff3333">Not connected</span>', 'output');
                }
                
                this.logHtml('&nbsp;', 'output');
                
                // Solana Wallet
                this.logHtml('<b>Solana Wallet:</b>', 'output');
                if (this.solanaAddress) {
                    try {
                        const body = {
                            "jsonrpc": "2.0",
                            "id": 1,
                            "method": "getBalance",
                            "params": [this.solanaAddress]
                        };
                        const res = await fetch('https://mainnet.helius-rpc.com/?api-key=94a04704-448e-45a8-82e5-8f4c63b25082', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(body)
                        });
                        const data = await res.json();
                        let sol = 'N/A';
                        if (data && data.result && typeof data.result.value === 'number') {
                            sol = data.result.value / 1e9;
                        }
                        this.logHtml(`  Balance: <b>${sol} SOL</b>`, 'output');
                    } catch (err) {
                        this.logHtml('  Balance: <b>N/A (Failed to fetch)</b>', 'output');
                    }
                    this.logHtml(`  Address: <span style="color:#99ccff">${this.solanaAddress}</span>`, 'output');
                } else {
                    this.logHtml('  Balance: <b>N/A SOL</b>', 'output');
                    this.logHtml('  Address: <span style="color:#ff3333">Not connected</span>', 'output');
                }
                
                this.logHtml('&nbsp;', 'output');
                
                // Hyperliquid Wallet
                this.logHtml('<b>Hyperliquid Wallet:</b>', 'output');
                if (window.hyperliquidApiWallet && window.hyperliquidApiWallet.address) {
                    this.logHtml(`  Address: <span style='color:#99ccff'>${window.hyperliquidApiWallet.address}</span>`, 'output');
                    this.logHtml(`  Private Key: <span style='color:#ff3333'>${window.hyperliquidApiWallet.privHex}</span>`, 'output');
                } else {
                    this.logHtml('  No Hyperliquid API wallet generated in this session.', 'output');
                    this.logHtml('  To generate a wallet, type: <b>hyperliquid gen-wallet</b>', 'output');
                }
                
                this.logHtml('&nbsp;', 'output');
                
                // Eclipse Wallet
                this.logHtml('<b>Eclipse Wallet:</b>', 'output');
                if (window.eclipseWallet && window.eclipseWallet.publicKey) {
                    try {
                        const connection = new window.solanaWeb3.Connection(window.eclipseWallet.rpcUrl, 'confirmed');
                        const publicKey = new window.solanaWeb3.PublicKey(window.eclipseWallet.publicKey);
                        const balance = await connection.getBalance(publicKey);
                        const balanceInSol = (balance / 1e9).toLocaleString(undefined, {minimumFractionDigits: 4, maximumFractionDigits: 8});
                        this.logHtml(`  Balance: <b>${balanceInSol} SOL</b>`, 'output');
                        this.logHtml(`  Address: <span style="color:#99ccff">${window.eclipseWallet.publicKey}</span>`, 'output');
                    } catch (err) {
                        this.logHtml('  Balance: <b>N/A SOL</b>', 'output');
                        this.logHtml(`  Address: <span style="color:#99ccff">${window.eclipseWallet.publicKey}</span>`, 'output');
                        this.logHtml('  [Error fetching Eclipse balance: ' + (err && err.message ? err.message : err) + ']', 'error');
                    }
                } else {
                    this.logHtml('  No Eclipse API wallet generated in this session.', 'output');
                    this.logHtml('  To generate a wallet, type: <b>eclipse gen-wallet</b>', 'output');
                }
            }
            
            async showStatus() {
                if (!this.signer) {
                    this.log('❌ Wallet not connected', 'error');
                    return;
                }
                
                try {
                    const address = await this.signer.getAddress();
                    this.log(`✅ Wallet: ${address}`, 'success');
                    this.log(`⛏️  Mining: ${this.isMining ? 'Active' : 'Inactive'}`, 'info');
                    this.log(`💰 Pending: ${this.totalEarned.toFixed(6)} OMEGA`, 'info');
                    this.log(`📊 Blocks Mined: ${this.mineCount || 0}`, 'info');
                } catch (error) {
                    this.log('❌ Failed to get status: ' + error.message, 'error');
                }
            }
            
            async showStats() {
                this.log('📊 Mining Statistics:', 'info');
                this.log(`⛏️  Total Blocks: ${this.mineCount || 0}`, 'output');
                this.log(`👻 Ghost Transactions: ${this.ghostTransactionCount || 0}`, 'output');
                this.log(`💰 Total Earned: ${this.totalEarned.toFixed(6)} OMEGA`, 'output');
                this.log(`⏱️  Session Time: ${this.startTime ? Math.floor((Date.now() - this.startTime) / 1000) : 0}s`, 'output');
                this.log(`🎯 Reward Structure: Avg 0.0001 | Max 1.0 OMEGA`, 'output');
            }
            
            stopAll() {
                let stoppedActivities = [];
                
                // Stop mining
                if (this.isMining) {
                    this.isMining = false;
                    stoppedActivities.push('mining');
                    this.log('⏹️  Mining stopped.', 'info');
                }
                
                // Stop stress testing
                if (this.isStressTesting) {
                    this.isStressTesting = false;
                    if (this.stressTestInterval) {
                        clearInterval(this.stressTestInterval);
                        this.stressTestInterval = null;
                    }
                    stoppedActivities.push('stress testing');
                }
                
                // Also clear stress funding interval if running
                if (this.stressFundingInterval) {
                    clearInterval(this.stressFundingInterval);
                    this.stressFundingInterval = null;
                }
                
                if (stoppedActivities.length > 0) {
                    this.log(`⏹️  Stopped: ${stoppedActivities.join(', ')}`, 'success');
                } else {
                    this.log('⏹️  No activities were running to stop', 'info');
                }
            }
            
            async startMiningSession() {
                this.log('🚀 Starting mining session...', 'info');
                await this.mine();
            }
            
            async faucetClaim() {
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }
                if (this.sessionOmegaWallet) {
                    const approved = await this.confirmOmegaTransaction();
                    if (!approved) return;
                }
                try {
                    this.log('🚰 Claiming from faucet...', 'info');
                    const faucetContract = new this.ethers.Contract(this.faucetAddress, this.faucetABI, this.signer);
                    const tx = await faucetContract.claim({ gasLimit: 100000 });
                    await tx.wait();
                    this.log('✅ Faucet claim successful!', 'success');
                } catch (error) {
                    this.log('❌ Faucet claim failed: ' + error.message, 'error');
                }
            }
            
            async showPendingRewards() {
                const minerInfo = await this.contract.getMinerInfo(this.miningWallet.address);
                const pendingRewards = this.ethers.utils.formatEther(minerInfo[2]);
                this.log(`💰 Pending Rewards: ${pendingRewards} OMEGA`, 'info');
                if (parseFloat(pendingRewards) > 0) {
                    this.log('💡 Use "claim" command to collect rewards', 'info');
                }
            }
            
            async depositForMining() {
                this.log('💡 This feature is not yet implemented', 'info');
            }
            
            async deployContract() {
                this.log('💡 Contract deployment is handled separately', 'info');
            }
            
            async showContractInfo() {
                this.log(`📋 Mining Contract: ${this.contractAddress}`, 'info');
                this.log(`🚰 Faucet Contract: ${this.faucetAddress}`, 'info');
            }
            
            async startStressTest() {
                if (!this.ethers || !this.provider || !this.provider.getNetwork) {
                    this.log('Ethers library or provider not loaded. Please refresh the page and connect your wallet.', 'error');
                    return;
                }
                const network = await this.provider.getNetwork();
                if (!network || !network.chainId || network.chainId === 0) {
                    this.log('⚠️ No valid network detected - stress test will not send real transactions.', 'warning');
                    return;
                }
                if (this.isStressTesting) {
                    this.log('Stress test already running. Use "stopstress" to stop it.', 'warning');
                    return;
                }
                
                // Generate a new wallet for the stress test
                this.stressWallet = this.ethers.Wallet.createRandom();
                this.log('🆕 Stress Test Wallet Generated:', 'info');
                this.logHtml('Address: <span class="copyable" onclick="navigator.clipboard.writeText(\'' + this.stressWallet.address + '\').then(() => window.terminal.log(\'✅ Address copied to clipboard!\', \'success\')).catch(() => window.terminal.log(\'❌ Failed to copy address\', \'error\'))">' + this.stressWallet.address + '</span>', 'output');
                this.logHtml('💡 <span style="color:#00ff99;cursor:pointer;text-decoration:underline;" onclick="window.terminal.fundStressWallet(\'0.001\')">[Click here to fund with 0.001 OMEGA]</span>', 'info');
                
                // Connect wallet to provider
                this.stressWallet = this.stressWallet.connect(this.provider);
                
                // Wait for funding
                this.log('⏳ Waiting for funding to initiate stress test...', 'info');
                this.isStressTesting = true;
                this.stressTestStats = {
                    walletsCreated: 0,
                    transactionsSent: 0,
                    successfulTxs: 0,
                    failedTxs: 0,
                    startTime: Date.now()
                };
                
                // Poll for funding every 5 seconds
                this.stressFundingInterval = setInterval(async () => {
                    const balance = await this.provider.getBalance(this.stressWallet.address);
                    if (!balance.isZero()) {
                        clearInterval(this.stressFundingInterval);
                        this.log('✅ Funding detected! Starting stress test...', 'success');
                        // Fetch and store the starting nonce
                        this.localNonce = await this.provider.getTransactionCount(this.stressWallet.address, 'latest');
                        this.startStressTestCycle();
                    }
                }, 5000);
            }

            startStressTestCycle() {
                this.stressTestInterval = setInterval(() => {
                    if (this.isStressTesting) {
                        this.runStressTestCycle();
                    }
                }, 3000);
                this.log('✅ Stress test will now begin!', 'success');
            }

            async runStressTestCycle() {
                try {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    const newWallet = this.ethers.Wallet.createRandom();
                    this.stressTestStats.walletsCreated++;
                    const gasPrice = await this.provider.getGasPrice();

                    // Log stress wallet address and balance before sending
                    const stressAddress = this.stressWallet.address;
                    const balance = await this.provider.getBalance(stressAddress);
                    this.log(`[DEBUG] Stress wallet: ${stressAddress}, Balance: ${this.ethers.utils.formatEther(balance)} OMEGA`, 'info');
                    this.log(`[DEBUG] Provider: ${this.provider.connection && this.provider.connection.url ? this.provider.connection.url : 'unknown'}`, 'info');
                    
                    // Use and increment local nonce
                    const nonce = this.localNonce;
                    this.localNonce++;
                    
                    const txObj = {
                        to: newWallet.address,
                        value: 0,
                        gasLimit: 21000,
                        gasPrice: gasPrice,
                        nonce: nonce
                    };
                    this.log(`[DEBUG] Sending tx: ${JSON.stringify(txObj)}`, 'info');

                    const tx = await this.stressWallet.sendTransaction(txObj);
                    
                    this.stressTestStats.transactionsSent++;
                    this.log(`📤 Sent empty tx to ${newWallet.address.slice(0, 10)}... (hash: ${tx.hash})`, 'info');
                    this.stressTestStats.successfulTxs++;
                } catch (err) {
                    this.stressTestStats.failedTxs++;
                    this.log(`[DEBUG] Error: ${err && err.stack ? err.stack : err}`, 'error');
                    // If nonce error, re-sync local nonce
                    if (err.message && (err.message.includes('nonce') || err.message.includes('replacement'))) {
                        this.log('🔄 Nonce error detected, re-syncing nonce from network...', 'warning');
                        this.localNonce = await this.provider.getTransactionCount(this.stressWallet.address, 'latest');
                    } else if (err.message && err.message.includes('Internal JSON-RPC error')) {
                        this.log(`⚠️ RPC overload - slowing down...`, 'warning');
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    } else {
                        this.log(`❌ Transaction failed: ${err.message}`, 'error');
                    }
                }
            }

            stopStressTest() {
                if (!this.isStressTesting) {
                    this.log('No stress test running.', 'warning');
                    return;
                }
                
                if (this.stressTestInterval) {
                    clearInterval(this.stressTestInterval);
                }
                if (this.stressFundingInterval) {
                    clearInterval(this.stressFundingInterval);
                }
                
                this.isStressTesting = false;
                this.log('🛑 Stress test stopped.', 'warning');
                this.showStressStats();
            }
            
            showStressStats() {
                if (!this.stressTestStats.startTime) {
                    this.log('No stress test has been run yet.', 'info');
                    return;
                }
                
                const runtime = Math.floor((Date.now() - this.stressTestStats.startTime) / 1000);
                const successRate = this.stressTestStats.transactionsSent > 0 
                    ? ((this.stressTestStats.successfulTxs / this.stressTestStats.transactionsSent) * 100).toFixed(1)
                    : 0;
                
                this.log('=== STRESS TEST STATISTICS ===', 'info');
                this.log(`Runtime: ${runtime} seconds`, 'output');
                this.log(`Wallets Created: ${this.stressTestStats.walletsCreated}`, 'output');
                this.log(`Transactions Sent: ${this.stressTestStats.transactionsSent}`, 'output');
                this.log(`Successful: ${this.stressTestStats.successfulTxs}`, 'success');
                this.log(`Failed: ${this.stressTestStats.failedTxs}`, 'error');
                this.log(`Success Rate: ${successRate}%`, 'output');
                this.log(`Status: ${this.isStressTesting ? 'RUNNING' : 'STOPPED'}`, this.isStressTesting ? 'success' : 'warning');
            }
            
            async showMiningStats() {
                await this.showStats();
            }
            
            async rickroll() {
                this.log('🎵 Never gonna give you up...', 'info');
                this.log('🎵 Never gonna let you down...', 'info');
                this.log('🎵 Never gonna run around and desert you...', 'info');
                this.log('🎵 Never gonna make you cry...', 'info');
                this.log('🎵 Never gonna say goodbye...', 'info');
                this.log('🎵 Never gonna tell a lie and hurt you...', 'info');
                
                // Create and show Rickroll popup
                const modal = document.createElement('div');
                modal.id = 'rickrollModal';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;
                
                const videoContainer = document.createElement('div');
                videoContainer.style.cssText = `
                    position: relative;
                    width: 80%;
                    max-width: 800px;
                    height: 60%;
                    max-height: 450px;
                `;
                
                const closeBtn = document.createElement('button');
                closeBtn.textContent = '×';
                closeBtn.style.cssText = `
                    position: absolute;
                    top: -40px;
                    right: 0;
                    background: #ff3333;
                    color: white;
                    border: none;
                    font-size: 24px;
                    width: 40px;
                    height: 40px;
                    cursor: pointer;
                    border-radius: 50%;
                    z-index: 10001;
                `;
                closeBtn.onclick = () => {
                    document.body.removeChild(modal);
                };
                
                const iframe = document.createElement('iframe');
                iframe.src = 'https://www.youtube.com/embed/dQw4w9WgXcQ?autoplay=1';
                iframe.style.cssText = `
                    width: 100%;
                    height: 100%;
                    border: none;
                    border-radius: 10px;
                `;
                iframe.allow = 'autoplay; encrypted-media';
                
                videoContainer.appendChild(closeBtn);
                videoContainer.appendChild(iframe);
                modal.appendChild(videoContainer);
                document.body.appendChild(modal);
                
                // Auto-close after 30 seconds
                setTimeout(() => {
                    if (document.body.contains(modal)) {
                        document.body.removeChild(modal);
                    }
                }, 30000);
            }
            
            fortune() {
                const fortunes = [
                    "A beautiful, smart, and loving person will be coming into your life.",
                    "A dubious friend may be an enemy in camouflage.",
                    "A faithful friend is a strong defense.",
                    "A fresh start will put you on your way.",
                    "A golden egg of opportunity falls into your lap this month.",
                    "A lifetime friend shall soon be made.",
                    "A light heart carries you through all the hard times.",
                    "A new perspective will come with the new year.",
                    "A pleasant surprise is waiting for you.",
                    "A short pencil is usually better than a long memory any day."
                ];
                const fortune = fortunes[Math.floor(Math.random() * fortunes.length)];
                this.log(`🔮 Fortune: ${fortune}`, 'info');
            }
            
            async matrix() {
                this.log('🌐 Entering the Matrix...', 'info');
                for (let i = 0; i < 5; i++) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                    this.log('01010101010101010101010101010101', 'output');
                }
                this.log('🌐 Matrix mode activated!', 'success');
            }
            
            async hack() {
                this.log('💻 Hacker mode activated...', 'info');
                this.log('🔓 Bypassing security protocols...', 'output');
                this.log('🔓 Accessing mainframe...', 'output');
                this.log('🔓 Downloading classified data...', 'output');
                this.log('✅ Hack complete! You are now a l33t h4x0r!', 'success');
            }
            
            async disco() {
                this.log('🕺 Disco mode activated!', 'info');
                this.log('💃 Stayin\' alive, stayin\' alive...', 'output');
                this.log('🎵 Ah, ha, ha, ha, stayin\' alive, stayin\' alive...', 'output');
                this.log('✨ Disco fever!', 'success');
            }
            
            sudoMine() {
                this.log('🔐 Sudo access granted!', 'info');
                this.log('⚡ Super user mining mode activated!', 'success');
                this.log('🚀 Mining with admin privileges...', 'output');
                this.totalEarned += 0.1;
                this.log('💰 Admin bonus: +0.1 OMEGA', 'success');
            }

            async fundMiningWallet(amount) {
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }
                if (!this.miningWallet) {
                    this.log('No mining wallet found. Start mining first.', 'error');
                    return;
                }
                if (!amount || isNaN(amount) || Number(amount) <= 0) {
                    this.log('Invalid amount. Usage: fund <amount>', 'error');
                    return;
                }
                try {
                    this.log(`💰 Funding mining wallet with ${amount} OMEGA...`, 'info');
                    const tx = await this.signer.sendTransaction({
                        to: this.miningWallet.address,
                        value: this.ethers.utils.parseEther(amount),
                        gasLimit: 21000
                    });
                    this.log(`📤 Funding transaction sent: ${tx.hash}`, 'info');
                    this.log('⏳ Waiting for confirmation... (this may take a few seconds)', 'info');
                    await tx.wait();
                    this.log(`✅ Mining wallet funded with ${amount} OMEGA!`, 'success');
                } catch (error) {
                    if (error.code === 4001) {
                        this.log('❌ Transaction rejected by user.', 'error');
                    } else {
                    this.log('❌ Failed to fund mining wallet: ' + error.message, 'error');
                    }
                }
            }

            async fundStressWallet(amount) {
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }
                if (!this.stressWallet) {
                    this.log('No stress test wallet found. Start stress test first.', 'error');
                    return;
                }
                if (!amount || isNaN(amount) || Number(amount) <= 0) {
                    this.log('Invalid amount. Usage: fund <amount>', 'error');
                    return;
                }
                try {
                    this.log(`💰 Funding stress test wallet with ${amount} OMEGA...`, 'info');
                    const tx = await this.signer.sendTransaction({
                        to: this.stressWallet.address,
                        value: this.ethers.utils.parseEther(amount),
                        gasLimit: 21000
                    });
                    this.log(`📤 Funding transaction sent: ${tx.hash}`, 'info');
                    this.log('⏳ Waiting for confirmation... (this may take a few seconds)', 'info');
                    await tx.wait();
                    this.log(`✅ Stress test wallet funded with ${amount} OMEGA!`, 'success');
                } catch (error) {
                    if (error.code === 4001) {
                        this.log('❌ Transaction rejected by user.', 'error');
                    } else {
                        this.log('❌ Failed to fund stress test wallet: ' + error.message, 'error');
                    }
                }
            }

            async setTheme(theme) {
                const validThemes = ['dark', 'light', 'matrix', 'retro', 'powershell'];
                if (!validThemes.includes(theme)) {
                    this.log('Invalid theme. Available: dark, light, matrix, retro, powershell', 'error');
                    return;
                }
                document.body.classList.remove('theme-dark', 'theme-light', 'theme-matrix', 'theme-retro', 'theme-powershell');
                document.body.classList.add('theme-' + theme);
                const terminal = document.getElementById('terminal');
                if (terminal) {
                    terminal.classList.remove('theme-dark', 'theme-light', 'theme-matrix', 'theme-retro', 'theme-powershell');
                    terminal.classList.add('theme-' + theme);
                }
                localStorage.setItem('omega-terminal-theme', theme);
                this.log(`Theme set to ${theme} mode`, 'success');
            }

            toggleAIMode() {
                const aiToggle = document.querySelector('.ai-toggle');
                if (aiToggle.textContent.includes('(off)')) {
                    aiToggle.textContent = 'AI Mode (on)';
                    this.log('🤖 AI Mode: Coming in v2!', 'info');
                    this.log('💡 Enhanced assistance, smart suggestions, and contextual help will be available soon.', 'info');
                } else {
                    aiToggle.textContent = 'AI Mode (off)';
                    this.log('🤖 AI Mode: Disabled', 'info');
                }
            }

            toggleTheme() {
                this.isDarkTheme = !this.isDarkTheme;
                this.applyTheme();
                localStorage.setItem('omega-miner-theme', this.isDarkTheme ? 'dark' : 'light');
            }
            
            applyTheme() {
                const theme = localStorage.getItem('omega-terminal-theme') || 'dark';
                document.body.classList.remove('theme-dark', 'theme-light', 'theme-matrix', 'theme-retro', 'theme-powershell');
                document.body.classList.add('theme-' + theme);
                const terminal = document.getElementById('terminal');
                if (terminal) {
                    terminal.classList.remove('theme-dark', 'theme-light', 'theme-matrix', 'theme-retro', 'theme-powershell');
                    terminal.classList.add('theme-' + theme);
                }
                const themeToggle = document.querySelector('.theme-toggle');
                if (themeToggle) {
                    if (theme === 'dark') themeToggle.textContent = '☀️ Light';
                    else if (theme === 'light') themeToggle.textContent = '🌙 Dark';
                    else if (theme === 'matrix') themeToggle.textContent = '🟩 Matrix';
                    else if (theme === 'retro') themeToggle.textContent = '🟨 Retro';
                    else if (theme === 'powershell') themeToggle.textContent = '💻 PowerShell';
                }
            }

            async sendOmega(command) {
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }
                // Parse command: send <address_or_ens> <amount>
                const parts = command.trim().split(/\s+/);
                if (parts.length !== 3) {
                    this.log('Usage: send <address_or_ens> <amount>', 'warning');
                    return;
                }
                let address = parts[1];
                const amountStr = parts[2];
                
                // First, try to resolve as ENS name if it's not a valid address
                if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
                    this.log(`🔍 Resolving ENS name: ${address}...`, 'info');
                    try {
                        const ens = this.getENSContract();
                        const resolvedAddress = await ens.resolve(address);
                        if (resolvedAddress && resolvedAddress !== '0x0000000000000000000000000000000000000000') {
                            this.log(`✅ Resolved ${address} to ${resolvedAddress}`, 'success');
                            address = resolvedAddress;
                        } else {
                            this.log(`❌ ENS name not found: ${address}`, 'error');
                            return;
                        }
                    } catch (err) {
                        this.log(`❌ Failed to resolve ENS name: ${err.message}`, 'error');
                        return;
                    }
                }
                
                // Now validate the resolved address
                if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
                    this.log('Invalid address format.', 'error');
                    return;
                }
                
                let amount;
                try {
                    amount = this.ethers.utils.parseEther(amountStr);
                } catch (e) {
                    this.log('Invalid amount.', 'error');
                    return;
                }
                
                this.log(`🚀 Sending ${amountStr} OMEGA to ${address}...`, 'info');
                try {
                    const tx = await this.signer.sendTransaction({
                        to: address,
                        value: amount
                    });
                    this.log('⏳ Waiting for confirmation...', 'info');
                    await tx.wait();
                    this.log(`✅ Sent ${amountStr} OMEGA to ${address}!`, 'success');
                } catch (error) {
                    this.log('❌ Send failed: ' + error.message, 'error');
                }
            }

            async claim() {
                if (!this.signer) {
                    this.log('Please connect wallet first using "connect" command', 'error');
                    return;
                }
                try {
                    const address = await this.signer.getAddress();
                    this.log('💸 Sending claim request to network...', 'info');
                    const res = await fetch(RELAYER_URL + '/claim', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ address })
                    });
                    const data = await res.json();
                    if (data.success) {
                        this.log(`✅ Claimed ${data.amount} OMEGA to your wallet!`, 'success');
                        if (data.txHash) {
                            this.logHtml(`📤 Claim tx sent: <span class="copyable" onclick="navigator.clipboard.writeText('${data.txHash}')">${data.txHash}</span>`, 'info');
                        }
                    } else {
                        this.log('❌ Claim failed: ' + (data.error || 'Unknown error'), 'error');
                    }
                } catch (error) {
                    this.log('❌ Claim error: ' + error.message, 'error');
                }
            }

            // 1. Add ENS contract setup at the top of the class (after constructor or as a helper):
            getENSContract(signerOrProvider) {
                const abi = [
                    {"anonymous":false,"inputs":[{"indexed":true,"internalType":"string","name":"name","type":"string"},{"indexed":true,"internalType":"address","name":"owner","type":"address"}],"name":"NameRegistered","type":"event"},
                    {"inputs":[{"internalType":"string","name":"name","type":"string"}],"name":"register","outputs":[],"stateMutability":"nonpayable","type":"function"},
                    {"inputs":[{"internalType":"string","name":"name","type":"string"},{"internalType":"address","name":"newOwner","type":"address"}],"name":"transfer","outputs":[],"stateMutability":"nonpayable","type":"function"},
                    {"inputs":[{"internalType":"string","name":"","type":"string"}],"name":"names","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
                    {"inputs":[{"internalType":"string","name":"name","type":"string"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}
                ];
                return new this.ethers.Contract('0xd9ce49734db4f033362d2fd51d52f24cabeb87fa', abi, signerOrProvider || this.signer || this.provider);
            }

            // Chat functionality
            async sendDirectMessage(recipient, message) {
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }
                // Resolve ENS if needed
                let toAddress = recipient;
                if (!/^0x[a-fA-F0-9]{40}$/.test(recipient)) {
                    try {
                        const ens = this.getENSContract();
                        const resolved = await ens.resolve(recipient);
                        if (resolved && resolved !== '0x0000000000000000000000000000000000000000') {
                            toAddress = resolved;
                        } else {
                            this.log('❌ ENS name not found: ' + recipient, 'error');
                            return;
                        }
                    } catch (err) {
                        this.log('❌ Failed to resolve ENS: ' + err.message, 'error');
                        return;
                    }
                }
                // Send DM on-chain
                try {
                    const dmABI = [
                        {
                            "inputs": [
                                { "internalType": "address", "name": "to", "type": "address" },
                                { "internalType": "string", "name": "ensName", "type": "string" },
                                { "internalType": "string", "name": "message", "type": "string" }
                            ],
                            "name": "sendMessage",
                            "outputs": [],
                            "stateMutability": "nonpayable",
                            "type": "function"
                        },
                        {
                            "anonymous": false,
                            "inputs": [
                                { "indexed": true, "internalType": "address", "name": "from", "type": "address" },
                                { "indexed": true, "internalType": "address", "name": "to", "type": "address" },
                                { "indexed": false, "internalType": "string", "name": "message", "type": "string" },
                                { "indexed": false, "internalType": "uint256", "name": "timestamp", "type": "uint256" }
                            ],
                            "name": "DirectMessage",
                            "type": "event"
                        }
                    ];
                    const dmContract = new this.ethers.Contract('0x26e31516e5e7790f8aaa35278735970a93fee213', dmABI, this.signer);
                    let tx;
                    if (/^0x[a-fA-F0-9]{40}$/.test(recipient)) {
                        // It's an address
                        tx = await dmContract.sendMessage(recipient, '', message);
                    } else {
                        // It's an ENS name
                        tx = await dmContract.sendMessage('0x0000000000000000000000000000000000000000', recipient, message);
                    }
                    this.log('⏳ Sending Email on-chain... (tx: ' + tx.hash + ')', 'info');
                    await tx.wait();
                    this.log('✅ Email sent!', 'success');
                } catch (err) {
                    this.log('❌ Failed to send DM: ' + err.message, 'error');
                }
            }

            async showInbox(showAll = false) {
                try {
                    // Check if wallet is connected
                    if (!this.signer) {
                        this.log('❌ Please connect your wallet first using: connect', 'error');
                        return;
                    }
                    
                    const dmABI = [
                        {
                            "inputs": [
                                { "internalType": "address", "name": "to", "type": "address" },
                                { "internalType": "string", "name": "ensName", "type": "string" },
                                { "internalType": "string", "name": "message", "type": "string" }
                            ],
                            "name": "sendMessage",
                            "outputs": [],
                            "stateMutability": "nonpayable",
                            "type": "function"
                        },
                        {
                            "anonymous": false,
                            "inputs": [
                                { "indexed": true, "internalType": "address", "name": "from", "type": "address" },
                                { "indexed": true, "internalType": "address", "name": "to", "type": "address" },
                                { "indexed": false, "internalType": "string", "name": "message", "type": "string" },
                                { "indexed": false, "internalType": "uint256", "name": "timestamp", "type": "uint256" }
                            ],
                            "name": "DirectMessage",
                            "type": "event"
                        }
                    ];
                    const dmContract = new this.ethers.Contract('0x26e31516e5e7790f8aaa35278735970a93fee213', dmABI, this.provider);
                    const myAddr = await this.signer.getAddress();
                    const filter = dmContract.filters.DirectMessage(null, myAddr);
                    
                    // Fetch more historical messages - last 100k blocks (about 1-2 weeks)
                    this.log('Fetching inbox events from last 100,000 blocks...', 'info');
                    const events = await dmContract.queryFilter(filter, -100000);
                    
                    if (!events.length) {
                        this.log('No direct messages found.', 'info');
                        return;
                    }
                    
                    this.log('=== Inbox ===', 'info');
                    this.log(`Found ${events.length} messages total`, 'info');
                    
                    // Sort events by timestamp (newest first)
                    const sortedEvents = events.sort((a, b) => Number(b.args.timestamp) - Number(a.args.timestamp));
                    
                    // Show messages based on parameter
                    const messagesToShow = showAll ? sortedEvents : sortedEvents.slice(0, 25);
                    
                    for (let i = 0; i < messagesToShow.length; i++) {
                        const ev = messagesToShow[i];
                        let from = ev.args.from;
                        let ensName = '';
                        try {
                            ensName = await this.provider.lookupAddress(from);
                        } catch {}
                        let fromDisplay = ensName ? `(${ensName}) | ${from}` : from;
                        
                        // Format date more nicely
                        const date = new Date(Number(ev.args.timestamp) * 1000);
                        const timeAgo = this.getTimeAgo(date);
                        const formattedDate = date.toLocaleString();
                        
                        this.log('──────────────────────────────', 'output');
                        this.logHtml(
                            `<span id="${ev.transactionHash}"><span style="color:#fff">📧</span> <span style="color:#99ccff">From:</span> <span style="color:#fff">${fromDisplay}</span><br><span style="color:#99ccff">Time:</span> <span style="color:#fff">${formattedDate} (${timeAgo})</span><br><span style="color:#99ccff">Message:</span> <span style="color:#fff">${ev.args.message}</span><br><span style="color:#00ff99;cursor:pointer;text-decoration:underline;" onclick="document.getElementById('${ev.transactionHash}').style.display='none'">Delete</span> | <span style="color:#00ccff;cursor:pointer;text-decoration:underline;" onclick="window.terminal.prefillOeMailRecipient('${from}')">Reply</span></span>`,
                            'output'
                        );
                    }
                    
                    if (!showAll && events.length > 25) {
                        this.log(`Showing 25 of ${events.length} messages. Use 'inbox all' to see all messages.`, 'info');
                    } else if (showAll) {
                        this.log(`Showing all ${events.length} messages.`, 'info');
                    }
                    
                    console.log('DM events:', events);
                } catch (err) {
                    this.log('❌ Failed to fetch inbox: ' + err.message, 'error');
                }
            }

            prefillOeMailRecipient(address) {
                const input = document.getElementById('commandInput');
                if (input) {
                    window.terminal.tempDMRecipient = address;
                    window.terminal.awaitingDMRecipient = false;
                    window.terminal.awaitingDMMessage = true;
                    window.terminal.logHtml('<span style="color:#99ccff">Recipient:</span> <span style="color:#fff">' + address + '</span>', 'info');
                    window.terminal.log('Enter your message:', 'info');
                    input.value = '';
                    input.focus();
                }
            }

            getTimeAgo(date) {
                const now = new Date();
                const diffInSeconds = Math.floor((now - date) / 1000);
                
                if (diffInSeconds < 60) return `${diffInSeconds}s ago`;
                if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
                if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
                if (diffInSeconds < 2592000) return `${Math.floor(diffInSeconds / 86400)}d ago`;
                if (diffInSeconds < 31536000) return `${Math.floor(diffInSeconds / 2592000)}mo ago`;
                return `${Math.floor(diffInSeconds / 31536000)}y ago`;
            }

            async showFaucetStatus() {
                // VERSION CHECK - If you see this message, the updated code is loaded
                this.log('🔄 UPDATED CODE VERSION: Using direct RPC provider for faucet status', 'info');
                
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }
                try {
                    const address = await this.signer.getAddress();
                    
                    // Use direct RPC provider to avoid MetaMask issues
                    const OMEGA_RPC_URL = 'https://0x4e454228.rpc.aurora-cloud.dev';
                    const directProvider = new this.ethers.providers.JsonRpcProvider(OMEGA_RPC_URL);
                    const faucetContract = new this.ethers.Contract(this.faucetAddress, this.faucetABI, directProvider);
                    
                    // Get faucet status using direct RPC
                    const info = await faucetContract.getFaucetStatus(address);
                    
                    const canClaim = info.canClaimNow;
                    const lastClaim = info.lastClaim;
                    const timeUntil = info.timeUntilNextClaim;
                    const claimAmount = info.claimAmount;
                    const faucetBalance = info.faucetBalance;
                    
                    this.log('=== Faucet Status ===', 'info');
                    this.log(`Can claim now: ${canClaim ? '✅ Yes' : '❌ No'}`, canClaim ? 'success' : 'error');
                    if (!canClaim) {
                        const mins = Math.floor(timeUntil / 60);
                        const secs = timeUntil % 60;
                        this.log(`Time until next claim: ${mins}m ${secs}s`, 'warning');
                    }
                    this.log(`Faucet balance: ${this.ethers.utils.formatEther(faucetBalance)} OMEGA`, 'info');
                    this.log(`Claim amount: ${this.ethers.utils.formatEther(claimAmount)} OMEGA`, 'info');
                } catch (error) {
                    this.log('❌ Failed to fetch faucet status: ' + error.message, 'error');
                }
            }

            // Add this helper method to the class
            async isRealMetaMask() {
                this.log('DEBUG: isRealMetaMask() called', 'info');
                console.log('[DEBUG] isRealMetaMask() called');
                if (typeof window.ethereum !== 'undefined' && window.ethereum.isMetaMask) {
                    try {
                        await window.ethereum.request({ method: 'eth_accounts' });
                        this.log('DEBUG: isRealMetaMask() returns true', 'info');
                        console.log('[DEBUG] isRealMetaMask() returns true');
                        return true;
                    } catch (e) {
                        this.log('DEBUG: eth_accounts call failed, MetaMask not real', 'info');
                        console.log('[DEBUG] eth_accounts call failed, MetaMask not real');
                        return false;
                    }
                }
                this.log('DEBUG: isRealMetaMask() returns false', 'info');
                console.log('[DEBUG] isRealMetaMask() returns false');
                return false;
            }

            // Add this method to the OmegaMinerTerminal class
            promptTerminalInput() {
                this.awaitingPromptInput = true;
                return new Promise((resolve) => {
                    this.promptResolver = resolve;
                    const input = document.getElementById('commandInput');
                    input.focus();
                });
            }

            // Add a helper to confirm transactions for Omega Test Wallet
            async confirmOmegaTransaction() {
                if (this.sessionOmegaWallet) {
                    this.log('Approve transaction? (yes / no)', 'warning');
                    while (true) {
                        const input = await this.promptTerminalInput();
                        if (input.toLowerCase() === 'yes') return true;
                        if (input.toLowerCase() === 'no') {
                            this.log('Transaction cancelled.', 'error');
                            return false;
                        }
                        this.log('Please type either "yes" or "no".', 'warning');
                    }
                }
                return true;
            }

            async handleDexScreenerAlias(args) {
                if (args[1] === 'help') {
                    this.logHtml('<span style="color:#33bbff">Dexscreener API Commands:</span>', 'info');
                    this.logHtml('<span style="color:#99ccff">ds trending</span> - Show trending tokens', 'output');
                    this.logHtml('<span style="color:#99ccff">ds search [query]</span> - Search for tokens', 'output');
                    this.logHtml('<span style="color:#99ccff">ds pair [chainId] [pairId]</span> - Get pair info', 'output');
                    this.logHtml('<span style="color:#99ccff">ds pools</span> - List all pools', 'output');
                    this.logHtml('<span style="color:#99ccff">ds pools [chainId] [tokenAddress]</span> - Get pools for a token', 'output');
                    this.logHtml('<br><span style="color:#33bbff">Examples:</span>', 'info');
                    this.logHtml('<span style="color:#99ccff">ds trending</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">ds search OMEGA</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">ds pair 1 0x123...</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">ds pools</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">ds pools 1 0x123...</span>', 'output');
                    return;
                }
                // Map ds commands to relayer endpoints
                if (args[1] === 'trending') {
                    await this.handleDexScreenerCommand(['dexscreener', 'trending']);
                } else if (args[1] === 'search' && args[2]) {
                    await this.handleDexScreenerCommand(['dexscreener', 'search', ...args.slice(2)]);
                } else if (args[1] === 'pair' && args[2] && args[3]) {
                    // /dex/pair/:chainId/:pairId
                    const chainId = args[2];
                    const pairId = args[3];
                    this.log(`Fetching DexScreener pair info for chain ${chainId}, pair ${pairId}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/dex/pair/${chainId}/${pairId}`);
                        const data = await res.json();
                        this.logHtml(`<pre>${JSON.stringify(data, null, 2)}</pre>`, 'output');
                    } catch (e) {
                        this.log('DexScreener pair fetch failed: ' + e.message, 'error');
                    }
                } else if (args[1] === 'pools' && !args[2]) {
                    // /dex/pools
                    this.log('Fetching all DexScreener pools...', 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/dex/pools`);
                        const data = await res.json();
                        this.logHtml(`<pre>${JSON.stringify(data, null, 2)}</pre>`, 'output');
                    } catch (e) {
                        this.log('DexScreener pools fetch failed: ' + e.message, 'error');
                    }
                } else if (args[1] === 'pools' && args[2] && args[3]) {
                    // /dex/pools/:chainId/:tokenAddress
                    const chainId = args[2];
                    const tokenAddress = args[3];
                    this.log(`Fetching DexScreener pools for chain ${chainId}, token ${tokenAddress}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/dex/pools/${chainId}/${tokenAddress}`);
                        const data = await res.json();
                        this.logHtml(`<pre>${JSON.stringify(data, null, 2)}</pre>`, 'output');
                    } catch (e) {
                        this.log('DexScreener pools fetch failed: ' + e.message, 'error');
                    }
                } else {
                    this.log('Type ds help for available commands.', 'info');
                }
            }

            async handleGeckoTerminalAlias(args) {
                if (args[1] === 'help') {
                    this.logHtml('<span style="color:#33bbff">GeckoTerminal API Commands:</span>', 'info');
                    this.logHtml('<span style="color:#99ccff">cg search [query]</span> - Search for pairs', 'output');
                    this.logHtml('<span style="color:#99ccff">cg networks</span> - List networks', 'output');
                    this.logHtml('<span style="color:#99ccff">cg dexes [network]</span> - List dexes for a network', 'output');
                    this.logHtml('<span style="color:#99ccff">cg pools [network]</span> - List pools for a network', 'output');
                    this.logHtml('<span style="color:#99ccff">cg token [network] [address]</span> - Get token info', 'output');
                    this.logHtml('<span style="color:#99ccff">cg tokenpools [network] [token_address]</span> - Get pools for a token', 'output');
                    this.logHtml('<span style="color:#99ccff">cg poolinfo [network] [pool_address]</span> - Get pool info', 'output');
                    this.logHtml('<span style="color:#99ccff">cg ohlcv [network] [pool_address] [timeframe]</span> - Get OHLCV data', 'output');
                    this.logHtml('<span style="color:#99ccff">cg trades [network] [pool_address]</span> - Get trades for a pool', 'output');
                    this.logHtml('<br><span style="color:#33bbff">Examples:</span>', 'info');
                    this.logHtml('<span style="color:#99ccff">cg search OMEGA</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">cg networks</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">cg dexes ethereum</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">cg pools ethereum</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">cg token ethereum 0x123...</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">cg tokenpools ethereum 0x123...</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">cg poolinfo ethereum 0xabc...</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">cg ohlcv ethereum 0xabc... 1d</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">cg trades ethereum 0xabc...</span>', 'output');
                    return;
                }
                // Map cg commands to relayer endpoints
                if (args[1] === 'search' && args[2]) {
                    await this.handleGeckoTerminalCommand(['geckoterminal', 'search', ...args.slice(2)]);
                } else if (args[1] === 'networks') {
                    this.log('Fetching GeckoTerminal networks...', 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            this.logHtml('<b>Available Networks:</b>', 'output');
                            data.data.forEach((item) => {
                                const net = item.attributes;
                                const id = item.id;
                                const cg = net.coingecko_asset_platform_id ? ` | Coingecko: <b>${net.coingecko_asset_platform_id}</b>` : '';
                                this.logHtml(`<b>${net.name}</b> (<span style='color:#99ccff'>${id}</span>)${cg}`, 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No networks found.</span>', 'error');
                        }
                    } catch (e) {
                        this.log('GeckoTerminal networks fetch failed: ' + e.message, 'error');
                    }
                } else if (args[1] === 'dexes' && args[2]) {
                    const network = args[2];
                    this.log(`Fetching GeckoTerminal dexes for network: ${network}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/dexes`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            this.logHtml(`<b>DEXes for ${network}:</b>`, 'output');
                            data.data.forEach((item) => {
                                const dex = item.attributes;
                                const id = item.id;
                                this.logHtml(`<b>${dex.name}</b> (<span style='color:#99ccff'>${id}</span>)`, 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No DEXes found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal dexes fetch failed: ' + e.message, 'error');
                    }
                } else if (args[1] === 'pools' && args[2]) {
                    const network = args[2];
                    this.log(`Fetching GeckoTerminal pools for network: ${network}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/pools`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            this.logHtml(`<b>Pools for ${network}:</b>`, 'output');
                            data.data.forEach((item) => {
                                const pool = item.attributes;
                                this.logHtml(`<b>${pool.name}</b> | DEX: <b>${pool.dex_name}</b> | TVL: <b>${pool.tvl_usd || 'N/A'}</b>`, 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No pools found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal pools fetch failed: ' + e.message, 'error');
                    }
                } else if (args[1] === 'token' && args[2] && args[3]) {
                    const network = args[2];
                    const address = args[3];
                    this.log(`Fetching GeckoTerminal token info for network: ${network}, address: ${address}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/tokens/${address}`);
                        const data = await res.json();
                        if (data && data.data && data.data.attributes) {
                            const token = data.data.attributes;
                            this.logHtml(`<b>${token.name} (${token.symbol})</b>`, 'output');
                            this.logHtml(`Price: <b>${token.price_usd || 'N/A'}</b> | TVL: <b>${token.tvl_usd || 'N/A'}</b>`, 'output');
                            this.logHtml(`DEX Count: <b>${token.dex_count || 'N/A'}</b> | Pool Count: <b>${token.pool_count || 'N/A'}</b>`, 'output');
                            if (token.gecko_terminal_url) this.logHtml(`<a href="${token.gecko_terminal_url}" target="_blank">View on GeckoTerminal</a>`, 'output');
                        } else {
                            this.logHtml('<span style="color:#ff3333">No token info found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal token fetch failed: ' + e.message, 'error');
                    }
                } else if (args[1] === 'tokenpools' && args[2] && args[3]) {
                    const network = args[2];
                    const tokenAddress = args[3];
                    this.log(`Fetching GeckoTerminal pools for token: ${tokenAddress} on network: ${network}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/tokens/${tokenAddress}/pools`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            this.logHtml(`<b>Pools for token ${tokenAddress} on ${network}:</b>`, 'output');
                            data.data.forEach((item) => {
                                const pool = item.attributes;
                                this.logHtml(`<b>${pool.name}</b> | DEX: <b>${pool.dex_name}</b> | TVL: <b>${pool.tvl_usd || 'N/A'}</b>`, 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No pools found for this token.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal tokenpools fetch failed: ' + e.message, 'error');
                    }
                } else if (args[1] === 'poolinfo' && args[2] && args[3]) {
                    const network = args[2];
                    const poolAddress = args[3];
                    this.log(`Fetching GeckoTerminal pool info for network: ${network}, pool: ${poolAddress}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/pools/${poolAddress}/info`);
                        const data = await res.json();
                        if (data && data.data && data.data.attributes) {
                            const pool = data.data.attributes;
                            this.logHtml(`<b>${pool.name}</b> | DEX: <b>${pool.dex_name}</b> | TVL: <b>${pool.tvl_usd || 'N/A'}</b>`, 'output');
                            this.logHtml(`Base: <b>${pool.base_token_symbol}</b> | Quote: <b>${pool.quote_token_symbol}</b>`, 'output');
                            this.logHtml(`Price: <b>${pool.price_usd || 'N/A'}</b> | Volume 24h: <b>${pool.volume_usd_24h || 'N/A'}</b>`, 'output');
                            if (pool.gecko_terminal_url) this.logHtml(`<a href="${pool.gecko_terminal_url}" target="_blank">View on GeckoTerminal</a>`, 'output');
                        } else {
                            this.logHtml('<span style="color:#ff3333">No pool info found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal poolinfo fetch failed: ' + e.message, 'error');
                    }
                } else if (args[1] === 'ohlcv' && args[2] && args[3] && args[4]) {
                    const network = args[2];
                    const poolAddress = args[3];
                    const timeframe = args[4];
                    this.log(`Fetching GeckoTerminal OHLCV for network: ${network}, pool: ${poolAddress}, timeframe: ${timeframe}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/pools/${poolAddress}/ohlcv/${timeframe}`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            this.logHtml(`<b>OHLCV (${timeframe}) for pool ${poolAddress}:</b>`, 'output');
                            data.data.forEach((item) => {
                                this.logHtml(`<b>${item.timestamp}</b>: O: <b>${item.open}</b>, H: <b>${item.high}</b>, L: <b>${item.low}</b>, C: <b>${item.close}</b>, V: <b>${item.volume}</b>`, 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No OHLCV data found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal ohlcv fetch failed: ' + e.message, 'error');
                    }
                } else if (args[1] === 'trades' && args[2] && args[3]) {
                    const network = args[2];
                    const poolAddress = args[3];
                    this.log(`Fetching GeckoTerminal trades for network: ${network}, pool: ${poolAddress}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/pools/${poolAddress}/trades`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            this.logHtml(`<b>Recent trades for pool ${poolAddress}:</b>`, 'output');
                            data.data.slice(0, 10).forEach((item) => {
                                const trade = item.attributes;
                                this.logHtml(`<b>${trade.timestamp}</b>: <b>${trade.amount_usd || 'N/A'} USD</b> | Type: <b>${trade.trade_type}</b> | Price: <b>${trade.price_usd || 'N/A'}</b>`, 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No trades found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal trades fetch failed: ' + e.message, 'error');
                    }
                } else {
                    this.log('Type cg help for available commands.', 'info');
                }
            }

            async handleAlphaAlias(args) {
                if (args[1] === 'help') {
                    this.logHtml('<span style="color:#33bbff">Alpha Vantage API Commands:</span>', 'info');
                    this.logHtml('<span style="color:#99ccff">alpha quote [symbol]</span> - Get stock quote', 'output');
                    this.logHtml('<span style="color:#99ccff">alpha search [query]</span> - Search for stocks', 'output');
                    this.logHtml('<span style="color:#99ccff">alpha daily [symbol]</span> - Get daily stock data', 'output');
                    this.logHtml('<span style="color:#99ccff">alpha overview [symbol]</span> - Get stock overview', 'output');
                    this.logHtml('<span style="color:#99ccff">alpha inflation</span> - Get US inflation data', 'output');
                    this.logHtml('<span style="color:#99ccff">alpha cpi</span> - Get US CPI data', 'output');
                    this.logHtml('<span style="color:#99ccff">alpha gdp</span> - Get US GDP data', 'output');
                    this.logHtml('<br><span style="color:#33bbff">Examples:</span>', 'info');
                    this.logHtml('<span style="color:#99ccff">alpha quote IBM</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">alpha search Microsoft</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">alpha daily TSLA</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">alpha overview AAPL</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">alpha inflation</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">alpha cpi</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">alpha gdp</span>', 'output');
                    return;
                }
                // Map alpha commands to relayer endpoints
                if (args[1] === 'quote' && args[2]) {
                    await this.handleStockCommand(['stock', 'quote', args[2]]);
                } else if (args[1] === 'search' && args[2]) {
                    await this.handleStockCommand(['stock', 'search', ...args.slice(2)]);
                } else if (args[1] === 'daily' && args[2]) {
                    await this.handleStockCommand(['stock', 'daily', args[2]]);
                } else if (args[1] === 'overview' && args[2]) {
                    await this.handleStockCommand(['stock', 'overview', args[2]]);
                } else if (args[1] === 'inflation') {
                    await this.handleStockCommand(['stock', 'inflation']);
                } else if (args[1] === 'cpi') {
                    await this.handleStockCommand(['stock', 'cpi']);
                } else if (args[1] === 'gdp') {
                    await this.handleStockCommand(['stock', 'gdp']);
                } else {
                    this.log('Type alpha help for available commands.', 'info');
                }
            }

            async handleCreateCommand(args) {
                if (!this.provider || !this.signer) {
                    this.log('Please connect your wallet first using "connect"', 'error');
                    return;
                }

                // OmegaTokenFactory contract details
                const FACTORY_ADDRESS = '0x1f568dbb3a7b9ea05062b132094a848ef1443cfe';
                const FACTORY_ABI = [
                  {
                    "inputs": [
                      { "internalType": "string", "name": "name_", "type": "string" },
                      { "internalType": "string", "name": "symbol_", "type": "string" },
                      { "internalType": "uint8", "name": "decimals_", "type": "uint8" },
                      { "internalType": "uint256", "name": "initialSupply_", "type": "uint256" },
                      { "internalType": "bool", "name": "mintable_", "type": "bool" },
                      { "internalType": "bool", "name": "pausable_", "type": "bool" }
                    ],
                    "name": "createToken",
                    "outputs": [ { "internalType": "address", "name": "", "type": "address" } ],
                    "stateMutability": "nonpayable",
                    "type": "function"
                  },
                  {
                    "anonymous": false,
                    "inputs": [
                      { "indexed": true, "internalType": "address", "name": "creator", "type": "address" },
                      { "indexed": false, "internalType": "address", "name": "token", "type": "address" },
                      { "indexed": false, "internalType": "string", "name": "name", "type": "string" },
                      { "indexed": false, "internalType": "string", "name": "symbol", "type": "string" }
                    ],
                    "name": "TokenCreated",
                    "type": "event"
                  },
                  {
                    "inputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ],
                    "name": "allTokens",
                    "outputs": [ { "internalType": "address", "name": "", "type": "address" } ],
                    "stateMutability": "view",
                    "type": "function"
                  },
                  {
                    "inputs": [],
                    "name": "getAllTokens",
                    "outputs": [ { "internalType": "address[]", "name": "", "type": "address[]" } ],
                    "stateMutability": "view",
                    "type": "function"
                  }
                ];

                try {
                    this.log('🚀 Omega Token Creator', 'info');
                    this.log('This will deploy a new ERC20 token on the Omega Network', 'info');
                    this.log('', 'info');

                    // Get token name
                    this.log('Enter token name (e.g., "My Awesome Token"):', 'info');
                    let name = await this.promptTerminalInput('Enter token name (e.g., "My Awesome Token"):');
                    name = name ? name.trim() : '';
                    if (!name) {
                        this.log('Token creation cancelled.', 'warning');
                        return;
                    }
                    document.getElementById('commandInput').value = '';

                    // Get token symbol
                    this.log('Enter token symbol (e.g., "MAT"):', 'info');
                    let symbol = await this.promptTerminalInput('Enter token symbol (e.g., "MAT"):');
                    symbol = symbol ? symbol.trim() : '';
                    if (!symbol) {
                        this.log('Token creation cancelled.', 'warning');
                        return;
                    }
                    document.getElementById('commandInput').value = '';

                    // Get decimals
                    this.log('Enter decimals (default 18):', 'info');
                    let decimalsInput = await this.promptTerminalInput('Enter decimals (default 18):');
                    decimalsInput = decimalsInput ? decimalsInput.trim() : '';
                    let decimals = 18;
                    if (decimalsInput) {
                        const parsed = parseInt(decimalsInput);
                        if (!isNaN(parsed) && parsed >= 0 && parsed <= 36) decimals = parsed;
                    }
                    document.getElementById('commandInput').value = '';

                    // Get initial supply
                    this.log('Enter initial supply (e.g., 1000000):', 'info');
                    let supplyInput = await this.promptTerminalInput('Enter initial supply (e.g., 1000000):');
                    supplyInput = supplyInput ? supplyInput.trim() : '';
                    if (!supplyInput) {
                        this.log('Token creation cancelled.', 'warning');
                        return;
                    }
                    document.getElementById('commandInput').value = '';
                    const initialSupply = this.ethers.BigNumber.from(supplyInput);
                    if (initialSupply.lte(0)) {
                        this.log('Invalid supply amount. Please enter a positive number.', 'error');
                        return;
                    }

                    // Get mintable
                    this.log('Mintable? (yes/no, default yes):', 'info');
                    let mintableInput = await this.promptTerminalInput('Mintable? (yes/no, default yes):');
                    mintableInput = mintableInput ? mintableInput.trim().toLowerCase() : '';
                    let mintable = true;
                    if (mintableInput === 'no' || mintableInput === 'false') mintable = false;
                    document.getElementById('commandInput').value = '';

                    // Get pausable
                    this.log('Pausable? (yes/no, default yes):', 'info');
                    let pausableInput = await this.promptTerminalInput('Pausable? (yes/no, default yes):');
                    pausableInput = pausableInput ? pausableInput.trim().toLowerCase() : '';
                    let pausable = true;
                    if (pausableInput === 'no' || pausableInput === 'false') pausable = false;
                    document.getElementById('commandInput').value = '';

                    this.log('', 'info');
                    this.log('📋 Token Details:', 'info');
                    this.log(`Name: ${name}`, 'output');
                    this.log(`Symbol: ${symbol}`, 'output');
                    this.log(`Decimals: ${decimals}`, 'output');
                    this.log(`Initial Supply: ${initialSupply.toLocaleString()}`, 'output');
                    this.log(`Mintable: ${mintable ? 'Yes' : 'No'}`, 'output');
                    this.log(`Pausable: ${pausable ? 'Yes' : 'No'}`, 'output');
                    this.log('', 'info');

                    this.log('Deploy token? (yes/no):', 'info');
                    let confirm = await this.promptTerminalInput('Deploy token? (yes/no):');
                    confirm = confirm ? confirm.trim().toLowerCase() : '';
                    if (confirm !== 'yes') {
                        this.log('Token creation cancelled.', 'warning');
                        return;
                    }
                    document.getElementById('commandInput').value = '';

                    this.log('⏳ Deploying token...', 'info');

                    // Create contract instance
                    const factory = new this.ethers.Contract(FACTORY_ADDRESS, FACTORY_ABI, this.signer);

                    try {
                        // Deploy token
                        const tx = await factory.createToken(name, symbol, decimals, initialSupply, mintable, pausable);
                        this.log(`Transaction sent: ${tx.hash}`, 'info');

                        // Wait for confirmation
                        const receipt = await tx.wait();
                        this.log('✅ Token deployed successfully!', 'success');
                        this.log('', 'info');

                        // Extract token address from events
                        let tokenAddress = null;
                        for (const log of receipt.logs) {
                            try {
                                const parsedLog = factory.interface.parseLog(log);
                                if (parsedLog.name === 'TokenCreated') {
                                    tokenAddress = parsedLog.args.token;
                                    break;
                                }
                            } catch (e) {
                                // Continue searching
                            }
                        }

                        if (tokenAddress) {
                            this.logHtml('<span class="success">🎉 <b>Token Deployed!</b></span>', 'success');
                            this.logHtml(`Token Address: <span class="copyable" onclick="navigator.clipboard.writeText('${tokenAddress}')" style="color:#33bbff;cursor:pointer;">${tokenAddress}</span>`, 'output');
                            this.logHtml(`Transaction Hash: <span class="copyable" onclick="navigator.clipboard.writeText('${tx.hash}')" style="color:#33bbff;cursor:pointer;">${tx.hash}</span>`, 'output');
                            this.logHtml(`<b>Name:</b> ${name}<br><b>Symbol:</b> ${symbol}<br><b>Decimals:</b> ${decimals}<br><b>Initial Supply:</b> ${initialSupply.toString()}<br><b>Mintable:</b> ${mintable ? 'Yes' : 'No'}<br><b>Pausable:</b> ${pausable ? 'Yes' : 'No'}`, 'output');
                            this.logHtml('<span style="color:#99ccff">💡 You can now add liquidity or trade your token!</span>', 'info');
                        } else {
                            this.logHtml('<span class="warning">⚠️ Token deployed but address not found in events</span>', 'warning');
                            this.logHtml(`Transaction Hash: <span class="copyable" onclick="navigator.clipboard.writeText('${tx.hash}')" style="color:#33bbff;cursor:pointer;">${tx.hash}</span>`, 'output');
                        }

                    } catch (error) {
                        this.log(`❌ Token creation failed: ${error.message}`, 'error');
                        if (error.code === 'ACTION_REJECTED') {
                            this.log('Transaction was rejected by user.', 'warning');
                        } else if (error.code === 'INSUFFICIENT_FUNDS') {
                            this.log('Insufficient funds for gas fees.', 'error');
                        } else if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
                            this.log('Tip: Check that the contract address, ABI, and network are correct. Make sure MetaMask is on the right network and the contract is deployed.', 'warning');
                        }
                    }
                } catch (error) {
                    this.log(`❌ Token creation failed: ${error.message}`, 'error');
                    if (error.code === 'ACTION_REJECTED') {
                        this.log('Transaction was rejected by user.', 'warning');
                    } else if (error.code === 'INSUFFICIENT_FUNDS') {
                        this.log('Insufficient funds for gas fees.', 'error');
                    }
                }
            }

            // 🏆 AMBASSADOR COMMAND HANDLER
            async handleAmbassadorCommand(args) {
                if (!args || args.length < 2) {
                    this.log('🏆 OMEGA NETWORK AMBASSADOR COMMANDS', 'info');
                    this.log('═══════════════════════════════════════', 'info');
                    this.log('', 'info');
                    this.log('📋 BASIC COMMANDS:', 'info');
                    this.log('  ambassador profile [address]     View ambassador profile', 'output');
                    this.log('  ambassador stats [address]       View ambassador statistics', 'output');
                    this.log('  ambassador leaderboard [limit]   View top ambassadors', 'output');
                    this.log('  ambassador directory             View all public ambassadors', 'output');
                    this.log('  ambassador referrals [address]   View ambassador referrals', 'output');
                    this.log('  ambassador generate              Generate referral code', 'output');
                    this.log('', 'info');
                    this.log('🎯 EXAMPLES:', 'info');
                    this.log('  ambassador profile 0x1234...     # Specific ambassador', 'info');
                    this.log('  ambassador stats                 # Your stats (if connected)', 'info');
                    this.log('  ambassador leaderboard 20        # Top 20 ambassadors', 'info');
                    this.log('  ambassador generate              # Create referral code', 'info');
                    this.log('', 'info');
                    this.log('💡 Tip: Connect your wallet first for personalized commands!', 'success');
                    return;
                }

                const subCommand = args[1].toLowerCase();
                
                try {
                    switch (subCommand) {
                        case 'profile':
                            await this.getAmbassadorProfile(args[2]);
                            break;
                        case 'stats':
                            await this.getAmbassadorStats(args[2]);
                            break;
                        case 'leaderboard':
                            await this.getAmbassadorLeaderboard(args[2]);
                            break;
                        case 'directory':
                            await this.getAmbassadorDirectory();
                            break;
                        case 'referrals':
                            await this.getAmbassadorReferrals(args[2]);
                            break;
                        case 'generate':
                            await this.generateAmbassadorCode();
                            break;
                        case 'help':
                            await this.handleAmbassadorCommand([]);
                            break;
                        default:
                            this.log(`❌ Unknown ambassador command: ${subCommand}`, 'error');
                            this.log('Type "ambassador help" for available commands', 'info');
                    }
                } catch (error) {
                    console.error('Ambassador command error:', error);
                    this.log(`❌ Ambassador command failed: ${error.message}`, 'error');
                }
            }

            // 👤 PROFILE COMMAND HANDLER
            async handleProfileCommand(args) {
                if (!args || args.length < 2) {
                    this.log('👤 OMEGA NETWORK USER PROFILE COMMANDS', 'info');
                    this.log('══════════════════════════════════════════', 'info');
                    this.log('', 'info');
                    this.log('📋 BASIC COMMANDS:', 'info');
                    this.log('  profile                          View your profile', 'output');
                    this.log('  profile view [address]           View specific user profile', 'output');
                    this.log('  profile register                 Register/setup your profile', 'output');
                    this.log('  profile update                   Update your existing profile', 'output');
                    this.log('  profile activity                 View your activity history', 'output');
                    this.log('  profile debug [address]          Debug profile data (local vs production)', 'output');
                    this.log('  profile test                     Test profile endpoints', 'output');
                    this.log('', 'info');
                    this.log('🎯 EXAMPLES:', 'info');
                    this.log('  profile                          # Your profile (if connected)', 'info');
                    this.log('  profile view 0x1234...           # View someone else\'s profile', 'info');
                    this.log('  profile register                 # Start guided profile setup', 'info');
                    this.log('  profile update                   # Update your existing profile', 'info');
                    this.log('', 'info');
                    this.log('💡 Tip: Connect your wallet first for personalized commands!', 'success');
                    return;
                }

                const subCommand = args[1].toLowerCase();
                
                try {
                    switch (subCommand) {
                        case 'view':
                            await this.getUserProfile(args[2]);
                            break;
                        case 'register':
                            await this.registerUserProfile();
                            break;
                        case 'update':
                            await this.updateUserProfile();
                            break;
                        case 'activity':
                            await this.getUserActivity(args[2]);
                            break;
                        case 'debug':
                            await this.debugUserProfile(args[2]);
                            break;
                        case 'test':
                            await this.testProfileEndpoints();
                            break;
                        case 'help':
                            await this.handleProfileCommand([]);
                            break;
                        default:
                            // If no subcommand, show user's own profile
                            if (args.length === 1) {
                                await this.getUserProfile();
                            } else {
                                this.log(`❌ Unknown profile command: ${subCommand}`, 'error');
                                this.log('Type "profile help" for available commands', 'info');
                            }
                    }
                } catch (error) {
                    console.error('Profile command error:', error);
                    this.log(`❌ Profile command failed: ${error.message}`, 'error');
                }
            }

            async getAmbassadorProfile(address) {
                let walletAddress = address;
                
                if (!walletAddress) {
                    if (this.signer) {
                        try {
                            walletAddress = await this.signer.getAddress();
                        } catch (error) {
                            this.log('❌ Please provide a wallet address or connect your wallet', 'error');
                            this.log('Usage: ambassador profile 0x1234...', 'info');
                            return;
                        }
                    } else {
                        this.log('❌ Please provide a wallet address or connect your wallet', 'error');
                        this.log('Usage: ambassador profile 0x1234...', 'info');
                        return;
                    }
                }
                
                this.log(`👤 Loading ambassador profile for: ${walletAddress}`, 'info');
                
                try {
                    const response = await fetch(`${OMEGA_API_URL}/v1/ambassadors/${encodeURIComponent(walletAddress)}/profile`);
                    const data = await response.json();
                    
                    if (!data.success) {
                        this.log(`❌ ${data.error}`, 'error');
                        return;
                    }
                    
                    const profile = data.data;
                    
                    this.log('✅ AMBASSADOR PROFILE', 'success');
                    this.log('═══════════════════════', 'success');
                    this.log(`👤 Username: ${profile.username || 'Not set'}`, 'info');
                    this.log(`🏷️  Display Name: ${profile.display_name || 'Not set'}`, 'info');
                    this.log(`📍 Location: ${profile.location || 'Not set'}`, 'info');
                    this.log(`🐦 Twitter: ${profile.twitter || 'Not set'}`, 'info');
                    this.log(`💬 Discord: ${profile.discord || 'Not set'}`, 'info');
                    this.log(`🌐 Website: ${profile.website || 'Not set'}`, 'info');
                    this.log(`📊 Level: ${profile.level || 1}`, 'info');
                    this.log(`🏆 Points: ${profile.total_points || 0}`, 'info');
                    this.log(`🎯 Referrals: ${profile.referrals_count || 0}`, 'info');
                    this.log(`🏅 Tier: ${profile.rank || 'BRONZE'}`, 'info');
                    
                } catch (error) {
                    this.log(`❌ Failed to load ambassador profile: ${error.message}`, 'error');
                }
            }

            async getAmbassadorStats(address) {
                let walletAddress = address;
                
                if (!walletAddress) {
                    if (this.signer) {
                        try {
                            walletAddress = await this.signer.getAddress();
                        } catch (error) {
                            this.log('❌ Please provide a wallet address or connect your wallet', 'error');
                            return;
                        }
                    } else {
                        this.log('❌ Please provide a wallet address or connect your wallet', 'error');
                        return;
                    }
                }
                
                this.log(`📊 Loading ambassador stats for: ${walletAddress}`, 'info');
                
                try {
                    const response = await fetch(`${OMEGA_API_URL}/v1/users/${walletAddress}/profile`);
                    const data = await response.json();
                    
                    if (!data.success) {
                        this.log(`❌ ${data.error}`, 'error');
                        return;
                    }
                    
                    const profile = data.data.profile;
                    const interactions = data.data.discoverInteractions || [];
                    
                    this.log('✅ AMBASSADOR STATISTICS', 'success');
                    this.log('═══════════════════════════', 'success');
                    this.log(`👤 Username: ${profile.username || 'Not set'}`, 'info');
                    this.log(`🏷️  Display Name: ${profile.displayName || 'Not set'}`, 'info');
                    this.log(`🐦 Twitter: ${profile.twitter || 'Not set'}`, 'info');
                    this.log(`💬 Discord: ${profile.discord || 'Not set'}`, 'info');
                    this.log(`📊 Recent Activities: ${interactions.length}`, 'info');
                    this.log(`🔗 Profile Public: ${profile.isPublic ? 'Yes' : 'No'}`, 'info');
                    
                    // Try to get referral data separately
                    try {
                        const refResponse = await fetch(`${OMEGA_API_URL}/v1/referrals/validate/${profile.username || 'unknown'}`);
                        const refData = await refResponse.json();
                        if (refData.success && refData.data.isValid) {
                            this.log(`🎯 Referral Status: Active Ambassador`, 'success');
                        }
                    } catch (refError) {
                        this.log(`🎯 Referral Status: Unknown`, 'warning');
                    }
                    
                } catch (error) {
                    this.log(`❌ Failed to load ambassador stats: ${error.message}`, 'error');
                }
            }

            async getAmbassadorLeaderboard(limit) {
                const queryLimit = limit || 10;
                
                this.log(`🏆 Loading top ${queryLimit} ambassadors...`, 'info');
                
                try {
                    const response = await fetch(`${OMEGA_API_URL}/v1/ambassadors/leaderboard?limit=${queryLimit}`);
                    const data = await response.json();
                    
                    if (!data.success) {
                        this.log(`❌ ${data.error}`, 'error');
                        return;
                    }
                    
                    this.log('🏆 AMBASSADOR LEADERBOARD', 'success');
                    this.log('═══════════════════════════════', 'success');
                    this.log('', 'info');
                    
                    data.data.forEach((ambassador, index) => {
                        const emoji = ambassador.rank === 1 ? '🥇' : 
                                     ambassador.rank === 2 ? '🥈' : 
                                     ambassador.rank === 3 ? '🥉' : '🏅';
                        
                        this.log(`${emoji} #${ambassador.rank} ${ambassador.displayName}`, 'info');
                        this.log(`   👤 @${ambassador.username} | 🎯 ${ambassador.totalReferrals} referrals | 🏆 ${ambassador.totalPoints} points`, 'info');
                        this.log(`   🏅 ${ambassador.tier} | 📈 Level ${ambassador.level}`, 'info');
                        this.log('', 'info');
                    });
                    
                    if (data.pagination) {
                        this.log(`📊 Showing ${data.data.length} of ${data.pagination.total} ambassadors`, 'info');
                    }
                    
                } catch (error) {
                    this.log(`❌ Failed to load ambassador leaderboard: ${error.message}`, 'error');
                }
            }

            async getAmbassadorDirectory() {
                this.log('🌐 Loading ambassador directory...', 'info');
                
                try {
                    const response = await fetch(`${OMEGA_API_URL}/v1/ambassadors/directory`);
                    const data = await response.json();
                    
                    if (!data.success) {
                        this.log(`❌ ${data.error}`, 'error');
                        return;
                    }
                    
                    this.log('🌐 AMBASSADOR DIRECTORY', 'success');
                    this.log('═══════════════════════════', 'success');
                    this.log('', 'info');
                    
                    data.data.forEach((ambassador, index) => {
                        this.log(`👤 ${ambassador.display_name || ambassador.username}`, 'success');
                        if (ambassador.bio) {
                            this.log(`   📝 ${ambassador.bio}`, 'info');
                        }
                        this.log(`   🎯 ${ambassador.referral_count || 0} referrals | 🏆 ${ambassador.total_points || 0} points`, 'info');
                        if (ambassador.website) {
                            this.logHtml(`   🌐 <a href="${ambassador.website}" target="_blank" style="color:#33bbff;">${ambassador.website}</a>`, 'info');
                        }
                        this.log('', 'info');
                    });
                    
                } catch (error) {
                    this.log(`❌ Failed to load ambassador directory: ${error.message}`, 'error');
                }
            }

            async getAmbassadorReferrals(address) {
                let walletAddress = address;
                
                if (!walletAddress) {
                    if (this.signer) {
                        try {
                            walletAddress = await this.signer.getAddress();
                        } catch (error) {
                            this.log('❌ Please provide a wallet address or connect your wallet', 'error');
                            return;
                        }
                    } else {
                        this.log('❌ Please provide a wallet address or connect your wallet', 'error');
                        return;
                    }
                }
                
                this.log(`🔗 Loading referrals for: ${walletAddress}`, 'info');
                
                try {
                    const response = await fetch(`${OMEGA_API_URL}/v1/ambassadors/${walletAddress}/referrals`);
                    const data = await response.json();
                    
                    if (!data.success) {
                        this.log(`❌ ${data.error}`, 'error');
                        return;
                    }
                    
                    this.log('🔗 AMBASSADOR REFERRALS', 'success');
                    this.log('═══════════════════════════', 'success');
                    this.log('', 'info');
                    
                    if (data.data.length === 0) {
                        this.log('📭 No referrals yet. Start sharing your ambassador link!', 'info');
                        return;
                    }
                    
                    data.data.forEach((referral, index) => {
                        const status = referral.status === 'COMPLETED' ? '✅' : '⏳';
                        const date = new Date(referral.created_at).toLocaleDateString();
                        
                        this.log(`${status} ${referral.referral_code}`, 'info');
                        
                        if (referral.referred_address) {
                            this.log(`   👤 Referred: ${referral.referred_address.substring(0, 10)}...`, 'info');
                            this.log(`   ✅ Completed: ${new Date(referral.completed_at).toLocaleDateString()}`, 'success');
                        } else {
                            this.log('   ⏳ Pending - waiting for signup', 'warning');
                        }
                        
                        this.log(`   📅 Created: ${date}`, 'info');
                        this.log('', 'info');
                    });
                    
                } catch (error) {
                    this.log(`❌ Failed to load ambassador referrals: ${error.message}`, 'error');
                }
            }

            async generateAmbassadorCode() {
                if (!this.signer) {
                    this.log('❌ Please connect your wallet first using "connect"', 'error');
                    return;
                }
                
                let walletAddress;
                try {
                    walletAddress = await this.signer.getAddress();
                } catch (error) {
                    this.log('❌ Please connect your wallet first using "connect"', 'error');
                    return;
                }
                
                this.log('🎯 Generating ambassador referral code...', 'info');
                
                try {
                    // First get user's profile to retrieve username
                    this.log('📝 Checking your profile for username...', 'info');
                    let username = null;
                    
                    try {
                        const profileResponse = await fetch(`${RELAYER_URL}/v1/users/${walletAddress}/profile`);
                        const profileData = await profileResponse.json();
                        
                        if (profileData.success && profileData.data.profile.username) {
                            username = profileData.data.profile.username;
                            this.log(`✅ Found username: ${username}`, 'success');
                        } else {
                            this.log('⚠️ No username found in profile. Please set up your profile first using "profile register"', 'error');
                            this.log('   This is required for proper referral credit tracking.', 'error');
                            return;
                        }
                    } catch (profileError) {
                        this.log('⚠️ Could not retrieve your profile. Please set up your profile first using "profile register"', 'error');
                        this.log('   This is required for proper referral credit tracking.', 'error');
                        return;
                    }
                    
                    // Generate the referral code
                    const response = await fetch(`${OMEGA_API_URL}/v1/referrals/generate-code`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ walletAddress: walletAddress })
                    });
                    
                    const data = await response.json();
                    
                    if (!data.success) {
                        this.log(`❌ ${data.error}`, 'error');
                        return;
                    }
                    
                    const result = data.data;
                    
                    if (result.alreadyExists) {
                        this.log('ℹ️ You already have an ambassador code!', 'info');
                    } else {
                        this.log('✅ Ambassador code generated successfully!', 'success');
                    }
                    
                    this.log('🎯 YOUR AMBASSADOR CODE', 'success');
                    this.log('═══════════════════════════', 'success');
                    this.log(`🔑 Code: ${result.referralCode}`, 'success');
                    this.log(`👤 Username: ${username}`, 'success');
                    this.logHtml(`🔗 Link: <span class="copyable" onclick="navigator.clipboard.writeText('https://omeganetwork.co/${username}/${result.referralCode}').then(() => window.terminal.log('✅ Ambassador link copied to clipboard!', 'success'))" style="color:#33bbff; cursor:pointer; text-decoration:underline;">https://omeganetwork.co/${username}/${result.referralCode}</span>`, 'info');
                    this.log('', 'info');
                    this.log('💡 Use: ambassador stats (to track your progress)', 'info');
                    
                } catch (error) {
                    this.log(`❌ Failed to generate ambassador code: ${error.message}`, 'error');
                }
            }

            // 👤 PROFILE MANAGEMENT FUNCTIONS
            async getUserProfile(address) {
                let walletAddress = address;
                
                if (!walletAddress) {
                    if (this.signer) {
                        try {
                            walletAddress = await this.signer.getAddress();
                        } catch (error) {
                            this.log('❌ Please connect your wallet first using "connect"', 'error');
                            return;
                        }
                    } else {
                        this.log('❌ Please connect your wallet first using "connect"', 'error');
                        return;
                    }
                }
                
                this.log(`👤 Loading profile for: ${walletAddress}`, 'info');
                
                try {
                    const response = await fetch(`${RELAYER_URL}/v1/users/${walletAddress}/profile`);
                    const data = await response.json();
                    
                    if (!data.success) {
                        this.log(`❌ Profile not found. Use "profile register" to create one.`, 'error');
                        return;
                    }
                    
                    const profile = data.data.profile;
                    
                    this.log('👤 USER PROFILE', 'success');
                    this.log('═══════════════', 'success');
                    this.log(`🏷️  Username: ${profile.username || 'Not set'}`, 'info');
                    this.log(`📝 Display Name: ${profile.displayName || 'Not set'}`, 'info'); 
                    this.log(`📍 Location: ${profile.location || 'Not set'}`, 'info');
                    this.log(`💬 Bio: ${profile.bio || 'Not set'}`, 'info');
                    this.log(`🌐 Website: ${profile.website || 'Not set'}`, 'info');
                    this.log(`🐦 Twitter: ${profile.twitter || 'Not set'}`, 'info');
                    this.log(`💬 Discord: ${profile.discord || 'Not set'}`, 'info');
                    this.log(`🐙 GitHub: ${profile.github || 'Not set'}`, 'info');
                    this.log(`📱 Telegram: ${profile.telegram || 'Not set'}`, 'info');
                    this.log(`📧 Email: ${profile.email || 'Not set'}`, 'info');
                    this.log(`🔓 Public: ${profile.isPublic ? 'Yes' : 'No'}`, 'info');
                    this.log('', 'info');
                    this.log('💡 Use: profile update (to modify your profile)', 'success');
                    
                } catch (error) {
                    this.log(`❌ Failed to load profile: ${error.message}`, 'error');
                }
            }

            async registerUserProfile() {
                if (!this.signer) {
                    this.log('❌ Please connect your wallet first using "connect"', 'error');
                    return;
                }
                
                let walletAddress;
                try {
                    walletAddress = await this.signer.getAddress();
                } catch (error) {
                    this.log('❌ Please connect your wallet first using "connect"', 'error');
                    return;
                }
                
                this.log('👤 PROFILE REGISTRATION', 'success');
                this.log('══════════════════════', 'success');
                this.log('', 'info');
                this.log('📝 Let\'s set up your Omega Network profile!', 'info');
                this.log('💡 You can skip any field by pressing Enter', 'info');
                this.log('', 'info');
                
                // Start guided registration
                this.profileRegistrationStep = 1;
                this.profileData = { walletAddress };
                this.awaitingInput = true;
                this.inputType = 'profile_username';
                
                this.log('🏷️  Enter your username:', 'info');
                this.log('    (3-20 characters, letters/numbers only)', 'output');
            }

            async updateUserProfile() {
                if (!this.signer) {
                    this.log('❌ Please connect your wallet first using "connect"', 'error');
                    return;
                }
                
                let walletAddress;
                try {
                    walletAddress = await this.signer.getAddress();
                } catch (error) {
                    this.log('❌ Please connect your wallet first using "connect"', 'error');
                    return;
                }
                
                // First check if profile exists
                try {
                    const response = await fetch(`${RELAYER_URL}/v1/users/${walletAddress}/profile`);
                    const data = await response.json();
                    
                    if (!data.success) {
                        this.log('❌ No profile found. Use "profile register" to create one first.', 'error');
                        return;
                    }
                    
                    this.log('👤 PROFILE UPDATE', 'success');
                    this.log('═══════════════', 'success');
                    this.log('', 'info');
                    this.log('📝 Let\'s update your profile! Current values:', 'info');
                    
                    const profile = data.data.profile;
                    this.log(`🏷️  Username: ${profile.username || 'Not set'}`, 'output');
                    this.log(`📝 Display Name: ${profile.displayName || 'Not set'}`, 'output');
                    this.log(`📍 Location: ${profile.location || 'Not set'}`, 'output');
                    this.log('', 'info');
                    this.log('💡 Enter new values (or press Enter to keep current)', 'info');
                    this.log('', 'info');
                    
                    // Start guided update
                    this.profileRegistrationStep = 1;
                    this.profileData = { walletAddress, ...profile };
                    this.awaitingInput = true;
                    this.inputType = 'profile_username';
                    
                    this.log('🏷️  Enter new username:', 'info');
                    this.log(`    Current: ${profile.username || 'Not set'}`, 'output');
                    
                } catch (error) {
                    this.log(`❌ Failed to load current profile: ${error.message}`, 'error');
                }
            }

            async getUserActivity(address) {
                let walletAddress = address;
                
                if (!walletAddress) {
                    if (this.signer) {
                        try {
                            walletAddress = await this.signer.getAddress();
                        } catch (error) {
                            this.log('❌ Please connect your wallet first using "connect"', 'error');
                            return;
                        }
                    } else {
                        this.log('❌ Please connect your wallet first using "connect"', 'error');
                        return;
                    }
                }
                
                this.log(`📊 Loading activity for: ${walletAddress}`, 'info');
                
                try {
                    const response = await fetch(`${RELAYER_URL}/v1/users/${walletAddress}/activity?limit=10`);
                    const data = await response.json();
                    
                    if (!data.success) {
                        this.log(`❌ No activity found for this address`, 'error');
                        return;
                    }
                    
                    this.log('📊 USER ACTIVITY (Last 10)', 'success');
                    this.log('═══════════════════════════', 'success');
                    
                    const activities = data.data;
                    if (activities.length === 0) {
                        this.log('📭 No recent activity found', 'info');
                        return;
                    }
                    
                    activities.forEach((activity, index) => {
                        const date = new Date(activity.createdAt).toLocaleDateString();
                        this.log(`${index + 1}. ${activity.action} - ${date}`, 'output');
                    });
                    
                } catch (error) {
                    this.log(`❌ Failed to load activity: ${error.message}`, 'error');
                }
            }

            // Profile registration input handler
            async handleProfileRegistrationInput(input) {
                switch (this.inputType) {
                    case 'profile_username':
                        if (input && input.length >= 3 && input.length <= 20 && /^[a-zA-Z0-9_]+$/.test(input)) {
                            this.profileData.username = input;
                            this.log(`✅ Username: ${input}`, 'success');
                        } else if (input) {
                            this.log('❌ Username must be 3-20 characters, letters/numbers/underscore only', 'error');
                            this.log('🏷️  Enter your username:', 'info');
                            return;
                        }
                        
                        this.profileRegistrationStep = 2;
                        this.inputType = 'profile_display_name';
                        this.log('', 'info');
                        this.log('📝 Enter your display name:', 'info');
                        this.log('    (The name others will see)', 'output');
                        break;
                        
                    case 'profile_display_name':
                        if (input && input.length <= 50) {
                            this.profileData.displayName = input;
                            this.log(`✅ Display Name: ${input}`, 'success');
                        }
                        
                        this.profileRegistrationStep = 3;
                        this.inputType = 'profile_bio';
                        this.log('', 'info');
                        this.log('💬 Enter your bio:', 'info');
                        this.log('    (Optional - tell others about yourself)', 'output');
                        break;
                        
                    case 'profile_bio':
                        if (input && input.length <= 200) {
                            this.profileData.bio = input;
                            this.log(`✅ Bio: ${input}`, 'success');
                        }
                        
                        this.profileRegistrationStep = 4;
                        this.inputType = 'profile_location';
                        this.log('', 'info');
                        this.log('📍 Enter your location:', 'info');
                        this.log('    (Optional - country, city, etc.)', 'output');
                        break;
                        
                    case 'profile_location':
                        if (input && input.length <= 100) {
                            this.profileData.location = input;
                            this.log(`✅ Location: ${input}`, 'success');
                        }
                        
                        this.profileRegistrationStep = 5;
                        this.inputType = 'profile_twitter';
                        this.log('', 'info');
                        this.log('🐦 Enter your Twitter handle:', 'info');
                        this.log('    (Optional - without @)', 'output');
                        break;
                        
                    case 'profile_twitter':
                        if (input && input.length <= 50) {
                            this.profileData.twitter = input;
                            this.log(`✅ Twitter: @${input}`, 'success');
                        }
                        
                        this.profileRegistrationStep = 6;
                        this.inputType = 'profile_discord';
                        this.log('', 'info');
                        this.log('💬 Enter your Discord ID:', 'info');
                        this.log('    (Optional - your Discord username or ID)', 'output');
                        break;
                        
                    case 'profile_discord':
                        if (input && input.length <= 50) {
                            this.profileData.discord = input;
                            this.log(`✅ Discord: ${input}`, 'success');
                        }
                        
                        this.profileRegistrationStep = 7;
                        this.inputType = 'profile_email';
                        this.log('', 'info');
                        this.log('📧 Enter your email address:', 'info');
                        this.log('    (Optional - for notifications and updates)', 'output');
                        break;
                        
                    case 'profile_email':
                        if (input && input.includes('@') && input.includes('.') && input.length <= 100) {
                            this.profileData.email = input;
                            this.log(`✅ Email: ${input}`, 'success');
                        } else if (input && input.length > 0) {
                            this.log('❌ Please enter a valid email address', 'error');
                            this.log('📧 Enter your email address:', 'info');
                            return;
                        }
                        
                        this.profileRegistrationStep = 8;
                        this.inputType = 'profile_confirmation';
                        this.log('', 'info');
                        this.log('✨ PROFILE SUMMARY', 'success');
                        this.log('═══════════════════', 'success');
                        this.log(`🏷️  Username: ${this.profileData.username || 'Not set'}`, 'info');
                        this.log(`📝 Display Name: ${this.profileData.displayName || 'Not set'}`, 'info');
                        this.log(`💬 Bio: ${this.profileData.bio || 'Not set'}`, 'info');
                        this.log(`📍 Location: ${this.profileData.location || 'Not set'}`, 'info');
                        this.log(`🐦 Twitter: ${this.profileData.twitter || 'Not set'}`, 'info');
                        this.log(`💬 Discord: ${this.profileData.discord || 'Not set'}`, 'info');
                        this.log(`📧 Email: ${this.profileData.email || 'Not set'}`, 'info');
                        this.log('', 'info');
                        this.log('✅ Confirm registration? (yes/no):', 'info');
                        break;
                        
                    case 'profile_confirmation':
                        const confirm = input.toLowerCase();
                        this.awaitingInput = false;
                        this.inputType = null;
                        
                        if (confirm === 'yes' || confirm === 'y') {
                            await this.submitUserProfile();
                        } else {
                            this.log('❌ Profile registration cancelled', 'error');
                            this.log('💡 Use "profile register" to try again', 'info');
                        }
                        break;
                }
            }

            async submitUserProfile() {
                this.log('📤 Submitting your profile...', 'info');
                
                try {
                    const response = await fetch(`${RELAYER_URL}/v1/users/${this.profileData.walletAddress}/profile`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            username: this.profileData.username,
                            displayName: this.profileData.displayName,
                            bio: this.profileData.bio,
                            location: this.profileData.location,
                            twitter: this.profileData.twitter,
                            discord: this.profileData.discord,
                            email: this.profileData.email
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (!data.success) {
                        this.log(`❌ Registration failed: ${data.error}`, 'error');
                        return;
                    }
                    
                    this.log('🎉 PROFILE REGISTERED SUCCESSFULLY!', 'success');
                    this.log('═══════════════════════════════════', 'success');
                    this.log(`✅ Welcome to Omega Network, ${this.profileData.displayName || this.profileData.username}!`, 'success');
                    this.log('', 'info');
                    this.log('🎯 What\'s next:', 'info');
                    this.log('  • Use "profile" to view your profile', 'output');
                    this.log('  • Use "ambassador generate" to become an ambassador', 'output');
                    this.log('  • Use "profile activity" to track your progress', 'output');
                    this.log('', 'info');
                    
                    // Clear registration data
                    this.profileData = null;
                    this.profileRegistrationStep = 0;
                    
                } catch (error) {
                    this.log(`❌ Registration failed: ${error.message}`, 'error');
                }
            }

            // 🐛 PROFILE DEBUG FUNCTIONS
            async debugUserProfile(address) {
                let walletAddress = address;
                
                if (!walletAddress) {
                    if (this.signer) {
                        try {
                            walletAddress = await this.signer.getAddress();
                        } catch (error) {
                            this.log('❌ Please connect your wallet first using "connect"', 'error');
                            return;
                        }
                    } else {
                        this.log('❌ Please provide a wallet address or connect your wallet', 'error');
                        return;
                    }
                }
                
                this.log('🐛 PROFILE DEBUG MODE', 'success');
                this.log('═══════════════════════', 'success');
                this.log(`🔍 Testing profile for: ${walletAddress}`, 'info');
                this.log('', 'info');
                
                // Test LOCAL relayer endpoint
                this.log('1. 🏠 LOCAL RELAYER TEST (localhost:4000)', 'info');
                this.log('   ─────────────────────────────────────────', 'info');
                try {
                    const localResponse = await fetch(`${RELAYER_URL}/v1/users/${walletAddress}/profile`);
                    this.log(`   📡 Status: ${localResponse.status}`, localResponse.ok ? 'success' : 'error');
                    
                    const localData = await localResponse.json();
                    this.log(`   📝 Success: ${localData.success}`, localData.success ? 'success' : 'error');
                    
                    if (localData.success && localData.data.profile) {
                        const profile = localData.data.profile;
                        this.log(`   👤 Username: ${profile.username || 'NOT FOUND'}`, profile.username ? 'success' : 'error');
                        this.log(`   📝 Display Name: ${profile.displayName || 'NOT FOUND'}`, 'info');
                        this.log(`   📧 Email: ${profile.email || 'NOT FOUND'}`, 'info');
                        this.log(`   🔓 Public: ${profile.isPublic}`, 'info');
                    } else {
                        this.log(`   ❌ Error: ${localData.error || 'No profile data'}`, 'error');
                    }
                } catch (error) {
                    this.log(`   💥 Failed: ${error.message}`, 'error');
                }
                
                this.log('', 'info');
                
                // Test PRODUCTION API endpoint
                this.log('2. 🌐 PRODUCTION API TEST (omeganetwork.co)', 'info');
                this.log('   ─────────────────────────────────────────', 'info');
                try {
                    const prodResponse = await fetch(`${OMEGA_API_URL}/v1/users/${walletAddress}/profile`);
                    this.log(`   📡 Status: ${prodResponse.status}`, prodResponse.ok ? 'success' : 'error');
                    
                    const prodData = await prodResponse.json();
                    this.log(`   📝 Success: ${prodData.success}`, prodData.success ? 'success' : 'error');
                    
                    if (prodData.success && prodData.data.profile) {
                        const profile = prodData.data.profile;
                        this.log(`   👤 Username: ${profile.username || 'NOT FOUND'}`, profile.username ? 'success' : 'error');
                        this.log(`   📝 Display Name: ${profile.displayName || 'NOT FOUND'}`, 'info');
                        this.log(`   📧 Email: ${profile.email || 'NOT FOUND'}`, 'info');
                        this.log(`   🔓 Public: ${profile.isPublic}`, 'info');
                    } else {
                        this.log(`   ❌ Error: ${prodData.error || 'No profile data'}`, 'error');
                    }
                } catch (error) {
                    this.log(`   💥 Failed: ${error.message}`, 'error');
                }
                
                this.log('', 'info');
                this.log('🎯 DIAGNOSIS:', 'success');
                this.log('• If LOCAL has username but PRODUCTION doesn\'t: Profile only saved locally', 'info');
                this.log('• If both have same username: Data sync is working', 'info');
                this.log('• If neither has username: Profile registration failed', 'info');
                this.log('• If PRODUCTION shows different data: Database mismatch', 'info');
            }

            async testProfileEndpoints() {
                if (!this.signer) {
                    this.log('❌ Please connect your wallet first using "connect"', 'error');
                    return;
                }
                
                let walletAddress;
                try {
                    walletAddress = await this.signer.getAddress();
                } catch (error) {
                    this.log('❌ Please connect your wallet first using "connect"', 'error');
                    return;
                }
                
                this.log('🧪 PROFILE ENDPOINT TESTS', 'success');
                this.log('═══════════════════════════', 'success');
                
                // Test 1: Check if relayer is running
                this.log('1. 🔗 Testing relayer connection...', 'info');
                try {
                    const healthResponse = await fetch(`${RELAYER_URL}/api/health/liveness`);
                    if (healthResponse.ok) {
                        this.log('   ✅ Relayer is running!', 'success');
                    } else {
                        this.log('   ❌ Relayer returned error status', 'error');
                    }
                } catch (error) {
                    this.log(`   💥 Relayer connection failed: ${error.message}`, 'error');
                    this.log('   💡 Make sure "node relayer-faucet.js" is running on port 4000', 'info');
                }
                
                // Test 2: Test profile GET endpoint
                this.log('', 'info');
                this.log('2. 📖 Testing profile GET endpoint...', 'info');
                try {
                    const response = await fetch(`${RELAYER_URL}/v1/users/${walletAddress}/profile`);
                    this.log(`   📡 Response status: ${response.status}`, response.ok ? 'success' : 'error');
                    
                    const data = await response.json();
                    this.log(`   📝 Response data:`, 'info');
                    this.log(`      ${JSON.stringify(data, null, 2)}`, 'output');
                } catch (error) {
                    this.log(`   💥 GET test failed: ${error.message}`, 'error');
                }
                
                // Test 3: Test profile POST endpoint with dummy data
                this.log('', 'info');
                this.log('3. 📝 Testing profile POST endpoint (dry run)...', 'info');
                try {
                    const testData = {
                        username: 'test_user_debug',
                        displayName: 'Debug Test User',
                        bio: 'This is a test profile for debugging',
                        email: 'debug@test.com'
                    };
                    
                    this.log(`   📤 Test payload: ${JSON.stringify(testData, null, 2)}`, 'output');
                    this.log('   ℹ️ This would POST to:', 'info');
                    this.log(`   ${RELAYER_URL}/v1/users/${walletAddress}/profile`, 'output');
                    this.log('   💡 Use "profile register" to actually save data', 'info');
                } catch (error) {
                    this.log(`   💥 POST test setup failed: ${error.message}`, 'error');
                }
                
                this.log('', 'info');
                this.log('🎯 NEXT STEPS:', 'success');
                this.log('• If connection fails: Start relayer with "node relayer-faucet.js"', 'info');
                this.log('• If GET works: Use "profile debug" to compare local vs production', 'info');
                this.log('• If POST endpoint exists: Try "profile register" again', 'info');
            }

            // 🎨 GUI THEME COMMAND HANDLER
            handleGuiCommand(args) {
                if (!args || args.length < 2) {
                    this.log('🎨 OMEGA TERMINAL GUI THEMES', 'info');
                    this.log('═══════════════════════════════', 'info');
                    this.log('', 'info');
                    this.log('📱 AVAILABLE THEMES:', 'info');
                    this.log('  gui ios          iOS Messages-style interface', 'output');
                this.log('  gui chatgpt      ChatGPT-style conversation interface', 'output');
                    this.log('  gui discord      Discord-style chat interface', 'output');
                    this.log('  gui aol          Retro AOL instant messenger style', 'output');
                    this.log('  gui windows95    Authentic Windows 95 DOS interface', 'output');
                    this.log('  gui limewire     P2P file sharing retro interface', 'output');
                    this.log('  gui off          Return to standard terminal', 'output');
                    this.log('', 'info');
                    this.log('🎯 EXAMPLES:', 'info');
                    this.log('  gui ios          # Switch to iOS Messages theme', 'info');
                this.log('  gui chatgpt      # Switch to ChatGPT theme', 'info');
                    this.log('  gui discord      # Switch to Discord theme', 'info');
                    this.log('  gui off          # Back to normal terminal', 'info');
                    this.log('', 'info');
                    this.log('💡 Each theme completely transforms the interface!', 'success');
                    return;
                }

                const theme = args[1].toLowerCase();
                
                // Remove all existing GUI theme classes
                document.body.classList.remove('gui-chatgpt', 'gui-ios', 'gui-discord', 'gui-aol', 'gui-windows95', 'gui-limewire');
                
                switch (theme) {
                    case 'ios':
                        document.body.classList.add('gui-ios');
                        this.setupiOSInterface();
                        this.log('✅ Switched to iOS Messages theme', 'success');
                        this.log('📱 You now have an iPhone-style messaging interface!', 'info');
                        break;
                    case 'chatgpt':
                        document.body.classList.add('gui-chatgpt');
                        this.setupChatGPTInterface();
                        this.log('✅ Switched to ChatGPT theme', 'success');
                        this.log('💬 You now have a conversational AI interface!', 'info');
                        break;
                    case 'discord':
                        document.body.classList.add('gui-discord');
                        this.setupDiscordInterface();
                        this.log('✅ Switched to Discord theme', 'success');
                        this.log('🎮 You now have a Discord-style chat interface!', 'info');
                        break;
                    case 'aol':
                        document.body.classList.add('gui-aol');
                        this.setupAOLInterface();
                        this.log('✅ Switched to AOL theme', 'success');
                        this.log('📞 Welcome to the 90s instant messenger experience!', 'info');
                        break;
                    case 'windows95':
                        document.body.classList.add('gui-windows95');
                        this.setupWindows95Interface();
                        this.log('✅ Switched to Windows 95 theme', 'success');
                        this.log('💻 Authentic retro DOS window experience!', 'info');
                        break;
                    case 'limewire':
                        document.body.classList.add('gui-limewire');
                        this.setupLimewireInterface();
                        this.log('✅ Switched to Limewire theme', 'success');
                        this.log('🎵 P2P file sharing retro interface activated!', 'info');
                        break;
                    case 'off':
                    case 'normal':
                    case 'default':
                        this.restoreOriginalTerminal();
                        this.log('✅ Returned to standard terminal theme', 'success');
                        this.log('🖥️ Classic terminal interface restored', 'info');
                        break;
                    default:
                        this.log(`❌ Unknown GUI theme: ${theme}`, 'error');
                        this.log('Type "gui" for available themes', 'info');
                }
            }

                    setupChatGPTInterface() {
                // Transform terminal into ChatGPT-style interface
                this.log('🤖 ChatGPT interface loading...', 'info');
                
                // Add GUI body class  
                document.body.className = 'gui-chatgpt';
                
                // Create ChatGPT interface structure
                const terminal = document.getElementById('terminal');
                terminal.style.height = '100vh';
                terminal.innerHTML = `
                    <div style="height: 100vh; display: flex; flex-direction: column; background: #212121; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
                        <!-- Header with back button -->
                        <div style="position: absolute; top: 20px; left: 20px; z-index: 100;">
                            <button onclick="window.terminal.handleGuiCommand(['gui', 'off'])" 
                                    style="background: #424242; color: #ececec; border: 1px solid #565656; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                                ← Terminal
                            </button>
                        </div>
                        
                        <!-- Conversation area -->
                        <div class="chatgpt-conversation" style="flex: 1; overflow-y: auto; padding: 80px 20px 200px 20px; max-width: 768px; margin: 0 auto; width: 100%;">
                            <div style="text-align: center; margin-bottom: 40px;">
                                <div style="font-size: 48px; margin-bottom: 16px;">🤖</div>
                                <h1 style="color: #ececec; font-size: 32px; font-weight: 300; margin: 0;">Omega Terminal AI</h1>
                                <p style="color: #8e8ea0; margin-top: 12px; font-size: 16px;">Type any command below!</p>
                            </div>
                        </div>
                        
                        <!-- Centered input at bottom -->
                        <div style="position: fixed; bottom: 0; left: 0; right: 0; background: #212121; padding: 32px 20px; border-top: 1px solid #424242;">
                            <div style="max-width: 768px; margin: 0 auto;">
                                <div style="position: relative; display: flex; align-items: center; background: #2f2f2f; border: 1px solid #565656; border-radius: 24px; padding: 12px 16px;">
                                    <div style="color: #8e8ea0; margin-right: 12px; font-size: 20px;">+</div>
                                    <input type="text" 
                                           placeholder="Type any terminal command..." 
                                           id="chatgptInput" 
                                           onkeypress="if(event.key==='Enter') window.terminal.handleChatGPTCommand();"
                                           style="flex: 1; background: none; border: none; color: #ececec; font-size: 16px; outline: none; padding: 4px 0;" />
                                    <div style="display: flex; gap: 8px; margin-left: 12px;">
                                        <div style="color: #8e8ea0; cursor: pointer; padding: 4px;">🎤</div>
                                        <div onclick="window.terminal.handleChatGPTCommand()" 
                                             style="background: #19c37d; color: white; border: none; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; cursor: pointer;">
                                            ➤
                                        </div>
                                    </div>
                                </div>
                                <p style="text-align: center; color: #8e8ea0; font-size: 13px; margin-top: 16px; margin-bottom: 0;">
                                    Try: balance, help, connect, mine, faucet
                                </p>
                            </div>
                        </div>
                    </div>
                `;
                
                this.currentInterface = 'chatgpt';
                this.log('💬 Chat bubbles and conversation mode activated', 'success');
                
                // Focus input
                setTimeout(() => {
                    document.getElementById('chatgptInput')?.focus();
                }, 100);
            }

            setupiOSInterface() {
                // Transform terminal into iOS Messages-style interface
                this.log('📱 iOS Messages interface loading...', 'info');
                
                // Add GUI body class  
                document.body.className = 'gui-ios';
                
                // Create iOS Messages interface structure
                const terminal = document.getElementById('terminal');
                terminal.style.height = '100vh';
                terminal.innerHTML = `
                    <div style="height: 100vh; display: flex; flex-direction: column; background: linear-gradient(180deg, #000000 0%, #1c1c1e 100%); font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;">
                        <!-- iOS Status Bar -->
                        <div style="background: rgba(0,0,0,0.8); backdrop-filter: blur(20px); padding: 8px 20px; display: flex; justify-content: space-between; align-items: center; color: white; font-size: 17px; font-weight: 600; border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <button onclick="window.terminal.handleGuiCommand(['gui', 'off'])" 
                                        style="background: none; border: none; color: #007AFF; font-size: 17px; cursor: pointer;">← Terminal</button>
                                <div style="width: 32px; height: 32px; border-radius: 50%; background: linear-gradient(135deg, #007AFF, #34C759); display: flex; align-items: center; justify-content: center; color: white; font-size: 16px; font-weight: bold;">Ω</div>
                                <span style="color: white; font-weight: 600;">Omega Network</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 6px; font-size: 14px;">
                                <span>●●●</span>
                                <span style="background: #34C759; width: 18px; height: 10px; border-radius: 2px;"></span>
                                <span>100%</span>
                            </div>
                        </div>
                        
                        <!-- Messages Area -->
                        <div style="flex: 1; padding: 16px; overflow-y: auto; background: #000000;" id="iosConversation">
                            <!-- Welcome message from system -->
                            <div style="display: flex; justify-content: flex-start; margin: 10px 0;">
                                <div style="background: rgba(142, 142, 147, 0.12); color: #FFFFFF; padding: 12px 16px; border-radius: 20px; max-width: 75%; font-size: 16px; line-height: 1.4;">
                                    👋 Welcome to Omega Terminal<br/>
                                    Try: <strong>balance</strong>, <strong>mine</strong>, <strong>claim</strong>, or <strong>help</strong>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Input Area -->
                        <div style="background: rgba(28, 28, 30, 0.95); backdrop-filter: blur(20px); padding: 16px; border-top: 1px solid rgba(255,255,255,0.1);">
                            <div style="display: flex; align-items: center; gap: 12px; background: rgba(58, 58, 60, 0.8); border-radius: 24px; padding: 8px 16px; border: 1px solid rgba(255,255,255,0.1);">
                                <input type="text" 
                                       placeholder="iMessage" 
                                       id="iosInput" 
                                       onkeypress="if(event.key==='Enter'){window.terminal.handleiOSCommand();}"
                                       style="flex: 1; background: none; border: none; color: #FFFFFF; font-size: 17px; outline: none; padding: 8px 0; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;" />
                                <button onclick="window.terminal.handleiOSCommand()" 
                                        style="background: #007AFF; color: white; border: none; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 16px; transition: all 0.2s; box-shadow: 0 2px 8px rgba(0, 122, 255, 0.3);">
                                    ↑
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                
                this.currentInterface = 'ios';
                this.log('📱 iOS Messages interface activated', 'success');
                
                // Focus input
                setTimeout(() => {
                    document.getElementById('iosInput')?.focus();
                }, 100);
            }

            setupDiscordInterface() {
                // Transform terminal into Discord-style interface
                this.log('🎮 Discord interface loading...', 'info');
                
                // Add GUI body class
                document.body.className = 'gui-discord';
                
                // Create Discord interface structure that matches CSS
                const terminal = document.getElementById('terminal');
                terminal.style.height = '100vh';
                terminal.innerHTML = `
                    <div class="discord-app">
                        <div class="discord-sidebar">
                            <div class="discord-server">Ω</div>
                            <div class="discord-channels">
                                <div class="channel-category">Text Channels</div>
                                <div class="channel active"># omega-terminal</div>
                                <div class="channel"># general</div>
                                <div class="channel"># mining</div>
                                <div class="channel"># ambassador</div>
                            </div>
                        </div>
                        <div class="discord-main">
                            <div class="discord-header">
                                # omega-terminal
                                <button onclick="window.terminal.handleGuiCommand(['gui', 'off'])" style="background: #f04747; color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; margin-left: auto;">Exit</button>
                            </div>
                            <div class="discord-messages" id="discordMessages">
                                <div class="discord-message">
                                    <div class="message-author">Omega Bot</div>
                                    <div class="message-text">Welcome to Omega Terminal Discord mode! Type any command to continue.</div>
                                </div>
                            </div>
                            <div class="discord-input">
                                <input type="text" placeholder="Message #omega-terminal" id="discordInput" onkeypress="if(event.key==='Enter'){window.terminal.handleDiscordCommand();}">
                                <button onclick="window.terminal.handleDiscordCommand()">Send</button>
                            </div>
                        </div>
                    </div>
                `;
                
                this.currentInterface = 'discord';
                this.log('💬 Full-screen chat mode activated', 'success');
                
                // Input handler is now inline in HTML - no setup needed
            }

            setupAOLInterface() {
                // Create AOL-style interface
                // Add GUI body class
                document.body.className = 'gui-aol';
                
                this.log('📞 AOL Instant Messenger loading...', 'info');
                
                // Create AOL interface structure that matches CSS
                const terminal = document.getElementById('terminal');
                terminal.style.height = '100vh';
                terminal.innerHTML = `
                    <div class="aol-window">
                        <div class="aol-titlebar">
                            <span>AOL Instant Messenger - Omega Terminal</span>
                            <div class="aol-buttons">
                                <button onclick="window.terminal.handleGuiCommand(['gui', 'off'])">X</button>
                            </div>
                        </div>
                        <div class="aol-content">
                            <div class="aol-buddylist">
                                <div class="aol-section">
                                    <strong>Online Buddies (3)</strong>
                                    <div class="buddy">OmegaMiner42</div>
                                    <div class="buddy">CryptoTrader</div>
                                    <div class="buddy">Web3Ninja</div>
                                </div>
                                <div class="aol-section">
                                    <strong>Away (1)</strong>
                                    <div class="buddy">Ambassador1</div>
                                </div>
                            </div>
                            <div class="aol-chat">
                                <div class="aol-messages" id="aolMessages">
                                    <div class="aol-message">
                                        <strong>OmegaBot:</strong> Welcome to AOL Omega Terminal! Type commands to chat.
                                    </div>
                                </div>
                                <div class="aol-input">
                                    <input type="text" placeholder="Type your message..." id="aolInput" onkeypress="if(event.key==='Enter'){window.terminal.handleAOLCommand();}">
                                    <button onclick="window.terminal.handleAOLCommand()">Send</button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                this.currentInterface = 'aol';
                this.log('✨ 90s nostalgia mode activated', 'success');
                
                // Input handler is now inline in HTML - no setup needed
            }

            setupWindows95Interface() {
                // Create Windows 95-style interface
                // Add GUI body class
                document.body.className = 'gui-windows95';
                
                this.log('💻 Windows 95 interface loading...', 'info');
                this.log('🖥️ Authentic DOS window experience', 'success');
                this.log('⚡ Retro computing mode activated', 'info');
            }

            setupLimewireInterface() {
                // Create Limewire-style interface
                // Add GUI body class
                document.body.className = 'gui-limewire';
                
                this.log('🎵 Limewire interface loading...', 'info');
                this.log('🔗 P2P file sharing theme activated', 'success');
                this.log('💚 Retro green interface ready', 'info');
            }

            async executeCommandInGUI(command, theme) {
                try {
                    // Store current GUI interface
                    const currentHTML = document.getElementById('terminal').innerHTML;
                    
                    // Temporarily restore basic terminal structure for command execution
                    document.getElementById('terminal').innerHTML = `
                        <div class="terminal-content" id="terminalContent"></div>
                        <div style="display: none;">
                            <input id="commandInput" value="">
                        </div>
                    `;
                    
                    // Execute the actual terminal command
                    await this.executeCommand(command);
                    
                    // Get the output from the terminal content
                    const output = document.getElementById('terminalContent').textContent || 'Command executed';
                    
                    // Restore GUI interface
                    document.getElementById('terminal').innerHTML = currentHTML;
                    
                    // Re-apply body class for styling
                    if (theme === 'ios') {
                        document.body.className = 'gui-ios';
                    } else if (theme === 'chatgpt') {
                        document.body.className = 'gui-chatgpt';
                    } else if (theme === 'discord') {
                        document.body.className = 'gui-discord';
                    } else if (theme === 'aol') {
                        document.body.className = 'gui-aol';
                    }
                    
                    // Clean up output for better display
                    const cleanOutput = output.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, '').trim();
                    
                    // Display result in appropriate GUI theme
                    if (theme === 'ios') {
                        this.addiOSMessage(`${cleanOutput || '✅ Command completed successfully!'}`, 'system');
                    } else if (theme === 'chatgpt') {
                        this.addChatGPTMessage(`${cleanOutput || 'Command completed successfully!'}`, 'assistant');
                    } else if (theme === 'discord') {
                        this.addDiscordMessage(`✅ ${cleanOutput || 'Command completed!'}`, 'bot');
                    } else if (theme === 'aol') {
                        this.addAOLMessage(`${cleanOutput || 'Command done!'}`, 'bot');
                    }
                    
                } catch (error) {
                    // Restore GUI on error
                    const currentHTML = document.getElementById('terminal').innerHTML;
                    if (!currentHTML.includes('iosConversation') && !currentHTML.includes('chatgpt-conversation') && !currentHTML.includes('discord') && !currentHTML.includes('aol')) {
                        // Need to restore GUI - something went wrong
                        if (theme === 'ios') {
                            this.setupiOSInterface();
                        } else if (theme === 'chatgpt') {
                            this.setupChatGPTInterface();
                        } else if (theme === 'discord') {
                            this.setupDiscordInterface();
                        } else if (theme === 'aol') {
                            this.setupAOLInterface();
                        }
                    }
                    
                    if (theme === 'ios') {
                        this.addiOSMessage(`❌ Error: ${error.message}`, 'system');
                    } else if (theme === 'chatgpt') {
                        this.addChatGPTMessage(`❌ Error: ${error.message}`, 'assistant');
                    } else if (theme === 'discord') {
                        this.addDiscordMessage(`❌ Error: ${error.message}`, 'bot');
                    } else if (theme === 'aol') {
                        this.addAOLMessage(`Error: ${error.message}`, 'bot');
                    }
                }
            }

            async safeExecuteCommand(command) {
                try {
                    // Store original DOM functions that might fail in GUI mode
                    const originalLog = this.log;
                    const originalLogHtml = this.logHtml;
                    
                    // Mock the log functions to prevent DOM errors
                    this.log = () => {}; // Silently ignore
                    this.logHtml = () => {}; // Silently ignore
                    
                    // Mock getElementById to prevent null errors
                    const originalGetElementById = document.getElementById;
                    document.getElementById = function(id) {
                        const element = originalGetElementById.call(document, id);
                        if (!element && (id === 'terminalContent' || id === 'commandInput')) {
                            // Return a mock element for critical terminal elements
                            return {
                                innerHTML: '',
                                appendChild: () => {},
                                scrollTop: 0,
                                style: {},
                                focus: () => {},
                                value: ''
                            };
                        }
                        return element;
                    };
                    
                    // Execute the command
                    await this.executeCommand(command);
                    
                    // Restore original functions
                    this.log = originalLog;
                    this.logHtml = originalLogHtml;
                    document.getElementById = originalGetElementById;
                    
                    return { success: true };
                } catch (error) {
                    // Restore functions in case of error
                    this.log = this.log.bind ? this.log : () => {};
                    this.logHtml = this.logHtml.bind ? this.logHtml : () => {};
                    document.getElementById = document.getElementById.bind ? document.getElementById : (id) => document.querySelector('#' + id);
                    
                    return { success: false, error: error.message };
                }
            }

                    async handleChatGPTCommand() {
                const input = document.getElementById('chatgptInput');
                if (!input) return;
                
                const command = input.value.trim();
                if (!command) return;
                
                // Add user message
                this.addChatGPTMessage(command, 'user');
                input.value = '';
                
                // Process command
                if (command === 'help') {
                    this.addChatGPTMessage('Available commands:\n• **test** - Test GUI functionality\n• **balance** - Check your OMEGA balance\n• **mine** - Start mining session\n• **claim** - Claim your rewards\n• **gui off** - Exit ChatGPT mode', 'assistant');
                } else if (command === 'test') {
                    this.addChatGPTMessage('✅ ChatGPT GUI is working perfectly!', 'assistant');
                } else if (command === 'gui off') {
                    this.handleGuiCommand(['gui', 'off']);
                } else if (command === 'balance') {
                    this.addChatGPTMessage('Checking your balance...', 'assistant');
                    this.executeCommandInGUI(command, 'chatgpt');
                } else if (command === 'mine') {
                    this.addChatGPTMessage('Starting mining session...', 'assistant');
                    this.executeCommandInGUI(command, 'chatgpt');
                } else if (command === 'claim') {
                    this.addChatGPTMessage('Processing claim...', 'assistant');
                    this.executeCommandInGUI(command, 'chatgpt');
                } else {
                    this.addChatGPTMessage(`Processing "${command}"...`, 'assistant');
                    // Try to execute other commands
                    this.safeExecuteCommand(command).then((result) => {
                        this.addChatGPTMessage(result.success ? `✅ ${command} completed` : `❌ ${result.error}`, 'assistant');
                    });
                }
            }

            async handleiOSCommand() {
                const input = document.getElementById('iosInput');
                if (!input) return;
                
                const command = input.value.trim();
                if (!command) return;
                
                // Add user message (blue bubble on right)
                this.addiOSMessage(command, 'user');
                input.value = '';
                
                // Process command with a small delay for realistic feel
                setTimeout(() => {
                    if (command === 'help') {
                        this.addiOSMessage('Available commands:\n• balance - Check your OMEGA balance\n• mine - Start mining session\n• claim - Claim your rewards\n• gui off - Exit iOS mode', 'system');
                    } else if (command === 'test') {
                        this.addiOSMessage('✅ iOS GUI is working perfectly! 📱', 'system');
                    } else if (command === 'gui off') {
                        this.handleGuiCommand(['gui', 'off']);
                    } else if (command === 'balance') {
                        this.addiOSMessage('⏳ Checking your balance...', 'system');
                        this.executeCommandInGUI(command, 'ios');
                    } else if (command === 'mine') {
                        this.addiOSMessage('⛏️ Starting mining session...', 'system');
                        this.executeCommandInGUI(command, 'ios');
                    } else if (command === 'claim') {
                        this.addiOSMessage('💰 Processing claim...', 'system');
                        this.executeCommandInGUI(command, 'ios');
                    } else {
                        this.addiOSMessage(`⚡ Processing "${command}"...`, 'system');
                        // Try to execute other commands
                        this.safeExecuteCommand(command).then((result) => {
                            this.addiOSMessage(result.success ? `✅ ${command} completed` : `❌ ${result.error}`, 'system');
                        });
                    }
                }, 300); // Small delay for realistic messaging feel
            }

            async handleDiscordCommand() {
                const input = document.getElementById('discordInput');
                if (!input) return;
                
                const command = input.value.trim();
                if (!command) return;
                
                // Add user message
                this.addDiscordMessage(command, 'user');
                input.value = '';
                
                // Process command
                if (command === 'help') {
                    this.addDiscordMessage('**Available Commands:**\n`test` - Test functionality\n`balance` - Check OMEGA balance\n`mine` - Start mining session\n`claim` - Claim rewards\n`gui off` - Exit Discord', 'bot');
                } else if (command === 'test') {
                    this.addDiscordMessage('✅ **Discord GUI Working!**', 'bot');
                } else if (command === 'gui off') {
                    this.handleGuiCommand(['gui', 'off']);
                } else if (command === 'balance') {
                    this.addDiscordMessage('💰 Checking balance...', 'bot');
                    this.executeCommandInGUI(command, 'discord');
                } else if (command === 'mine') {
                    this.addDiscordMessage('⛏️ Starting mining...', 'bot');
                    this.executeCommandInGUI(command, 'discord');
                } else if (command === 'claim') {
                    this.addDiscordMessage('💎 Processing claim...', 'bot');
                    this.executeCommandInGUI(command, 'discord');
                } else {
                    this.addDiscordMessage(`🔄 Processing "${command}"...`, 'bot');
                    this.safeExecuteCommand(command).then((result) => {
                        this.addDiscordMessage(result.success ? `✅ ${command} completed` : `❌ ${result.error}`, 'bot');
                    });
                }
            }

            addDiscordMessage(content, sender) {
                const messages = document.getElementById('discordMessages');
                if (!messages) return;
                
                const messageEl = document.createElement('div');
                messageEl.className = 'discord-message';
                
                const username = sender === 'user' ? 'You' : 'Omega Bot';
                
                messageEl.innerHTML = `
                    <div class="message-author">${username}</div>
                    <div class="message-text">
                        <pre style="font-family: monospace; white-space: pre-wrap; margin: 0; color: #dcddde;">${content}</pre>
                    </div>
                `;
                
                messages.appendChild(messageEl);
                messages.scrollTop = messages.scrollHeight;
            }

            async handleAOLCommand() {
                const input = document.getElementById('aolInput');
                if (!input) return;
                
                const command = input.value.trim();
                if (!command) return;
                
                // Add user message
                this.addAOLMessage(command, 'user');
                input.value = '';
                
                // Process command
                if (command === 'help') {
                    this.addAOLMessage('Commands: test, balance, mine, claim, gui off', 'bot');
                } else if (command === 'test') {
                    this.addAOLMessage('AOL GUI working!', 'bot');
                } else if (command === 'gui off') {
                    this.handleGuiCommand(['gui', 'off']);
                } else if (command === 'balance') {
                    this.addAOLMessage('Checking balance...', 'bot');
                    this.executeCommandInGUI(command, 'aol');
                } else if (command === 'mine') {
                    this.addAOLMessage('Mining started...', 'bot');
                    this.executeCommandInGUI(command, 'aol');
                } else if (command === 'claim') {
                    this.addAOLMessage('Processing claim...', 'bot');
                    this.executeCommandInGUI(command, 'aol');
                } else {
                    this.addAOLMessage(`Processing "${command}"...`, 'bot');
                    this.safeExecuteCommand(command).then((result) => {
                        this.addAOLMessage(result.success ? `${command} done` : `Error: ${result.error}`, 'bot');
                    });
                }
            }
            




            addAOLMessage(content, sender) {
                const messages = document.getElementById('aolMessages');
                if (!messages) return;
                
                const messageEl = document.createElement('div');
                messageEl.className = 'aol-message';
                
                const username = sender === 'user' ? 'You' : 'OmegaBot';
                messageEl.innerHTML = `<strong>${username}:</strong> ${content}`;
                
                messages.appendChild(messageEl);
                messages.scrollTop = messages.scrollHeight;
            }

            addChatGPTMessage(content, sender) {
                const conversation = document.querySelector('.chatgpt-conversation');
                if (!conversation) return;
                
                const messageEl = document.createElement('div');
                messageEl.className = `chat-message ${sender}`;
                
                if (sender === 'user') {
                    // User messages on the right - GREEN BUBBLES!
                    messageEl.innerHTML = `
                        <div style="display: flex; justify-content: flex-end; margin: 10px 0;">
                            <div style="background: #19c37d; color: white; padding: 12px 16px; border-radius: 18px; max-width: 70%; margin-right: 12px;">
                                ${content}
                            </div>
                            <div style="width: 32px; height: 32px; border-radius: 50%; background: #19c37d; color: white; display: flex; align-items: center; justify-content: center; font-size: 16px;">👤</div>
                        </div>
                    `;
                } else {
                    // Assistant messages on the left - PURPLE AVATAR!
                    messageEl.innerHTML = `
                        <div style="display: flex; justify-content: flex-start; margin: 10px 0;">
                            <div style="width: 32px; height: 32px; border-radius: 50%; background: #ab68ff; color: white; display: flex; align-items: center; justify-content: center; font-size: 16px; margin-right: 12px;">🤖</div>
                            <div style="background: transparent; color: #ececec; padding: 12px 16px; border-radius: 18px; max-width: 70%;">
                                ${content}
                            </div>
                        </div>
                    `;
                }
                
                conversation.appendChild(messageEl);
                conversation.scrollTop = conversation.scrollHeight;
            }

            addiOSMessage(content, sender) {
                const conversation = document.getElementById('iosConversation');
                if (!conversation) return;
                
                const messageEl = document.createElement('div');
                messageEl.className = `ios-message ${sender}`;
                
                if (sender === 'user') {
                    // User messages on the right - Blue iOS bubbles
                    messageEl.innerHTML = `
                        <div style="display: flex; justify-content: flex-end; margin: 8px 0; animation: slideInRight 0.3s ease-out;">
                            <div style="background: #007AFF; color: white; padding: 12px 16px; border-radius: 20px; max-width: 75%; font-size: 16px; line-height: 1.4; box-shadow: 0 2px 8px rgba(0, 122, 255, 0.3); word-wrap: break-word;">
                                ${content.replace(/\n/g, '<br>')}
                            </div>
                        </div>
                    `;
                } else {
                    // System messages on the left - Gray iOS bubbles  
                    messageEl.innerHTML = `
                        <div style="display: flex; justify-content: flex-start; margin: 8px 0; animation: slideInLeft 0.3s ease-out;">
                            <div style="background: rgba(142, 142, 147, 0.12); color: #FFFFFF; padding: 12px 16px; border-radius: 20px; max-width: 75%; font-size: 16px; line-height: 1.4; border: 1px solid rgba(255,255,255,0.1); word-wrap: break-word;">
                                ${content.replace(/\n/g, '<br>')}
                            </div>
                        </div>
                    `;
                }
                
                conversation.appendChild(messageEl);
                conversation.scrollTop = conversation.scrollHeight;
                
                // Add subtle haptic-like effect
                messageEl.style.transform = 'scale(0.95)';
                setTimeout(() => {
                    messageEl.style.transform = 'scale(1)';
                    messageEl.style.transition = 'transform 0.1s ease-out';
                }, 50);
            }

            restoreOriginalTerminal() {
                // Remove all GUI body classes
                document.body.className = '';
                
                // Store current interface state
                const currentInterface = this.currentInterface;
                this.currentInterface = 'terminal';
                
                // Restore original terminal HTML structure
                const terminal = document.getElementById('terminal');
                terminal.style.height = '';
                terminal.innerHTML = `
                    <div class="terminal-header">
                        <div class="terminal-title">Omega Terminal v1.5.9</div>
                        <div style="display: flex; align-items: center; gap: 18px; margin-left: auto;">
                            <button class="ai-toggle" title="Toggle AI Mode" id="aiToggle">AI Mode (off)</button>
                            <button class="theme-toggle" title="Toggle Theme"></button>
                            <div class="terminal-status" id="connectionStatus">CONNECTED</div>
                        </div>
                    </div>
                    <div class="tab-bar" id="tabBar" style="display: flex; align-items: center; background: #111; border-bottom: 1px solid #fff;">
                        <div class="tab active" data-tab="0" style="padding: 8px 18px; cursor: pointer; border-right: 1px solid #333; color: #fff; font-weight: bold;">Terminal 1</div>
                        <div id="addTabBtn" style="padding: 8px 18px; cursor: pointer; color: #00bcf2; font-size: 1.3em;">+</div>
                    </div>
                    <div class="terminal-content" id="terminalContent"></div>
                    <div class="terminal-input-section">
                        <div class="input-line">
                            <span class="input-prompt">root@omega-miner:~$</span>
                            <input type="text" class="input-field" id="commandInput" placeholder="Enter command..." autocomplete="off">
                            <span class="cursor">|</span>
                        </div>
                    </div>
                `;
                
                // Restore event listeners
                this.setupEventListeners();
            }

            renderTabs() {
                const tabBar = document.getElementById('tabBar');
                if (!tabBar) return;
                // Clear existing tabs except the add button
                const addBtn = document.getElementById('addTabBtn');
                tabBar.innerHTML = '';
                if (addBtn) tabBar.appendChild(addBtn);
                this.tabs.forEach((tab, index) => {
                    const tabElement = document.createElement('div');
                    tabElement.className = `tab ${index === this.activeTab ? 'active' : ''}`;
                    tabElement.dataset.tab = index;
                    tabElement.style.cssText = 'padding: 8px 18px; cursor: pointer; border-right: 1px solid #333; color: #fff; font-weight: bold; display: flex; align-items: center; position: relative;';
                    tabElement.onclick = (e) => {
                        // Prevent switching if close button is clicked
                        if (e.target.classList.contains('tab-close')) return;
                        this.switchTab(index);
                    };
                    tabElement.textContent = tab.name;
                    // Add close button for all tabs except the first
                    if (index > 0) {
                        const closeBtn = document.createElement('span');
                        closeBtn.textContent = ' ×';
                        closeBtn.className = 'tab-close';
                        closeBtn.style.cssText = 'margin-left: 8px; color: #ff3333; cursor: pointer; font-weight: bold;';
                        closeBtn.onclick = (e) => {
                            e.stopPropagation();
                            this.closeTab(index);
                        };
                        tabElement.appendChild(closeBtn);
                    }
                    tabBar.insertBefore(tabElement, addBtn);
                });
            }

            switchTab(index) {
                if (index === this.activeTab) return;
                this.activeTab = index;
                this.renderTabs();
                this.loadTabContent();
            }

            closeTab(index) {
                if (index === 0) return; // Never close the first tab
                this.tabs.splice(index, 1);
                // Adjust activeTab if needed
                if (this.activeTab >= index) {
                    this.activeTab = Math.max(0, this.activeTab - 1);
                }
                this.renderTabs();
                this.loadTabContent();
            }

            loadTabContent() {
                const tab = this.tabs[this.activeTab];
                if (!tab) return;
                const terminalContent = document.getElementById('terminalContent');
                terminalContent.innerHTML = '';
                // Load tab history
                if (tab.history && tab.history.length) {
                    tab.history.forEach(item => {
                        if (item.type === 'command') {
                            this.logCommand(item.content);
                        } else {
                            this.logHtml(item.content, item.logType || 'output');
                        }
                    });
                }
            }

            clearTerminalContent() {
                const terminalContent = document.getElementById('terminalContent');
                terminalContent.innerHTML = '';
                // Also clear the tab's history
                const tab = this.tabs[this.activeTab];
                if (tab) tab.history = [];
            }

            async airdrop() {
                this.log('🎁 Incoming airdrop!', 'info');
                // Create and show Airdrop popup
                const modal = document.createElement('div');
                modal.id = 'airdropModal';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;
                const imgContainer = document.createElement('div');
                imgContainer.style.cssText = `
                    position: relative;
                    width: 80%;
                    max-width: 600px;
                    height: 60%;
                    max-height: 400px;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    background: #111;
                    border-radius: 10px;
                    box-shadow: 0 0 30px #00bcf2;
                `;
                const closeBtn = document.createElement('button');
                closeBtn.textContent = '×';
                closeBtn.style.cssText = `
                    position: absolute;
                    top: -40px;
                    right: 0;
                    background: #ff3333;
                    color: white;
                    border: none;
                    font-size: 24px;
                    width: 40px;
                    height: 40px;
                    cursor: pointer;
                    border-radius: 50%;
                    z-index: 10001;
                `;
                closeBtn.onclick = () => {
                    document.body.removeChild(modal);
                };
                const img = document.createElement('img');
                img.src = 'https://i.postimg.cc/g08SBcPg/Metal-Pole-Bang-for-nearly-15-minutes-crazy-art-dance.gif'; // user-provided gif
                img.alt = 'Airdrop';
                img.style.cssText = 'max-width:100%; max-height:100%; border-radius:10px;';
                imgContainer.appendChild(closeBtn);
                imgContainer.appendChild(img);
                // Add Roy message below the GIF with spacing and centered
                const msg = document.createElement('div');
                msg.innerHTML = `<div style="color:#fff; text-align:center; font-size:1.5em; margin-top:28px; font-weight:bold;">Roy says not yet</div>`;
                imgContainer.appendChild(msg);
                modal.appendChild(imgContainer);
                document.body.appendChild(modal);
                // Auto-close after 30 seconds
                setTimeout(() => {
                    if (document.body.contains(modal)) {
                        document.body.removeChild(modal);
                    }
                }, 30000);
            }
            
            // Helper methods for Eclipse swaps
            async executeSolarSwap(inputMint, outputMint, amount, slippageBps) {
                // Step 1: Get quote using GET request with query parameters
                this.log('Getting Solar DEX quote...', 'info');
                
                // Ensure we have the correct SOL mint address
                const solMintAddress = 'So11111111111111111111111111111111111111112';
                const actualInputMint = inputMint === '11111111111111111111111111111111' ? solMintAddress : inputMint;
                const actualOutputMint = outputMint === '11111111111111111111111111111111' ? solMintAddress : outputMint;
                
                // Convert amount to proper decimals (assuming 9 decimals for most tokens)
                const amountInDecimals = amount * 1e9;
                
                // Build query parameters
                const queryParams = new URLSearchParams({
                    inputMint: actualInputMint,
                    outputMint: actualOutputMint,
                    amount: amountInDecimals.toString(),
                    slippageBps: slippageBps.toString(),
                    txVersion: 'LEGACY'
                });
                
                // this.log(`Quote URL: https://api.solarstudios.co/compute/swap-base-in?${queryParams.toString()}`, 'info');
                
                const quoteResponse = await fetch(`https://api.solarstudios.co/compute/swap-base-in?${queryParams.toString()}`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (!quoteResponse.ok) {
                    const errorText = await quoteResponse.text();
                    this.log(`Solar quote failed: HTTP ${quoteResponse.status}`, 'error');
                    this.log(`Error details: ${errorText}`, 'error');
                    this.log(`Debug: Request URL: ${quoteResponse.url}`, 'info');
                    throw new Error('Solar quote failed');
                }
                
                const quoteData = await quoteResponse.json();
                // this.log(`Solar quote received: ${JSON.stringify(quoteData)}`, 'success');
                
                if (!quoteData.success) {
                    this.log(`Quote failed: ${quoteData.msg || 'Unknown error'}`, 'error');
                    throw new Error('Solar quote failed');
                }
                
                // Step 2: Get transaction using the quote response
                this.log('Getting Solar transaction...', 'info');
                
                const transactionPayload = {
                    computeUnitPriceMicroLamports: String(300000),
                    swapResponse: quoteData,
                    txVersion: 'LEGACY',
                    wallet: window.eclipseWallet.keypair.publicKey.toString(),
                    wrapSol: actualInputMint === solMintAddress,
                    unwrapSol: actualOutputMint === solMintAddress,
                    inputAccount: window.eclipseWallet.keypair.publicKey.toString(), // Simplified for now
                    outputAccount: window.eclipseWallet.keypair.publicKey.toString()  // Simplified for now
                };
                
                // this.log(`Transaction payload: ${JSON.stringify(transactionPayload)}`, 'info');
                
                const txResponse = await fetch('https://api.solarstudios.co/transaction/swap-base-in', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(transactionPayload)
                });
                
                if (!txResponse.ok) {
                    const errorText = await txResponse.text();
                    this.log(`Solar transaction failed: ${errorText}`, 'error');
                    throw new Error('Solar transaction failed');
                }
                
                const txData = await txResponse.json();
                // this.log(`Solar transaction received: ${JSON.stringify(txData)}`, 'success');
                
                if (!txData.success) {
                    this.log(`Transaction failed: ${txData.msg || 'Unknown error'}`, 'error');
                    throw new Error('Solar transaction failed');
                }
                
                // Step 3: Sign and send transactions
                this.log('Signing and sending transactions...', 'info');
                
                const connection = new window.solanaWeb3.Connection(window.eclipseWallet.rpcUrl, 'confirmed');
                
                // Handle multiple transactions (like the dev's code)
                const allTxBuf = txData.data.map(tx => Buffer.from(tx.transaction, 'base64'));
                const allTransactions = allTxBuf.map(txBuf => window.solanaWeb3.Transaction.from(txBuf));
                
                this.log(`Total ${allTransactions.length} transactions to process`, 'info');
                
                for (let idx = 0; idx < allTransactions.length; idx++) {
                    const transaction = allTransactions[idx];
                    
                    // Add blockhash
                    const {blockhash, lastValidBlockHeight} = await connection.getLatestBlockhash();
                    transaction.recentBlockhash = blockhash;
                    
                    // Sign the transaction
                    transaction.sign(window.eclipseWallet.keypair);
                    
                    // Serialize and send
                    const txId = await connection.sendRawTransaction(transaction.serialize(), {
                        skipPreflight: false,
                    });
                    
                    this.log(`${idx + 1} transaction sending..., txId: ${txId}`, 'info');
                    
                    await connection.confirmTransaction({
                        blockhash,
                        lastValidBlockHeight,
                        signature: txId,
                    }, 'confirmed');
                    
                    this.log(`${idx + 1} transaction confirmed`, 'success');
                    
                    this.log(`✅ Solar swap completed successfully!`, 'success');
                    this.log(`Transaction: https://explorer.eclipse.xyz/tx/${txId}`, 'info');
                    return;
                }
            }
            
            async executeDeserializeSwap(inputMint, outputMint, amount, slippageBps) {
                // Step 0: Check balances first
                this.log('Checking wallet balances...', 'info');
                
                try {
                    const connection = new window.solanaWeb3.Connection(window.eclipseWallet.rpcUrl, 'confirmed');
                    
                    // Check SOL balance for transaction fees
                    const solBalance = await connection.getBalance(window.eclipseWallet.publicKey);
                    const solBalanceSol = solBalance / 1e9; // Convert lamports to SOL
                    
                    this.log(`SOL balance: ${solBalanceSol.toFixed(6)} SOL`, 'info');
                    
                    if (solBalanceSol < 0.001) {
                        this.log('❌ Insufficient SOL for transaction fees. Need at least 0.001 SOL.', 'error');
                        throw new Error('Insufficient SOL for transaction fees');
                    }
                    
                    // Check token balance if it's not SOL
                    if (inputMint !== 'So11111111111111111111111111111111111111112') { // Not SOL
                        const tokenAccount = await connection.getTokenAccountsByOwner(window.eclipseWallet.publicKey, {
                            mint: new window.solanaWeb3.PublicKey(inputMint)
                        });
                        
                        if (tokenAccount.value.length === 0) {
                            this.log(`❌ No ${inputMint} tokens found in wallet.`, 'error');
                            throw new Error(`No ${inputMint} tokens in wallet`);
                        }
                        
                        const tokenBalance = await connection.getTokenAccountBalance(tokenAccount.value[0].pubkey);
                        const tokenAmount = tokenBalance.value.uiAmount;
                        
                        this.log(`Token balance: ${tokenAmount} tokens`, 'info');
                        
                        if (tokenAmount < amount) {
                            this.log(`❌ Insufficient token balance. Have: ${tokenAmount}, Need: ${amount}`, 'error');
                            throw new Error('Insufficient token balance');
                        }
                    }
                    
                    this.log('✅ Balance check passed', 'success');
                } catch (e) {
                    if (e.message.includes('balance') || e.message.includes('tokens')) {
                        throw e; // Re-throw balance errors
                    }
                    this.log('⚠️ Could not verify balances, proceeding anyway...', 'warning');
                }
                
                // Step 1: Get quote
                this.log('Getting Deserialize quote...', 'info');
                
                const quotePayload = {
                    tokenA: inputMint,
                    tokenB: outputMint,
                    amountIn: amount.toString(),
                    dexId: "ALL",
                    options: {
                        reduceToTwoHops: false,
                        targetRouteNumber: 0
                    }
                };
                
                const quoteResponse = await fetch('https://api.deserialize.xyz/quote', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(quotePayload)
                });
                
                if (!quoteResponse.ok) {
                    const errorText = await quoteResponse.text();
                    this.log(`Deserialize quote failed: HTTP ${quoteResponse.status}`, 'error');
                    this.log(`Error details: ${errorText}`, 'error');
                    
                    // Try with different parameters
                    this.log('Trying Deserialize with different parameters...', 'info');
                    const altPayload = {
                        tokenA: inputMint,
                        tokenB: outputMint,
                        amountIn: amount.toString(),
                        dexId: "ALL", // Use ALL instead of JUPITER
                        options: {
                            reduceToTwoHops: true,
                            targetRouteNumber: 0
                        }
                    };
                    
                    const altResponse = await fetch('https://api.deserialize.xyz/quote', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(altPayload)
                    });
                    
                    if (!altResponse.ok) {
                        const altErrorText = await altResponse.text();
                        this.log(`Deserialize alternative attempt also failed: HTTP ${altResponse.status}`, 'error');
                        this.log(`Error details: ${altErrorText}`, 'error');
                        throw new Error('Deserialize quote failed - service may be down');
                    }
                    
                    // Use the alternative response
                    const quoteData = await altResponse.json();
                    this.log(`Deserialize quote received (alternative): ${quoteData.amountOut} output tokens`, 'success');
                    this.log(`Price impact: ${quoteData.priceImpact}%`, 'info');
                    return quoteData;
                }
                
                const quoteData = await quoteResponse.json();
                this.log(`Deserialize quote received: ${quoteData.amountOut} output tokens`, 'success');
                this.log(`Price impact: ${quoteData.priceImpact}%`, 'info');
                
                // Step 2: Get transaction
                this.log('Getting Deserialize transaction...', 'info');
                const swapPayload = {
                    publicKey: window.eclipseWallet.publicKey,
                    quote: quoteData,
                    fee: {
                        devFeeRate: 0.1, // 0.1% fee
                        partnerFeeAddress: window.eclipseWallet.publicKey
                    }
                };
                
                const txResponse = await fetch('https://api.deserialize.xyz/swap', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(swapPayload)
                });
                
                if (!txResponse.ok) {
                    const errorText = await txResponse.text();
                    this.log(`Deserialize transaction failed: ${errorText}`, 'error');
                    throw new Error('Deserialize transaction failed');
                }
                
                const txData = await txResponse.json();
                this.log('Deserialize transaction received, signing...', 'info');
                
                // Step 3: Sign and send transaction
                const connection = new window.solanaWeb3.Connection(window.eclipseWallet.rpcUrl, 'confirmed');
                
                // Handle both regular and versioned transactions
                let transaction;
                let signature;
                
                try {
                    // First try to deserialize as a regular transaction
                    transaction = window.solanaWeb3.Transaction.from(Buffer.from(txData.transaction, 'base64'));
                    transaction.sign(window.eclipseWallet.keypair);
                    signature = await connection.sendTransaction(transaction, [window.eclipseWallet.keypair]);
                } catch (e) {
                    // If that fails, try as a versioned transaction
                    if (e.message.includes('VersionedMessage')) {
                        this.log('Detected versioned transaction, using VersionedTransaction...', 'info');
                        transaction = window.solanaWeb3.VersionedTransaction.deserialize(Buffer.from(txData.transaction, 'base64'));
                        transaction.sign([window.eclipseWallet.keypair]);
                        signature = await connection.sendTransaction(transaction);
                    } else {
                        throw e; // Re-throw if it's a different error
                    }
                }
                
                this.log(`✅ Deserialize swap transaction submitted! Signature: ${signature}`, 'success');
                this.log('Waiting for confirmation...', 'info');
                
                const confirmation = await connection.confirmTransaction(signature, 'confirmed');
                if (confirmation.value.err) {
                    this.log(`❌ Deserialize transaction failed: ${confirmation.value.err}`, 'error');
                    throw new Error('Deserialize transaction failed');
                } else {
                    this.log(`✅ Deserialize swap completed successfully!`, 'success');
                    this.log(`Transaction: https://explorer.eclipse.xyz/tx/${signature}`, 'info');
                }
            }
            
            async showEclipseSwapInterface() {
                this.log('🔄 Eclipse Swap Interface', 'info');
                this.log('Loading available tokens...', 'info');
                
                try {
                    // Fetch tokens from both APIs
                    const [solarResponse, deserializeResponse] = await Promise.all([
                        fetch('https://api.solarstudios.co/mint/list'),
                        fetch('https://api.deserialize.xyz/tokenList')
                    ]);
                    
                    let solarTokens = [];
                    let deserializeTokens = [];
                    
                    if (solarResponse.ok) {
                        const solarData = await solarResponse.json();
                        if (solarData.success && solarData.data && solarData.data.mintList) {
                            solarTokens = solarData.data.mintList;
                        }
                    }
                    
                    if (deserializeResponse.ok) {
                        const deserializeData = await deserializeResponse.json();
                        if (deserializeData.data && Array.isArray(deserializeData.data)) {
                            deserializeTokens = deserializeData.data;
                        }
                    }
                    
                    // Merge tokens
                    const allTokens = new Map();
                    
                    solarTokens.forEach(token => {
                        allTokens.set(token.address, {
                            address: token.address,
                            symbol: token.symbol,
                            name: token.name,
                            decimals: token.decimals,
                            source: 'Solar'
                        });
                    });
                    
                    deserializeTokens.forEach(token => {
                        allTokens.set(token.address, {
                            address: token.address,
                            symbol: token.metadata?.symbol || 'N/A',
                            name: token.metadata?.name || 'N/A',
                            decimals: token.decimals,
                            source: allTokens.has(token.address) ? 'Both' : 'Deserialize'
                        });
                    });
                    
                    const tokens = Array.from(allTokens.values()).sort((a, b) => a.symbol.localeCompare(b.symbol));
                    
                    // Find ETH and SOLAR tokens for defaults (do this first)
                    const ethToken = tokens.find(t => t.symbol === 'ETH' || t.name.includes('Ethereum'));
                    const solarToken = tokens.find(t => t.symbol === 'SOLAR' || t.name.includes('SOLAR'));
                    
                    const defaultFromToken = ethToken || tokens[0];
                    const defaultToToken = solarToken || tokens[1] || tokens[0];
                    
                    // Create swap interface with custom dropdowns
                    let html = `<div style="background: rgba(255,255,255,0.05); border: 1px solid #ffffff; padding: 15px; border-radius: 5px; margin: 10px 0;">`;
                    html += `<h3 style="margin: 0 0 15px 0; color: #ffffff;">🔄 Eclipse Swap</h3>`;
                    
                    // From token selection with custom dropdown
                    html += `<div style="margin-bottom: 15px;">`;
                    html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">From Token:</label>`;
                    html += `<div class="custom-dropdown" style="position: relative; width: 100%;">`;
                    html += `<div class="dropdown-header" id="eclipseFromTokenHeader" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; cursor: pointer;">`;
                    html += `<span id="eclipseFromTokenDisplay">🟢 ${defaultFromToken?.name || 'Ethereum'}</span>`;
                    html += `<span style="color: #666;">▼</span>`;
                    html += `</div>`;
                    html += `<div class="dropdown-content" id="eclipseFromTokenDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #111; border: 1px solid #333; border-top: none; border-radius: 0 0 3px 3px; max-height: 200px; overflow-y: auto; z-index: 1000;">`;
                    tokens.forEach(token => {
                        const sourceIcon = token.source === 'Solar' ? '🔵' : token.source === 'Deserialize' ? '🟠' : '🟢';
                        html += `<div class="dropdown-item" data-value="${token.address}" data-symbol="${token.symbol}" data-decimals="${token.decimals}" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">`;
                        html += `${sourceIcon} ${token.name}`;
                        html += `</div>`;
                    });
                    html += `</div>`;
                    html += `<input type="hidden" id="eclipseFromToken" value="${defaultFromToken?.address || ''}">`;
                    html += `</div>`;
                    html += `</div>`;
                    
                    // To token selection with custom dropdown
                    html += `<div style="margin-bottom: 15px;">`;
                    html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">To Token:</label>`;
                    html += `<div class="custom-dropdown" style="position: relative; width: 100%;">`;
                    html += `<div class="dropdown-header" id="eclipseToTokenHeader" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; cursor: pointer;">`;
                    html += `<span id="eclipseToTokenDisplay">🔵 ${defaultToToken?.name || 'SOLAR STUDIOS'}</span>`;
                    html += `<span style="color: #666;">▼</span>`;
                    html += `</div>`;
                    html += `<div class="dropdown-content" id="eclipseToTokenDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #111; border: 1px solid #333; border-top: none; border-radius: 0 0 3px 3px; max-height: 200px; overflow-y: auto; z-index: 1000;">`;
                    tokens.forEach(token => {
                        const sourceIcon = token.source === 'Solar' ? '🔵' : token.source === 'Deserialize' ? '🟠' : '🟢';
                        html += `<div class="dropdown-item" data-value="${token.address}" data-symbol="${token.symbol}" data-decimals="${token.decimals}" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">`;
                        html += `${sourceIcon} ${token.name}`;
                        html += `</div>`;
                    });
                    html += `</div>`;
                    html += `<input type="hidden" id="eclipseToToken" value="${defaultToToken?.address || ''}">`;
                    html += `</div>`;
                    html += `</div>`;
                    
                    // Amount input
                    html += `<div style="margin-bottom: 15px;">`;
                    html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">Amount:</label>`;
                    html += `<input type="number" id="eclipseAmount" placeholder="Enter amount" step="0.000001" style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; box-sizing: border-box;">`;
                    html += `</div>`;
                    
                    // Slippage selection with custom dropdown
                    html += `<div style="margin-bottom: 15px;">`;
                    html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">Slippage:</label>`;
                    html += `<div class="custom-dropdown" style="position: relative; width: 100%;">`;
                    html += `<div class="dropdown-header" id="eclipseSlippageHeader" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; cursor: pointer;">`;
                    html += `<span id="eclipseSlippageDisplay">1.0% (Standard)</span>`;
                    html += `<span style="color: #666;">▼</span>`;
                    html += `</div>`;
                    html += `<div class="dropdown-content" id="eclipseSlippageDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #111; border: 1px solid #333; border-top: none; border-radius: 0 0 3px 3px; max-height: 200px; overflow-y: auto; z-index: 1000;">`;
                    html += `<div class="dropdown-item" data-value="50" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">0.5% (Conservative)</div>`;
                    html += `<div class="dropdown-item" data-value="100" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">1.0% (Standard)</div>`;
                    html += `<div class="dropdown-item" data-value="200" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">2.0% (Aggressive)</div>`;
                    html += `<div class="dropdown-item" data-value="500" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">5.0% (High Risk)</div>`;
                    html += `</div>`;
                    html += `<input type="hidden" id="eclipseSlippage" value="100">`;
                    html += `</div>`;
                    html += `</div>`;
                    
                    // Quote display section
                    html += `<div id="eclipseQuoteDisplay" style="margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.05); border: 1px solid #333; border-radius: 3px; display: none;">`;
                    html += `<div style="font-size: 12px; color: #999; margin-bottom: 5px;">Estimated Output:</div>`;
                    html += `<div id="eclipseQuoteAmount" style="font-size: 16px; color: #fff; font-weight: bold;"></div>`;
                    html += `<div id="eclipseQuotePrice" style="font-size: 12px; color: #999; margin-top: 3px;"></div>`;
                    html += `</div>`;
                    
                    // Swap button
                    html += `<button id="eclipseSwapBtn" style="width: 100%; padding: 12px; background: linear-gradient(45deg, #00bcf2, #0099cc); color: white; border: none; border-radius: 5px; font-size: 16px; font-weight: bold; cursor: pointer; margin-bottom: 10px;">🔄 Execute Swap</button>`;
                    
                    // Info section
                    html += `<div style="font-size: 12px; color: #999; line-height: 1.4;">`;
                    html += `<p><strong>Smart Routing:</strong> Automatically uses Solar DEX for SOLAR token, Deserialize Aggregator for others.</p>`;
                    html += `<p><strong>Icons:</strong> 🔵 Solar DEX | 🟠 Deserialize | 🟢 Both DEXes</p>`;
                    html += `</div>`;
                    
                    html += `</div>`;
                    
                    this.logHtml(html, 'output');
                    
                    // Add event listeners for custom dropdowns
                    setTimeout(() => {
                        this.setupEclipseDropdowns();
                        const swapBtn = document.getElementById('eclipseSwapBtn');
                        if (swapBtn) {
                            swapBtn.addEventListener('click', () => this.executeEclipseSwapFromInterface());
                        }
                        
                        // Fix amount input event handling and add quote functionality
                        const amountInput = document.getElementById('eclipseAmount');
                        if (amountInput) {
                            amountInput.addEventListener('click', (e) => e.stopPropagation());
                            amountInput.addEventListener('focus', (e) => e.stopPropagation());
                            amountInput.addEventListener('input', (e) => {
                                e.stopPropagation();
                                this.updateEclipseQuote();
                            });
                        }
                        
                        // Add quote update on token changes
                        const fromToken = document.getElementById('eclipseFromToken');
                        const toToken = document.getElementById('eclipseToToken');
                        const slippage = document.getElementById('eclipseSlippage');
                        if (fromToken) fromToken.addEventListener('change', () => this.updateEclipseQuote());
                        if (toToken) toToken.addEventListener('change', () => this.updateEclipseQuote());
                        if (slippage) slippage.addEventListener('change', () => this.updateEclipseQuote());
                    }, 100);
                    
                } catch (e) {
                    this.log(`Failed to load swap interface: ${e.message}`, 'error');
                }
            }
            
            setupEclipseDropdowns() {
                // Close all dropdowns when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.custom-dropdown')) {
                        document.querySelectorAll('.dropdown-content').forEach(dropdown => {
                            dropdown.style.display = 'none';
                        });
                    }
                });
                
                // From token dropdown
                const fromHeader = document.getElementById('eclipseFromTokenHeader');
                const fromDropdown = document.getElementById('eclipseFromTokenDropdown');
                const fromHidden = document.getElementById('eclipseFromToken');
                const fromDisplay = document.getElementById('eclipseFromTokenDisplay');
                
                if (fromHeader && fromDropdown) {
                    fromHeader.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isOpen = fromDropdown.style.display === 'block';
                        // Close all other dropdowns
                        document.querySelectorAll('.dropdown-content').forEach(dropdown => {
                            if (dropdown !== fromDropdown) {
                                dropdown.style.display = 'none';
                            }
                        });
                        fromDropdown.style.display = isOpen ? 'none' : 'block';
                    });
                    
                    // Handle item selection
                    fromDropdown.addEventListener('click', (e) => {
                        if (e.target.classList.contains('dropdown-item')) {
                            const value = e.target.getAttribute('data-value');
                            const symbol = e.target.getAttribute('data-symbol');
                            const text = e.target.textContent.trim();
                            
                            fromHidden.value = value;
                            fromDisplay.textContent = text;
                            fromDropdown.style.display = 'none';
                            
                            // Update quote when token changes
                            this.updateEclipseQuote();
                        }
                    });
                }
                
                // To token dropdown
                const toHeader = document.getElementById('eclipseToTokenHeader');
                const toDropdown = document.getElementById('eclipseToTokenDropdown');
                const toHidden = document.getElementById('eclipseToToken');
                const toDisplay = document.getElementById('eclipseToTokenDisplay');
                
                if (toHeader && toDropdown) {
                    toHeader.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isOpen = toDropdown.style.display === 'block';
                        // Close all other dropdowns
                        document.querySelectorAll('.dropdown-content').forEach(dropdown => {
                            if (dropdown !== toDropdown) {
                                dropdown.style.display = 'none';
                            }
                        });
                        toDropdown.style.display = isOpen ? 'none' : 'block';
                    });
                    
                    // Handle item selection
                    toDropdown.addEventListener('click', (e) => {
                        if (e.target.classList.contains('dropdown-item')) {
                            const value = e.target.getAttribute('data-value');
                            const symbol = e.target.getAttribute('data-symbol');
                            const text = e.target.textContent.trim();
                            
                            toHidden.value = value;
                            toDisplay.textContent = text;
                            toDropdown.style.display = 'none';
                            
                            // Update quote when token changes
                            this.updateEclipseQuote();
                        }
                    });
                }
                
                // Slippage dropdown
                const slippageHeader = document.getElementById('eclipseSlippageHeader');
                const slippageDropdown = document.getElementById('eclipseSlippageDropdown');
                const slippageHidden = document.getElementById('eclipseSlippage');
                const slippageDisplay = document.getElementById('eclipseSlippageDisplay');
                
                if (slippageHeader && slippageDropdown) {
                    slippageHeader.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isOpen = slippageDropdown.style.display === 'block';
                        // Close all other dropdowns
                        document.querySelectorAll('.dropdown-content').forEach(dropdown => {
                            if (dropdown !== slippageDropdown) {
                                dropdown.style.display = 'none';
                            }
                        });
                        slippageDropdown.style.display = isOpen ? 'none' : 'block';
                    });
                    
                    // Handle item selection
                    slippageDropdown.addEventListener('click', (e) => {
                        if (e.target.classList.contains('dropdown-item')) {
                            const value = e.target.getAttribute('data-value');
                            const text = e.target.textContent.trim();
                            
                            slippageHidden.value = value;
                            slippageDisplay.textContent = text;
                            slippageDropdown.style.display = 'none';
                        }
                    });
                }
                        }

            async updateEclipseQuote() {
                const fromToken = document.getElementById('eclipseFromToken');
                const toToken = document.getElementById('eclipseToToken');
                const amountInput = document.getElementById('eclipseAmount');
                const slippage = document.getElementById('eclipseSlippage');
                const quoteDisplay = document.getElementById('eclipseQuoteDisplay');
                const quoteAmount = document.getElementById('eclipseQuoteAmount');
                const quotePrice = document.getElementById('eclipseQuotePrice');
                
                if (!fromToken || !toToken || !amountInput || !slippage || !quoteDisplay || !quoteAmount || !quotePrice) {
                    return;
                }
                
                const fromMint = fromToken.value;
                const toMint = toToken.value;
                const amount = parseFloat(amountInput.value);
                const slippageBps = parseInt(slippage.value);
                
                if (!fromMint || !toMint || isNaN(amount) || amount <= 0 || isNaN(slippageBps)) {
                    quoteDisplay.style.display = 'none';
                    return;
                }
                
                try {
                    // Smart routing logic - same as swap execution
                    const solarTokenAddress = 'CwrZKtPiZJrAK3tTjNPP22rD9VzeoxQv8iHd6EeyNoze';
                    const useSolarDex = fromMint === solarTokenAddress || toMint === solarTokenAddress;
                    
                    let quoteData;
                    if (useSolarDex) {
                        // Get Solar DEX quote
                        const res = await fetch(`${RELAYER_URL}/solar/quote`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                inputMint: fromMint,
                                outputMint: toMint,
                                amount: amount.toString(),
                                slippageBps: slippageBps
                            })
                        });
                        quoteData = await res.json();
                    } else {
                        // Get Deserialize quote
                        const res = await fetch(`${RELAYER_URL}/deserialize/quote`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                inputMint: fromMint,
                                outputMint: toMint,
                                amount: amount.toString(),
                                slippageBps: slippageBps
                            })
                        });
                        quoteData = await res.json();
                    }
                    
                    if (quoteData && quoteData.outAmount) {
                        // Get token symbols for display
                        const fromTokenElement = document.querySelector('#eclipseFromTokenDropdown .dropdown-item[data-value="' + fromMint + '"]');
                        const toTokenElement = document.querySelector('#eclipseToTokenDropdown .dropdown-item[data-value="' + toMint + '"]');
                        const fromSymbol = fromTokenElement ? fromTokenElement.getAttribute('data-symbol') : 'Unknown';
                        const toSymbol = toTokenElement ? toTokenElement.getAttribute('data-symbol') : 'Unknown';
                        
                        // Convert output amount to human readable
                        const outputAmount = parseFloat(quoteData.outAmount).toFixed(6);
                        quoteAmount.textContent = `${outputAmount} ${toSymbol}`;
                        
                        // Show price impact if available
                        if (quoteData.priceImpact) {
                            const priceImpact = parseFloat(quoteData.priceImpact);
                            if (priceImpact > 0.1) {
                                quotePrice.textContent = `Price Impact: ${priceImpact.toFixed(2)}%`;
                                quotePrice.style.color = '#ff6b6b';
                            } else {
                                quotePrice.textContent = `Price Impact: ${priceImpact.toFixed(2)}%`;
                                quotePrice.style.color = '#51cf66';
                            }
                        } else {
                            quotePrice.textContent = '';
                        }
                        
                        quoteDisplay.style.display = 'block';
                    } else {
                        quoteDisplay.style.display = 'none';
                    }
                } catch (e) {
                    quoteDisplay.style.display = 'none';
                }
            }

            async executeEclipseSwapFromInterface() {
                const fromToken = document.getElementById('eclipseFromToken');
                const toToken = document.getElementById('eclipseToToken');
                const amount = document.getElementById('eclipseAmount');
                const slippage = document.getElementById('eclipseSlippage');
                
                if (!fromToken || !toToken || !amount || !slippage) {
                    this.log('Swap interface not found. Please try again.', 'error');
                    return;
                }
                
                const inputMint = fromToken.value;
                const outputMint = toToken.value;
                const amountValue = parseFloat(amount.value);
                const slippageBps = parseInt(slippage.value);
                
                if (!inputMint || !outputMint || isNaN(amountValue) || isNaN(slippageBps)) {
                    this.log('Please fill in all fields with valid values.', 'error');
                    return;
                }
                
                if (inputMint === outputMint) {
                    this.log('Cannot swap the same token.', 'error');
                    return;
                }
                
                if (amountValue <= 0) {
                    this.log('Amount must be greater than 0.', 'error');
                    return;
                }
                
                // Smart routing logic
                const solarTokenAddress = 'CwrZKtPiZJrAK3tTjNPP22rD9VzeoxQv8iHd6EeyNoze';
                const useSolarDex = inputMint === solarTokenAddress || outputMint === solarTokenAddress;
                const dexName = useSolarDex ? 'Solar DEX' : 'Deserialize Aggregator';
                
                // Get symbols from the hidden inputs' data attributes
                const fromTokenElement = document.querySelector('#eclipseFromTokenDropdown .dropdown-item[data-value="' + inputMint + '"]');
                const toTokenElement = document.querySelector('#eclipseToTokenDropdown .dropdown-item[data-value="' + outputMint + '"]');
                const fromSymbol = fromTokenElement ? fromTokenElement.getAttribute('data-symbol') : 'Unknown';
                const toSymbol = toTokenElement ? toTokenElement.getAttribute('data-symbol') : 'Unknown';
                
                this.log(`Starting Eclipse swap: ${amountValue} ${fromSymbol} → ${toSymbol}`, 'info');
                this.log(`Using: ${dexName}`, 'info');
                this.log(`Slippage: ${slippageBps/100}%`, 'info');
                
                try {
                    if (useSolarDex) {
                        await this.executeSolarSwap(inputMint, outputMint, amountValue, slippageBps);
                    } else {
                        await this.executeDeserializeSwap(inputMint, outputMint, amountValue, slippageBps);
                    }
                } catch (e) {
                    this.log(`Eclipse swap failed: ${e.message}`, 'error');
                }
            }
            
            async showNearSwapInterface() {
                this.log('🔄 Near Intents Swap Interface', 'info');
                this.log('Loading available tokens...', 'info');
                
                try {
                    // Fetch tokens from Near Intents API
                    const response = await fetch('https://1click.chaindefuser.com/v0/tokens');
                    if (!response.ok) {
                        this.log(`Failed to fetch tokens: HTTP ${response.status}`, 'error');
                        return;
                    }
                    
                    const tokens = await response.json();
                    const sortedTokens = tokens.sort((a, b) => a.symbol.localeCompare(b.symbol));
                    
                    // Debug: Show what tokens were loaded
                    this.log(`Loaded ${tokens.length} tokens for swap interface:`, 'info');
                    tokens.slice(0, 10).forEach(token => {
                        this.log(`- ${token.symbol} (${token.blockchain}): ${token.assetId}`, 'info');
                    });
                    if (tokens.length > 10) {
                        this.log(`... and ${tokens.length - 10} more tokens`, 'info');
                    }
                    
                    // Create swap interface with custom dropdowns
                    let html = `<div style="background: rgba(255,255,255,0.05); border: 1px solid #ffffff; padding: 15px; border-radius: 5px; margin: 10px 0;">`;
                    html += `<h3 style="margin: 0 0 15px 0; color: #ffffff;">🔄 Near Intents Cross-Chain Swap</h3>`;
                    
                    // From token selection with custom dropdown
                    html += `<div style="margin-bottom: 15px;">`;
                    html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">From Token:</label>`;
                    html += `<div class="custom-dropdown" style="position: relative; width: 100%;">`;
                    html += `<div class="dropdown-header" id="nearFromTokenHeader" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; cursor: pointer;">`;
                    html += `<span id="nearFromTokenDisplay">🔵 wNEAR (NEAR)</span>`;
                    html += `<span style="color: #666;">▼</span>`;
                    html += `</div>`;
                    html += `<div class="dropdown-content" id="nearFromTokenDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #111; border: 1px solid #333; border-top: none; border-radius: 0 0 3px 3px; max-height: 200px; overflow-y: auto; z-index: 1000;">`;
                    sortedTokens.forEach(token => {
                        const blockchainIcon = token.blockchain === 'near' ? '🔵' : token.blockchain === 'solana' ? '🟣' : token.blockchain === 'ethereum' ? '🔶' : '⚪';
                        html += `<div class="dropdown-item" data-value="${token.assetId}" data-symbol="${token.symbol}" data-blockchain="${token.blockchain}" data-decimals="${token.decimals}" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">`;
                        html += `${blockchainIcon} ${token.symbol} (${token.blockchain.toUpperCase()})`;
                        html += `</div>`;
                    });
                    html += `</div>`;
                    html += `<input type="hidden" id="nearFromToken" value="${sortedTokens[0]?.assetId || ''}">`;
                    html += `</div>`;
                    html += `</div>`;
                    
                    // To token selection with custom dropdown
                    html += `<div style="margin-bottom: 15px;">`;
                    html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">To Token:</label>`;
                    html += `<div class="custom-dropdown" style="position: relative; width: 100%;">`;
                    html += `<div class="dropdown-header" id="nearToTokenHeader" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; cursor: pointer;">`;
                    html += `<span id="nearToTokenDisplay">🟣 SOL (Solana)</span>`;
                    html += `<span style="color: #666;">▼</span>`;
                    html += `</div>`;
                    html += `<div class="dropdown-content" id="nearToTokenDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #111; border: 1px solid #333; border-top: none; border-radius: 0 0 3px 3px; max-height: 200px; overflow-y: auto; z-index: 1000;">`;
                    sortedTokens.forEach(token => {
                        const blockchainIcon = token.blockchain === 'near' ? '🔵' : token.blockchain === 'solana' ? '🟣' : token.blockchain === 'ethereum' ? '🔶' : '⚪';
                        html += `<div class="dropdown-item" data-value="${token.assetId}" data-symbol="${token.symbol}" data-blockchain="${token.blockchain}" data-decimals="${token.decimals}" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">`;
                        html += `${blockchainIcon} ${token.symbol} (${token.blockchain.toUpperCase()})`;
                        html += `</div>`;
                    });
                    html += `</div>`;
                    html += `<input type="hidden" id="nearToToken" value="${sortedTokens.find(t => t.blockchain === 'solana')?.assetId || sortedTokens[1]?.assetId || ''}">`;
                    html += `</div>`;
                    html += `</div>`;
                    
                    // Amount input
                    html += `<div style="margin-bottom: 15px;">`;
                    html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">Amount:</label>`;
                    html += `<input type="number" id="nearAmount" placeholder="Enter amount" step="0.000001" style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; box-sizing: border-box;">`;
                    html += `</div>`;
                    
                    // Recipient input
                    html += `<div style="margin-bottom: 15px;">`;
                    html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">Recipient Address:</label>`;
                    html += `<input type="text" id="nearRecipient" placeholder="account.near for NEAR, 0x... for EVM, or Solana address" style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; box-sizing: border-box;">`;
                    html += `</div>`;
                    
                    // Slippage selection with custom dropdown
                    html += `<div style="margin-bottom: 15px;">`;
                    html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">Slippage:</label>`;
                    html += `<div class="custom-dropdown" style="position: relative; width: 100%;">`;
                    html += `<div class="dropdown-header" id="nearSlippageHeader" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; cursor: pointer;">`;
                    html += `<span id="nearSlippageDisplay">1.0% (Standard)</span>`;
                    html += `<span style="color: #666;">▼</span>`;
                    html += `</div>`;
                    html += `<div class="dropdown-content" id="nearSlippageDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #111; border: 1px solid #333; border-top: none; border-radius: 0 0 3px 3px; max-height: 200px; overflow-y: auto; z-index: 1000;">`;
                    html += `<div class="dropdown-item" data-value="50" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">0.5% (Conservative)</div>`;
                    html += `<div class="dropdown-item" data-value="100" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">1.0% (Standard)</div>`;
                    html += `<div class="dropdown-item" data-value="200" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">2.0% (Aggressive)</div>`;
                    html += `<div class="dropdown-item" data-value="500" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">5.0% (High Risk)</div>`;
                    html += `</div>`;
                    html += `<input type="hidden" id="nearSlippage" value="100">`;
                    html += `</div>`;
                    html += `</div>`;
                    
                    // Swap button
                    html += `<button id="nearSwapBtn" style="width: 100%; padding: 12px; background: linear-gradient(45deg, #00bcf2, #0099cc); color: white; border: none; border-radius: 5px; font-size: 16px; font-weight: bold; cursor: pointer; margin-bottom: 10px;">🔄 Execute Cross-Chain Swap</button>`;
                    
                    // Info section
                    html += `<div style="font-size: 12px; color: #999; line-height: 1.4;">`;
                    html += `<p><strong>Cross-Chain Swaps:</strong> Swap tokens across different blockchains using NEAR Intents.</p>`;
                    html += `<p><strong>Icons:</strong> 🔵 NEAR | 🟣 Solana | 🔶 Ethereum | ⚪ Other</p>`;
                    html += `<p><strong>Note:</strong> You'll need to manually send tokens to the deposit address provided.</p>`;
                    html += `</div>`;
                    
                    html += `</div>`;
                    
                    this.logHtml(html, 'output');
                    
                    // Add event listeners for custom dropdowns
                    setTimeout(() => {
                        this.setupNearDropdowns();
                        const swapBtn = document.getElementById('nearSwapBtn');
                        if (swapBtn) {
                            swapBtn.addEventListener('click', () => this.executeNearSwapFromInterface());
                        }
                        
                        // Fix input event handling
                        const amountInput = document.getElementById('nearAmount');
                        const recipientInput = document.getElementById('nearRecipient');
                        if (amountInput) {
                            amountInput.addEventListener('click', (e) => e.stopPropagation());
                            amountInput.addEventListener('focus', (e) => e.stopPropagation());
                            amountInput.addEventListener('input', (e) => e.stopPropagation());
                        }
                        if (recipientInput) {
                            recipientInput.addEventListener('click', (e) => e.stopPropagation());
                            recipientInput.addEventListener('focus', (e) => e.stopPropagation());
                            recipientInput.addEventListener('input', (e) => e.stopPropagation());
                        }
                    }, 100);
                    
                } catch (e) {
                    this.log(`Failed to load Near Intents swap interface: ${e.message}`, 'error');
                }
            }
            
            setupSolanaDropdowns() {
                // Close all dropdowns when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.custom-dropdown')) {
                        document.querySelectorAll('.dropdown-content').forEach(dropdown => {
                            dropdown.style.display = 'none';
                        });
                    }
                });
                
                // From token dropdown
                const fromHeader = document.getElementById('solanaFromTokenHeader');
                const fromDropdown = document.getElementById('solanaFromTokenDropdown');
                const fromHidden = document.getElementById('solanaFromToken');
                const fromDisplay = document.getElementById('solanaFromTokenDisplay');
                const fromSearch = document.getElementById('solanaFromSearch');
                const fromTokenList = document.getElementById('solanaFromTokenList');
                
                if (fromHeader && fromDropdown) {
                    fromHeader.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isOpen = fromDropdown.style.display === 'block';
                        // Close all other dropdowns
                        document.querySelectorAll('.dropdown-content').forEach(dropdown => {
                            if (dropdown !== fromDropdown) {
                                dropdown.style.display = 'none';
                            }
                        });
                        fromDropdown.style.display = isOpen ? 'none' : 'block';
                        if (!isOpen && fromSearch) {
                            fromSearch.focus();
                        }
                    });
                    
                                            // Handle search input
                        if (fromSearch) {
                            fromSearch.addEventListener('input', async (e) => {
                                e.stopPropagation();
                                const query = e.target.value.trim();
                                if (query.length >= 2) {
                                    fromTokenList.innerHTML = '<div style="padding: 8px; color: #666;">Searching...</div>';
                                    try {
                                        const res = await fetch(`${RELAYER_URL}/jupiter/search?q=${encodeURIComponent(query)}`);
                                        const data = await res.json();
                                        if (Array.isArray(data) && data.length > 0) {
                                        let html = '';
                                        data.slice(0, 10).forEach(token => {
                                            const icon = token.symbol === 'SOL' ? '🟣' : '💎';
                                            html += `<div class="dropdown-item" data-value="${token.address || token.id}" data-symbol="${token.symbol}" data-name="${token.name}" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">`;
                                            html += `${icon} ${token.symbol} (${token.name})`;
                                            html += `</div>`;
                                        });
                                        fromTokenList.innerHTML = html;
                                    } else {
                                        fromTokenList.innerHTML = '<div style="padding: 8px; color: #666;">No tokens found</div>';
                                    }
                                } catch (err) {
                                    fromTokenList.innerHTML = '<div style="padding: 8px; color: #666;">Search failed</div>';
                                }
                            } else if (query.length === 0) {
                                // Reset to default tokens
                                fromTokenList.innerHTML = `
                                    <div class="dropdown-item" data-value="So11111111111111111111111111111111111111112" data-symbol="SOL" data-name="Solana" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">🟣 SOL (Solana)</div>
                                    <div class="dropdown-item" data-value="EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" data-symbol="USDC" data-name="USD Coin" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">💙 USDC (USD Coin)</div>
                                    <div class="dropdown-item" data-value="Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB" data-symbol="USDT" data-name="Tether USD" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">💚 USDT (Tether USD)</div>
                                    <div class="dropdown-item" data-value="DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263" data-symbol="BONK" data-name="Bonk" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">🐕 BONK (Bonk)</div>
                                `;
                            }
                        });
                        
                        fromSearch.addEventListener('click', (e) => e.stopPropagation());
                        fromSearch.addEventListener('focus', (e) => e.stopPropagation());
                    }
                    
                    // Handle item selection
                    fromTokenList.addEventListener('click', (e) => {
                        if (e.target.classList.contains('dropdown-item')) {
                            const value = e.target.getAttribute('data-value');
                            const symbol = e.target.getAttribute('data-symbol');
                            const name = e.target.getAttribute('data-name');
                            const text = e.target.textContent.trim();
                            
                            fromHidden.value = value;
                            fromDisplay.textContent = text;
                            fromDropdown.style.display = 'none';
                            if (fromSearch) fromSearch.value = '';
                            
                            // Update quote when token changes
                            this.updateSolanaQuote();
                        }
                    });
                }
                
                // To token dropdown
                const toHeader = document.getElementById('solanaToTokenHeader');
                const toDropdown = document.getElementById('solanaToTokenDropdown');
                const toHidden = document.getElementById('solanaToToken');
                const toDisplay = document.getElementById('solanaToTokenDisplay');
                const toSearch = document.getElementById('solanaToSearch');
                const toTokenList = document.getElementById('solanaToTokenList');
                
                if (toHeader && toDropdown) {
                    toHeader.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isOpen = toDropdown.style.display === 'block';
                        // Close all other dropdowns
                        document.querySelectorAll('.dropdown-content').forEach(dropdown => {
                            if (dropdown !== toDropdown) {
                                dropdown.style.display = 'none';
                            }
                        });
                        toDropdown.style.display = isOpen ? 'none' : 'block';
                        if (!isOpen && toSearch) {
                            toSearch.focus();
                        }
                    });
                    
                                            // Handle search input
                        if (toSearch) {
                            toSearch.addEventListener('input', async (e) => {
                                e.stopPropagation();
                                const query = e.target.value.trim();
                                if (query.length >= 2) {
                                    toTokenList.innerHTML = '<div style="padding: 8px; color: #666;">Searching...</div>';
                                    try {
                                        const res = await fetch(`${RELAYER_URL}/jupiter/search?q=${encodeURIComponent(query)}`);
                                        const data = await res.json();
                                        if (Array.isArray(data) && data.length > 0) {
                                        let html = '';
                                        data.slice(0, 10).forEach(token => {
                                            const icon = token.symbol === 'SOL' ? '🟣' : '💎';
                                            html += `<div class="dropdown-item" data-value="${token.address || token.id}" data-symbol="${token.symbol}" data-name="${token.name}" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">`;
                                            html += `${icon} ${token.symbol} (${token.name})`;
                                            html += `</div>`;
                                        });
                                        toTokenList.innerHTML = html;
                                    } else {
                                        toTokenList.innerHTML = '<div style="padding: 8px; color: #666;">No tokens found</div>';
                                    }
                                } catch (err) {
                                    toTokenList.innerHTML = '<div style="padding: 8px; color: #666;">Search failed</div>';
                                }
                            } else if (query.length === 0) {
                                // Reset to default tokens
                                toTokenList.innerHTML = `
                                    <div class="dropdown-item" data-value="So11111111111111111111111111111111111111112" data-symbol="SOL" data-name="Solana" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">🟣 SOL (Solana)</div>
                                    <div class="dropdown-item" data-value="EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" data-symbol="USDC" data-name="USD Coin" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">💙 USDC (USD Coin)</div>
                                    <div class="dropdown-item" data-value="Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB" data-symbol="USDT" data-name="Tether USD" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">💚 USDT (Tether USD)</div>
                                    <div class="dropdown-item" data-value="DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263" data-symbol="BONK" data-name="Bonk" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">🐕 BONK (Bonk)</div>
                                `;
                            }
                        });
                        
                        toSearch.addEventListener('click', (e) => e.stopPropagation());
                        toSearch.addEventListener('focus', (e) => e.stopPropagation());
                    }
                    
                    // Handle item selection
                    toTokenList.addEventListener('click', (e) => {
                        if (e.target.classList.contains('dropdown-item')) {
                            const value = e.target.getAttribute('data-value');
                            const symbol = e.target.getAttribute('data-symbol');
                            const name = e.target.getAttribute('data-name');
                            const text = e.target.textContent.trim();
                            
                            toHidden.value = value;
                            toDisplay.textContent = text;
                            toDropdown.style.display = 'none';
                            if (toSearch) toSearch.value = '';
                            
                            // Update quote when token changes
                            this.updateSolanaQuote();
                        }
                    });
                }
            }

            async executeSolanaSwapFromInterface() {
                if (!this.solanaAddress) {
                    this.log('Please connect your Phantom wallet first using: solana connect', 'error');
                    return;
                }
                
                const fromMint = document.getElementById('solanaFromToken')?.value;
                const toMint = document.getElementById('solanaToToken')?.value;
                const amount = document.getElementById('solanaAmount')?.value;
                
                if (!fromMint || !toMint || !amount) {
                    this.log('Please fill in all fields: From Token, To Token, and Amount', 'error');
                    return;
                }
                
                if (fromMint === toMint) {
                    this.log('From and To tokens cannot be the same', 'error');
                    return;
                }
                
                // Convert amount to lamports (raw amount)
                let amountLamports;
                if (fromMint === 'So11111111111111111111111111111111111111112') {
                    // SOL: 1 SOL = 1,000,000,000 lamports
                    amountLamports = Math.floor(parseFloat(amount) * 1000000000).toString();
                } else {
                    // For other tokens, we need to get their decimals
                    // For now, assume 6 decimals (like USDC)
                    amountLamports = Math.floor(parseFloat(amount) * 1000000).toString();
                }
                
                this.log(`Executing swap: ${amount} SOL (${amountLamports} lamports) from ${fromMint} to ${toMint}`, 'info');
                await this.executeSolanaSwap(amountLamports, fromMint, toMint);
            }

            setupNearDropdowns() {
                // Close all dropdowns when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.custom-dropdown')) {
                        document.querySelectorAll('.dropdown-content').forEach(dropdown => {
                            dropdown.style.display = 'none';
                        });
                    }
                });
                
                // From token dropdown
                const fromHeader = document.getElementById('nearFromTokenHeader');
                const fromDropdown = document.getElementById('nearFromTokenDropdown');
                const fromHidden = document.getElementById('nearFromToken');
                const fromDisplay = document.getElementById('nearFromTokenDisplay');
                
                if (fromHeader && fromDropdown) {
                    fromHeader.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isOpen = fromDropdown.style.display === 'block';
                        // Close all other dropdowns
                        document.querySelectorAll('.dropdown-content').forEach(dropdown => {
                            if (dropdown !== fromDropdown) {
                                dropdown.style.display = 'none';
                            }
                        });
                        fromDropdown.style.display = isOpen ? 'none' : 'block';
                    });
                    
                    // Handle item selection
                    fromDropdown.addEventListener('click', (e) => {
                        if (e.target.classList.contains('dropdown-item')) {
                            const value = e.target.getAttribute('data-value');
                            const text = e.target.textContent.trim();
                            
                            fromHidden.value = value;
                            fromDisplay.textContent = text;
                            fromDropdown.style.display = 'none';
                        }
                    });
                }
                
                // To token dropdown
                const toHeader = document.getElementById('nearToTokenHeader');
                const toDropdown = document.getElementById('nearToTokenDropdown');
                const toHidden = document.getElementById('nearToToken');
                const toDisplay = document.getElementById('nearToTokenDisplay');
                
                if (toHeader && toDropdown) {
                    toHeader.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isOpen = toDropdown.style.display === 'block';
                        // Close all other dropdowns
                        document.querySelectorAll('.dropdown-content').forEach(dropdown => {
                            if (dropdown !== toDropdown) {
                                dropdown.style.display = 'none';
                            }
                        });
                        toDropdown.style.display = isOpen ? 'none' : 'block';
                    });
                    
                    // Handle item selection
                    toDropdown.addEventListener('click', (e) => {
                        if (e.target.classList.contains('dropdown-item')) {
                            const value = e.target.getAttribute('data-value');
                            const text = e.target.textContent.trim();
                            
                            toHidden.value = value;
                            toDisplay.textContent = text;
                            toDropdown.style.display = 'none';
                        }
                    });
                }
                
                // Slippage dropdown
                const slippageHeader = document.getElementById('nearSlippageHeader');
                const slippageDropdown = document.getElementById('nearSlippageDropdown');
                const slippageHidden = document.getElementById('nearSlippage');
                const slippageDisplay = document.getElementById('nearSlippageDisplay');
                
                if (slippageHeader && slippageDropdown) {
                    slippageHeader.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isOpen = slippageDropdown.style.display === 'block';
                        // Close all other dropdowns
                        document.querySelectorAll('.dropdown-content').forEach(dropdown => {
                            if (dropdown !== slippageDropdown) {
                                dropdown.style.display = 'none';
                            }
                        });
                        slippageDropdown.style.display = isOpen ? 'none' : 'block';
                    });
                    
                    // Handle item selection
                    slippageDropdown.addEventListener('click', (e) => {
                        if (e.target.classList.contains('dropdown-item')) {
                            const value = e.target.getAttribute('data-value');
                            const text = e.target.textContent.trim();
                            
                            slippageHidden.value = value;
                            slippageDisplay.textContent = text;
                            slippageDropdown.style.display = 'none';
                        }
                    });
                }
            }
            
            // Helper functions for Near Intents address validation
            getOriginChainFromAsset(asset) {
                // Check for explicit chain prefixes first
                if (asset.includes('nep141:')) return 'NEAR';
                if (asset.includes('sol:')) return 'Solana';
                if (asset.includes('eth:')) return 'Ethereum';
                if (asset.includes('polygon:')) return 'Polygon';
                if (asset.includes('arbitrum:')) return 'Arbitrum';
                
                // Check for specific token patterns
                if (asset.includes('wrap.near') || asset.includes('NEAR (NEAR)')) return 'NEAR';
                if (asset.includes('SOL (Solana)') || asset.includes('sol-')) return 'Solana';
                if (asset.includes('(ETH)') || asset.includes('(Ethereum)')) return 'Ethereum';
                if (asset.includes('(Polygon)')) return 'Polygon';
                if (asset.includes('(Arbitrum)')) return 'Arbitrum';
                
                // Default to Ethereum for most tokens
                return 'Ethereum';
            }
            
            getDestinationChainFromAsset(asset) {
                // Check for explicit chain prefixes first
                if (asset.includes('nep141:')) return 'NEAR';
                if (asset.includes('sol:')) return 'Solana';
                if (asset.includes('eth:')) return 'Ethereum';
                if (asset.includes('polygon:')) return 'Polygon';
                if (asset.includes('arbitrum:')) return 'Arbitrum';
                
                // Check for specific token patterns
                if (asset.includes('wrap.near') || asset.includes('NEAR (NEAR)')) return 'NEAR';
                if (asset.includes('SOL (Solana)') || asset.includes('sol-')) return 'Solana';
                if (asset.includes('(ETH)') || asset.includes('(Ethereum)')) return 'Ethereum';
                if (asset.includes('(Polygon)')) return 'Polygon';
                if (asset.includes('(Arbitrum)')) return 'Arbitrum';
                
                // Default to Ethereum for most tokens
                return 'Ethereum';
            }
            
            async executeNearSwapFromInterface() {
                const fromToken = document.getElementById('nearFromToken');
                const toToken = document.getElementById('nearToToken');
                const amount = document.getElementById('nearAmount');
                const recipient = document.getElementById('nearRecipient');
                const slippage = document.getElementById('nearSlippage');
                
                if (!fromToken || !toToken || !amount || !recipient || !slippage) {
                    this.log('Swap interface not found. Please try again.', 'error');
                    return;
                }
                
                const originAsset = fromToken.value;
                const destinationAsset = toToken.value;
                const amountValue = parseFloat(amount.value);
                const recipientAddress = recipient.value.trim();
                const slippageBps = parseInt(slippage.value);
                
                if (!originAsset || !destinationAsset || isNaN(amountValue) || !recipientAddress || isNaN(slippageBps)) {
                    this.log('Please fill in all fields with valid values.', 'error');
                    return;
                }
                
                // Validate and format recipient address based on destination chain
                let formattedRecipient = recipientAddress;
                let refundAddress = recipientAddress;
                
                // Determine destination chain from asset
                const destinationChain = this.getDestinationChainFromAsset(destinationAsset);
                const originChain = this.getOriginChainFromAsset(originAsset);
                
                // Debug logging
                this.log(`Debug: Origin asset "${originAsset}" detected as ${originChain}`, 'info');
                this.log(`Debug: Destination asset "${destinationAsset}" detected as ${destinationChain}`, 'info');
                
                // Format addresses based on chain
                if (destinationChain === 'NEAR') {
                    // NEAR addresses should be in format: account.near or account.testnet
                    if (!recipientAddress.includes('.near') && !recipientAddress.includes('.testnet')) {
                        this.log('For NEAR destination, recipient should be in format: account.near', 'error');
                        this.log('Example: myaccount.near or myaccount.testnet', 'info');
                        this.log('Note: Even though the token shows (ETH), it\'s wrapped on NEAR chain', 'info');
                        return;
                    }
                    formattedRecipient = recipientAddress;
                    refundAddress = recipientAddress;
                } else if (destinationChain === 'Ethereum' || destinationChain === 'Polygon' || destinationChain === 'Arbitrum') {
                    // EVM addresses should be 0x format
                    if (!recipientAddress.startsWith('0x') || recipientAddress.length !== 42) {
                        this.log('For EVM chains, recipient should be a valid 0x address', 'error');
                        return;
                    }
                    formattedRecipient = recipientAddress;
                    refundAddress = recipientAddress;
                } else if (destinationChain === 'Solana') {
                    // Solana addresses should be base58 format
                    if (recipientAddress.length < 32 || recipientAddress.length > 44) {
                        this.log('For Solana destination, recipient should be a valid Solana address', 'error');
                        return;
                    }
                    formattedRecipient = recipientAddress;
                    refundAddress = recipientAddress;
                }
                
                if (originAsset === destinationAsset) {
                    this.log('Cannot swap the same token.', 'error');
                    return;
                }
                
                if (amountValue <= 0) {
                    this.log('Amount must be greater than 0.', 'error');
                    return;
                }
                
                // Get token info for display
                const fromTokenElement = document.querySelector('#nearFromTokenDropdown .dropdown-item[data-value="' + originAsset + '"]');
                const toTokenElement = document.querySelector('#nearToTokenDropdown .dropdown-item[data-value="' + destinationAsset + '"]');
                const fromSymbol = fromTokenElement ? fromTokenElement.getAttribute('data-symbol') : 'Unknown';
                const toSymbol = toTokenElement ? toTokenElement.getAttribute('data-symbol') : 'Unknown';
                
                this.log(`Starting Near Intents swap: ${amountValue} ${fromSymbol} → ${toSymbol}`, 'info');
                this.log(`Recipient: ${recipientAddress}`, 'info');
                this.log(`Slippage: ${slippageBps/100}%`, 'info');
                
                try {
                    // Step 1: Get quote
                    this.log('Getting quote...', 'info');
                    const quotePayload = {
                        dry: false, // Real swap
                        swapType: 'EXACT_INPUT',
                        slippageTolerance: slippageBps,
                        originAsset,
                        depositType: 'ORIGIN_CHAIN',
                        destinationAsset,
                        amount: amountValue.toString(),
                        refundTo: refundAddress,
                        refundType: 'ORIGIN_CHAIN',
                        recipient: formattedRecipient,
                        recipientType: 'DESTINATION_CHAIN',
                        deadline: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
                        quoteWaitingTimeMs: 3000
                    };
                    
                    const quoteResponse = await fetch('https://1click.chaindefuser.com/v0/quote', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(quotePayload)
                    });
                    
                    if (!quoteResponse.ok) {
                        const errorText = await quoteResponse.text();
                        this.log(`Quote failed: HTTP ${quoteResponse.status}`, 'error');
                        this.log(`Error details: ${errorText}`, 'error');
                        return;
                    }
                    
                    const quoteData = await quoteResponse.json();
                    this.log(`✅ Quote received!`, 'success');
                    this.log(`Input: ${quoteData.quote.amountInFormatted} ${fromSymbol}`, 'info');
                    this.log(`Output: ${quoteData.quote.amountOutFormatted} ${toSymbol}`, 'info');
                    this.log(`Deposit Address: ${quoteData.quote.depositAddress}`, 'info');
                    this.log(`Deadline: ${new Date(quoteData.quote.deadline).toLocaleString()}`, 'info');
                    
                    // Store swap info for status checking
                    window.nearSwapInfo = {
                        depositAddress: quoteData.quote.depositAddress,
                        originAsset,
                        destinationAsset,
                        amount: amountValue.toString(),
                        recipient: recipientAddress,
                        timestamp: Date.now()
                    };
                    
                    this.log(`<br><b>⚠️ IMPORTANT:</b> Send ${quoteData.quote.amountInFormatted} ${fromSymbol} to:`, 'warning');
                    this.log(`<b>${quoteData.quote.depositAddress}</b>`, 'info');
                    this.log(`<br>Use <b>near status ${quoteData.quote.depositAddress}</b> to check swap progress`, 'info');
                    
                } catch (e) {
                    this.log(`Swap failed: ${e.message}`, 'error');
                }
            }
            
            // Polymarket Prediction Market Functions
            async getPolymarketMarkets() {
                try {
                    this.log('Fetching Polymarket prediction markets...', 'info');
                    
                    // Try multiple API endpoints
                    let data = null;
                    let response = null;
                    
                    // Try the main API first
                    try {
                        response = await fetch('https://clob.polymarket.com/markets?limit=20', {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                            }
                        });
                        
                        if (response.ok) {
                            data = await response.json();
                        }
                    } catch (e) {
                        this.log('Primary API failed, trying alternative...', 'warning');
                    }
                    
                    // If primary failed, try alternative endpoint
                    if (!data) {
                        try {
                            response = await fetch('https://clob.polymarket.com/markets', {
                                method: 'GET',
                                headers: {
                                    'Accept': 'application/json',
                                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                                }
                            });
                            
                            if (response.ok) {
                                data = await response.json();
                            }
                        } catch (e) {
                            this.log('Alternative API also failed', 'warning');
                        }
                    }
                    
                    if (data && Array.isArray(data)) {
                        let html = `<b>🔮 Polymarket Prediction Markets (${data.length} shown)</b><br>`;
                        html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                        html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Status</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;
                        
                        data.forEach((market, index) => {
                            const status = market.active ? '🟢 Active' : market.closed ? '🔴 Closed' : '🟡 Archived';
                            const endDate = market.end_date_iso ? new Date(market.end_date_iso).toLocaleDateString() : 'N/A';
                            const outcomes = market.tokens ? market.tokens.map(t => t.outcome).join(' / ') : 'N/A';
                            
                            html += `<tr style='border-bottom:1px solid #444;'>`;
                            html += `<td style='padding:8px;'>${market.question || 'N/A'}</td>`;
                            html += `<td style='padding:8px;'>${status}</td>`;
                            html += `<td style='padding:8px;'>${endDate}</td>`;
                            html += `<td style='padding:8px;'>${outcomes}</td>`;
                            html += `</tr>`;
                        });
                        
                        html += `</table>`;
                        html += `<br><small>Use "polymarket market &lt;id&gt;" to get detailed info for a specific market</small>`;
                        this.logHtml(html, 'output');
                    } else if (data && typeof data === 'object') {
                        // Handle different response formats
                        const markets = data.markets || data.data || data.results || [];
                        if (Array.isArray(markets) && markets.length > 0) {
                            let html = `<b>🔮 Polymarket Prediction Markets (${markets.length} shown)</b><br>`;
                            html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                            html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Status</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;
                            
                            markets.forEach((market, index) => {
                                const status = market.active ? '🟢 Active' : market.closed ? '🔴 Closed' : '🟡 Archived';
                                const endDate = market.end_date_iso ? new Date(market.end_date_iso).toLocaleDateString() : 'N/A';
                                const outcomes = market.tokens ? market.tokens.map(t => t.outcome).join(' / ') : 'N/A';
                                
                                html += `<tr style='border-bottom:1px solid #444;'>`;
                                html += `<td style='padding:8px;'>${market.question || 'N/A'}</td>`;
                                html += `<td style='padding:8px;'>${status}</td>`;
                                html += `<td style='padding:8px;'>${endDate}</td>`;
                                html += `<td style='padding:8px;'>${outcomes}</td>`;
                                html += `</tr>`;
                            });
                            
                            html += `</table>`;
                            html += `<br><small>Use "polymarket market &lt;id&gt;" to get detailed info for a specific market</small>`;
                            this.logHtml(html, 'output');
                        } else {
                            this.log('No markets found in response.', 'warning');
                            this.log(`Response structure: ${JSON.stringify(data).substring(0, 200)}...`, 'info');
                        }
                    } else {
                        this.log('No markets found or invalid response format.', 'warning');
                        if (response) {
                            this.log(`HTTP Status: ${response.status}`, 'info');
                            const text = await response.text();
                            this.log(`Response: ${text.substring(0, 200)}...`, 'info');
                        }
                    }
                } catch (e) {
                    this.log(`Failed to fetch Polymarket markets: ${e.message}`, 'error');
                    this.log('This might be due to CORS restrictions or API changes.', 'info');
                    
                    // Show sample data for demonstration
                    this.log('Showing sample Polymarket data for demonstration:', 'info');
                    const sampleMarkets = [
                        {
                            question: "Will Bitcoin reach $100,000 by end of 2024?",
                            active: true,
                            end_date_iso: "2024-12-31T23:59:59Z",
                            tokens: [{outcome: "Yes"}, {outcome: "No"}]
                        },
                        {
                            question: "Will Ethereum 2.0 launch before June 2024?",
                            active: true,
                            end_date_iso: "2024-06-30T23:59:59Z",
                            tokens: [{outcome: "Yes"}, {outcome: "No"}]
                        },
                        {
                            question: "Will the US have a recession in 2024?",
                            active: true,
                            end_date_iso: "2024-12-31T23:59:59Z",
                            tokens: [{outcome: "Yes"}, {outcome: "No"}]
                        }
                    ];
                    
                    let html = `<b>🔮 Sample Polymarket Prediction Markets (Demo)</b><br>`;
                    html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                    html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Status</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;
                    
                    sampleMarkets.forEach((market, index) => {
                        const status = market.active ? '🟢 Active' : '🔴 Closed';
                        const endDate = market.end_date_iso ? new Date(market.end_date_iso).toLocaleDateString() : 'N/A';
                        const outcomes = market.tokens ? market.tokens.map(t => t.outcome).join(' / ') : 'N/A';
                        
                        html += `<tr style='border-bottom:1px solid #444;'>`;
                        html += `<td style='padding:8px;'>${market.question || 'N/A'}</td>`;
                        html += `<td style='padding:8px;'>${status}</td>`;
                        html += `<td style='padding:8px;'>${endDate}</td>`;
                        html += `<td style='padding:8px;'>${outcomes}</td>`;
                        html += `</tr>`;
                    });
                    
                    html += `</table>`;
                    html += `<br><small>Note: This is sample data. Real API access requires server-side proxy due to CORS restrictions.</small>`;
                    this.logHtml(html, 'output');
                }
            }
            
            async getPolymarketLiveMarkets() {
                try {
                    this.log('Fetching live Polymarket prediction markets...', 'info');
                    
                    let data = null;
                    let response = null;
                    
                    try {
                        // Use the same approach as active markets but with different endpoint
                        this.log('Attempting API call to Polymarket live markets...', 'info');
                        response = await fetch('https://clob.polymarket.com/markets?limit=200&sort=volume&order=desc', {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                            }
                        });
                        
                        if (!response.ok) {
                            // Try with CORS proxy
                            this.log('Direct API failed, trying CORS proxy...', 'info');
                            response = await fetch('https://api.codetabs.com/v1/proxy?quest=https://clob.polymarket.com/markets?limit=200&sort=volume&order=desc', {
                                method: 'GET',
                                headers: {
                                    'Accept': 'application/json'
                                }
                            });
                        }
                        
                        if (!response.ok) {
                            // Try alternative CORS proxy
                            this.log('First CORS proxy failed, trying alternative...', 'info');
                            response = await fetch('https://thingproxy.freeboard.io/fetch/https://clob.polymarket.com/markets?limit=200&sort=volume&order=desc', {
                                method: 'GET',
                                headers: {
                                    'Accept': 'application/json'
                                }
                            });
                        }
                        
                        this.log(`API Response Status: ${response.status}`, 'info');
                        
                        if (response.ok) {
                            data = await response.json();
                            this.log(`Received data type: ${typeof data}`, 'info');
                        } else {
                            this.log(`API returned status: ${response.status}`, 'warning');
                            throw new Error(`API returned status: ${response.status}`);
                        }
                    } catch (e) {
                        this.log('API request failed', 'warning');
                        this.log(`Error: ${e.message}`, 'info');
                    }
                    
                    if (data && typeof data === 'object' && !Array.isArray(data)) {
                        // Handle object response format (same as active markets)
                        this.log('Processing live markets response format...', 'info');
                        
                        // Handle GraphQL response format
                        let markets = [];
                        if (data.data && data.data.markets) {
                            markets = data.data.markets;
                            this.log('Processing GraphQL response format...', 'info');
                        } else {
                            markets = data.markets || data.data || data.results || [];
                            this.log('Processing REST API response format...', 'info');
                        }
                        
                        this.log(`Found ${markets.length} live markets`, 'info');
                        
                        // Filter for active markets
                        let liveMarkets = markets.filter(market => {
                            if (!market.active || !market.question || !market.tokens || market.tokens.length === 0) {
                                return false;
                            }
                            
                            // Check if market is still open
                            if (market.end_date_iso) {
                                const endDate = new Date(market.end_date_iso);
                                const now = new Date();
                                const daysDiff = (endDate - now) / (1000 * 60 * 60 * 24);
                                
                                // Only include markets that haven't ended or ended within the last 7 days
                                if (daysDiff < -7) {
                                    return false;
                                }
                            }
                            
                            return true;
                        });
                        
                        this.log(`Found ${liveMarkets.length} truly live markets`, 'info');
                        
                        if (liveMarkets.length > 0) {
                            const displayMarkets = liveMarkets.slice(0, 20);
                            
                            let html = `<b>🟢 Live Polymarket Prediction Markets (${liveMarkets.length} total, showing first 20)</b><br>`;
                            
                            // Add category filter buttons
                            html += `<div style='margin: 10px 0; padding: 10px; background: #222; border-radius: 5px;'>`;
                            html += `<b>Quick Filters:</b> `;
                            html += `<button onclick="window.terminal.filterPolymarketMarkets('all')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>All (${liveMarkets.length})</button>`;
                            html += `<button onclick="window.terminal.filterPolymarketMarkets('sports')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Sports</button>`;
                            html += `<button onclick="window.terminal.filterPolymarketMarkets('politics')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Politics</button>`;
                            html += `<button onclick="window.terminal.filterPolymarketMarkets('entertainment')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Entertainment</button>`;
                            html += `<button onclick="window.terminal.filterPolymarketMarkets('crypto')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Crypto</button>`;
                            html += `<button onclick="window.terminal.filterPolymarketMarkets('economy')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Economy</button>`;
                            html += `</div>`;
                            
                            // Add search box
                            html += `<div style='margin: 10px 0;'>`;
                            html += `<input type="text" id="polymarketSearch" placeholder="Search markets..." style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; box-sizing: border-box; z-index: 1000; position: relative; pointer-events: auto;" autocomplete="off" spellcheck="false" oninput="window.terminal.searchPolymarketResults(this.value)" onclick="this.focus()" onkeydown="console.log('Key pressed:', event.key)">`;
                            html += `</div>`;
                            
                            html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                            html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Category</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;
                            
                            displayMarkets.forEach((market, index) => {
                                const endDate = market.end_date_iso ? new Date(market.end_date_iso).toLocaleDateString() : 'N/A';
                                const outcomes = market.tokens ? market.tokens.map(t => t.outcome).join(' / ') : 'N/A';
                                const category = this.getMarketCategory(market.question || '');
                                
                                html += `<tr style='border-bottom:1px solid #444;'>`;
                                html += `<td style='padding:8px;'>${market.question || 'N/A'}</td>`;
                                html += `<td style='padding:8px;'><span style='color: #99ccff;'>${category}</span></td>`;
                                html += `<td style='padding:8px;'>${endDate}</td>`;
                                html += `<td style='padding:8px;'>${outcomes}</td>`;
                                html += `</tr>`;
                            });
                            
                            html += `</table>`;
                            
                            // Store markets for filtering
                            window.polymarketActiveMarkets = liveMarkets;
                            
                            this.logHtml(html, 'output');
                            
                            // Add search functionality
                            this.setupPolymarketSearch();
                        } else {
                            this.log('No live markets found.', 'warning');
                        }
                    } else {
                        this.log('No valid data received for live markets.', 'warning');
                    }
                } catch (e) {
                    this.log(`Failed to fetch live Polymarket markets: ${e.message}`, 'error');
                }
            }
            
            async getPolymarketRecentMarkets() {
                try {
                    this.log('Fetching recent Polymarket prediction markets (last 30 days)...', 'info');
                    
                    let data = null;
                    let response = null;
                    
                    try {
                        // Try to get recent markets with different parameters
                        response = await fetch('https://clob.polymarket.com/markets?limit=1000&sort=created_at&order=desc', {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                            }
                        });
                        
                        this.log(`API Response Status: ${response.status}`, 'info');
                        
                        if (response.ok) {
                            data = await response.json();
                            this.log(`Received data type: ${typeof data}`, 'info');
                        } else {
                            this.log(`API returned status: ${response.status}`, 'warning');
                        }
                    } catch (e) {
                        this.log('API request failed', 'warning');
                        this.log(`Error: ${e.message}`, 'info');
                    }
                    
                    if (data && typeof data === 'object' && !Array.isArray(data)) {
                        const markets = data.markets || data.data || data.results || [];
                        this.log(`Found ${markets.length} total markets`, 'info');
                        
                        // Filter for markets created in the last 30 days
                        const thirtyDaysAgo = new Date();
                        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
                        
                        let recentMarkets = markets.filter(market => {
                            if (!market.active || !market.question || !market.tokens || market.tokens.length === 0) {
                                return false;
                            }
                            
                            // Check creation date if available
                            if (market.created_at) {
                                const createdDate = new Date(market.created_at);
                                return createdDate >= thirtyDaysAgo;
                            }
                            
                            // If no creation date, check end date (must be in the future or recent past)
                            if (market.end_date_iso) {
                                const endDate = new Date(market.end_date_iso);
                                const now = new Date();
                                const daysDiff = (endDate - now) / (1000 * 60 * 60 * 24);
                                return daysDiff > -30; // Within 30 days of end date
                            }
                            
                            return true; // Include if no date info available
                        });
                        
                        this.log(`Found ${recentMarkets.length} recent markets (last 30 days)`, 'info');
                        
                        if (recentMarkets.length > 0) {
                            const displayMarkets = recentMarkets.slice(0, 20);
                            
                            let html = `<b>🟢 Recent Polymarket Prediction Markets (${recentMarkets.length} total, showing first 20)</b><br>`;
                            
                            // Add category filter buttons
                            html += `<div style='margin: 10px 0; padding: 10px; background: #222; border-radius: 5px;'>`;
                            html += `<b>Quick Filters:</b> `;
                            html += `<button onclick="window.terminal.filterPolymarketMarkets('all')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>All (${recentMarkets.length})</button>`;
                            html += `<button onclick="window.terminal.filterPolymarketMarkets('sports')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Sports</button>`;
                            html += `<button onclick="window.terminal.filterPolymarketMarkets('politics')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Politics</button>`;
                            html += `<button onclick="window.terminal.filterPolymarketMarkets('entertainment')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Entertainment</button>`;
                            html += `<button onclick="window.terminal.filterPolymarketMarkets('crypto')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Crypto</button>`;
                            html += `<button onclick="window.terminal.filterPolymarketMarkets('economy')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Economy</button>`;
                            html += `</div>`;
                            
                            // Add search box
                            html += `<div style='margin: 10px 0;'>`;
                            html += `<input type="text" id="polymarketSearch" placeholder="Search markets..." style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; box-sizing: border-box; z-index: 1000; position: relative; pointer-events: auto;" autocomplete="off" spellcheck="false" oninput="window.terminal.searchPolymarketResults(this.value)" onclick="this.focus()" onkeydown="console.log('Key pressed:', event.key)">`;
                            html += `</div>`;
                            
                            html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                            html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Category</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;
                            
                            displayMarkets.forEach((market, index) => {
                                const endDate = market.end_date_iso ? new Date(market.end_date_iso).toLocaleDateString() : 'N/A';
                                const outcomes = market.tokens ? market.tokens.map(t => t.outcome).join(' / ') : 'N/A';
                                const category = this.getMarketCategory(market.question || '');
                                
                                html += `<tr style='border-bottom:1px solid #444;'>`;
                                html += `<td style='padding:8px;'>${market.question || 'N/A'}</td>`;
                                html += `<td style='padding:8px;'><span style='color: #99ccff;'>${category}</span></td>`;
                                html += `<td style='padding:8px;'>${endDate}</td>`;
                                html += `<td style='padding:8px;'>${outcomes}</td>`;
                                html += `</tr>`;
                            });
                            
                            html += `</table>`;
                            
                            // Store markets for filtering
                            window.polymarketActiveMarkets = recentMarkets;
                            
                            this.logHtml(html, 'output');
                            
                            // Add search functionality
                            this.setupPolymarketSearch();
                        } else {
                            this.log('No recent markets found.', 'warning');
                        }
                    } else {
                        this.log('No valid data received for recent markets.', 'warning');
                    }
                } catch (e) {
                    this.log(`Failed to fetch recent Polymarket markets: ${e.message}`, 'error');
                }
            }
            
            async getPolymarketActiveMarkets() {
                try {
                    this.log('Fetching active Polymarket prediction markets...', 'info');
                    
                    let data = null;
                    let response = null;
                    
                    try {
                        // Try direct API call first (might work in some browsers)
                        this.log('Attempting direct API call to Polymarket...', 'info');
                        response = await fetch('https://clob.polymarket.com/markets?limit=500&sort=created_at&order=desc', {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                            }
                        });
                        
                        if (!response.ok) {
                            // Try with different CORS proxy
                            this.log('Direct API failed, trying CORS proxy...', 'info');
                            response = await fetch('https://api.codetabs.com/v1/proxy?quest=https://clob.polymarket.com/markets?limit=500&sort=created_at&order=desc', {
                                method: 'GET',
                                headers: {
                                    'Accept': 'application/json'
                                }
                            });
                        }
                        
                        if (!response.ok) {
                            // Try another CORS proxy
                            this.log('First CORS proxy failed, trying alternative...', 'info');
                            response = await fetch('https://thingproxy.freeboard.io/fetch/https://clob.polymarket.com/markets?limit=500&sort=created_at&order=desc', {
                                method: 'GET',
                                headers: {
                                    'Accept': 'application/json'
                                }
                            });
                        }
                        
                        if (!response.ok) {
                            // Try Polymarket's public API
                            this.log('CORS proxies failed, trying public API...', 'info');
                            response = await fetch('https://api.codetabs.com/v1/proxy?quest=https://api.polymarket.com/markets?limit=200&status=open', {
                                method: 'GET',
                                headers: {
                                    'Accept': 'application/json'
                                }
                            });
                        }
                        
                        this.log(`API Response Status: ${response.status}`, 'info');
                        
                        if (response.ok) {
                            data = await response.json();
                            this.log(`Received data type: ${typeof data}`, 'info');
                        } else {
                            this.log(`API returned status: ${response.status}`, 'warning');
                            throw new Error(`API returned status: ${response.status}`);
                        }
                        
                        if (response.ok) {
                            data = await response.json();
                            this.log(`Received data type: ${typeof data}`, 'info');
                            this.log(`Total markets received: ${Array.isArray(data) ? data.length : 'N/A'}`, 'info');
                        } else {
                            this.log(`API returned status: ${response.status}`, 'warning');
                        }
                    } catch (e) {
                        this.log('API request failed', 'warning');
                        this.log(`Error: ${e.message}`, 'info');
                    }
                    
                    if (data && typeof data === 'object' && !Array.isArray(data)) {
                        // Handle object response format (this is what the API actually returns)
                        this.log('Processing object response format...', 'info');
                        this.log(`Object keys: ${Object.keys(data).join(', ')}`, 'info');
                        
                        // Handle GraphQL response format
                        let markets = [];
                        if (data.data && data.data.markets) {
                            markets = data.data.markets;
                            this.log('Processing GraphQL response format...', 'info');
                        } else {
                            markets = data.markets || data.data || data.results || [];
                            this.log('Processing REST API response format...', 'info');
                        }
                        
                        this.log(`Found ${markets.length} markets in object`, 'info');
                        
                        if (markets.length > 0) {
                            this.log(`Processing ${markets.length} markets from API...`, 'info');
                            
                            // Filter for truly active markets with strict date checking
                            let activeMarkets = markets.filter(market => {
                                // Must be active
                                if (!market.active) {
                                    return false;
                                }
                                
                                // Must have valid question and tokens
                                if (!market.question || !market.tokens || market.tokens.length === 0) {
                                    return false;
                                }
                                
                                // Check if market has ended - only show markets that haven't ended or ended very recently
                                if (market.end_date_iso) {
                                    const endDate = new Date(market.end_date_iso);
                                    const now = new Date();
                                    const daysDiff = (endDate - now) / (1000 * 60 * 60 * 24);
                                    
                                    // Only include markets that haven't ended or ended within the last 7 days
                                    if (daysDiff < -7) {
                                        return false;
                                    }
                                }
                                
                                return true;
                            });
                            
                            this.log(`Found ${activeMarkets.length} truly active markets after filtering`, 'info');
                            
                            // If no active markets found, try to get some recent ones
                            if (activeMarkets.length === 0) {
                                this.log('No active markets found, looking for recent markets...', 'info');
                                activeMarkets = markets.filter(market => 
                                    market.active && 
                                    market.question && 
                                    market.tokens && 
                                    market.tokens.length > 0
                                ).slice(0, 20);
                                
                                this.log(`Found ${activeMarkets.length} recent markets as fallback`, 'info');
                            }
                            
                            if (activeMarkets.length > 0) {
                                // Limit to first 20 markets for better readability
                                const displayMarkets = activeMarkets.slice(0, 20);
                                
                                let html = `<b>🟢 Active Polymarket Prediction Markets (${activeMarkets.length} total, showing first 20)</b><br>`;
                                
                                // Add category filter buttons
                                html += `<div style='margin: 10px 0; padding: 10px; background: #222; border-radius: 5px;'>`;
                                html += `<b>Quick Filters:</b> `;
                                html += `<button onclick="window.terminal.filterPolymarketMarkets('all')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>All (${activeMarkets.length})</button>`;
                                html += `<button onclick="window.terminal.filterPolymarketMarkets('sports')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Sports</button>`;
                                html += `<button onclick="window.terminal.filterPolymarketMarkets('politics')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Politics</button>`;
                                html += `<button onclick="window.terminal.filterPolymarketMarkets('entertainment')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Entertainment</button>`;
                                html += `<button onclick="window.terminal.filterPolymarketMarkets('crypto')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Crypto</button>`;
                                html += `<button onclick="window.terminal.filterPolymarketMarkets('economy')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Economy</button>`;
                                html += `</div>`;
                                
                                // Add search box
                                html += `<div style='margin: 10px 0;'>`;
                                html += `<input type="text" id="polymarketSearch" placeholder="Search markets..." style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; box-sizing: border-box; z-index: 1000; position: relative; pointer-events: auto;" autocomplete="off" spellcheck="false" oninput="window.terminal.searchPolymarketResults(this.value)" onclick="this.focus()" onkeydown="console.log('Key pressed:', event.key)">`;
                                html += `</div>`;
                                
                                html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                                html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Category</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;
                                
                                displayMarkets.forEach((market, index) => {
                                    const endDate = market.end_date_iso ? new Date(market.end_date_iso).toLocaleDateString() : 'N/A';
                                    const outcomes = market.tokens ? market.tokens.map(t => t.outcome).join(' / ') : 'N/A';
                                    const category = this.getMarketCategory(market.question || '');
                                    
                                    html += `<tr style='border-bottom:1px solid #444;'>`;
                                    html += `<td style='padding:8px;'>${market.question || 'N/A'}</td>`;
                                    html += `<td style='padding:8px;'><span style='color: #99ccff;'>${category}</span></td>`;
                                    html += `<td style='padding:8px;'>${endDate}</td>`;
                                    html += `<td style='padding:8px;'>${outcomes}</td>`;
                                    html += `</tr>`;
                                });
                                
                                html += `</table>`;
                                
                                // Add "Show More" button if there are more results
                                if (activeMarkets.length > 20) {
                                    html += `<br><button onclick="window.terminal.showMoreAllPolymarketMarkets(20)" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${activeMarkets.length - 20} remaining)</button>`;
                                }
                                
                                // Store markets for filtering
                                window.polymarketActiveMarkets = activeMarkets;
                                
                                this.logHtml(html, 'output');
                                
                                // Add search functionality
                                this.setupPolymarketSearch();
                            } else {
                                this.log('No active markets found after filtering.', 'warning');
                            }
                        } else {
                            this.log('No markets found in object response.', 'warning');
                            this.log(`Debug: Data structure: ${JSON.stringify(data).substring(0, 200)}...`, 'info');
                        }
                    } else if (data && Array.isArray(data)) {
                        // Handle direct array response (fallback)
                        this.log(`Processing array response format with ${data.length} markets...`, 'info');
                        
                        // Filter for truly active markets with better date checking
                        let activeMarkets = data.filter(market => {
                            // Debug: Log what we're checking
                            const endDate = market.end_date_iso ? new Date(market.end_date_iso) : null;
                            const now = new Date();
                            const daysDiff = endDate ? (now - endDate) / (1000 * 60 * 60 * 24) : 0;
                            
                            // Must be active (but allow closed markets if they're recent)
                            if (!market.active) {
                                this.log(`Filtered out: not active`, 'info');
                                return false;
                            }
                            
                            // Additional checks for market validity
                            if (market.tokens && market.tokens.length === 0) {
                                this.log(`Filtered out: no tokens`, 'info');
                                return false;
                            }
                            if (!market.question || market.question.trim() === '') {
                                this.log(`Filtered out: no question`, 'info');
                                return false;
                            }
                            
                            // Check if market has ended - but be very lenient (90 days)
                            if (market.end_date_iso) {
                                if (endDate < now) {
                                    if (daysDiff > 90) {
                                        this.log(`Filtered out: ended ${daysDiff.toFixed(0)} days ago`, 'info');
                                        return false;
                                    }
                                }
                            }
                            
                            return true;
                        });
                        
                        this.log(`Found ${activeMarkets.length} truly active markets after date filtering`, 'info');
                        this.log(`Found ${activeMarkets.length} active markets after filtering`, 'info');
                        
                        if (activeMarkets.length > 0) {
                            let html = `<b>🟢 Active Polymarket Prediction Markets (${activeMarkets.length} found)</b><br>`;
                            html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                            html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th><th style='padding:8px;text-align:left;'>Min Order</th></tr>`;
                            
                            activeMarkets.forEach((market, index) => {
                                const endDate = market.end_date_iso ? new Date(market.end_date_iso).toLocaleDateString() : 'N/A';
                                const outcomes = market.tokens ? market.tokens.map(t => t.outcome).join(' / ') : 'N/A';
                                const minOrder = market.minimum_order_size ? `$${market.minimum_order_size}` : 'N/A';
                                
                                html += `<tr style='border-bottom:1px solid #444;'>`;
                                html += `<td style='padding:8px;'>${market.question || 'N/A'}</td>`;
                                html += `<td style='padding:8px;'>${endDate}</td>`;
                                html += `<td style='padding:8px;'>${outcomes}</td>`;
                                html += `<td style='padding:8px;'>${minOrder}</td>`;
                                html += `</tr>`;
                            });
                            
                            html += `</table>`;
                            this.logHtml(html, 'output');
                        } else {
                            this.log('No active markets found.', 'warning');
                        }
                    } else {
                        this.log('No valid data received.', 'warning');
                        if (data) {
                            this.log(`Debug: Received data type: ${typeof data}`, 'info');
                            this.log(`Debug: Data structure: ${JSON.stringify(data).substring(0, 200)}...`, 'info');
                        }
                    }
                } catch (e) {
                    this.log(`Failed to fetch active Polymarket markets: ${e.message}`, 'error');
                    this.log('This might be due to CORS restrictions or API changes.', 'info');
                }
            }
            
            // Helper function to categorize markets
            getMarketCategory(question) {
                const q = question.toLowerCase();
                
                // Sports categories
                if (q.includes('nfl') || q.includes('nba') || q.includes('mlb') || q.includes('nhl') || 
                    q.includes('soccer') || q.includes('football') || q.includes('basketball') || 
                    q.includes('baseball') || q.includes('hockey') || q.includes('ufc') || 
                    q.includes('boxing') || q.includes('tennis') || q.includes('golf') ||
                    q.includes('champion') || q.includes('vs') || q.includes('beat') ||
                    q.includes('super bowl') || q.includes('playoff') || q.includes('final') ||
                    q.includes('league') || q.includes('cup') || q.includes('tournament')) {
                    return 'Sports';
                }
                
                // Politics categories
                if (q.includes('election') || q.includes('president') || q.includes('biden') || 
                    q.includes('trump') || q.includes('congress') || q.includes('senate') || 
                    q.includes('house') || q.includes('democrat') || q.includes('republican') ||
                    q.includes('state of the union') || q.includes('hearing') || q.includes('secretary') ||
                    q.includes('campaign') || q.includes('vote') || q.includes('poll') ||
                    q.includes('government') || q.includes('policy') || q.includes('law')) {
                    return 'Politics';
                }
                
                // Entertainment categories
                if (q.includes('movie') || q.includes('film') || q.includes('box office') || 
                    q.includes('gross') || q.includes('oscar') || q.includes('award') ||
                    q.includes('tv') || q.includes('television') || q.includes('show') ||
                    q.includes('album') || q.includes('music') || q.includes('concert') ||
                    q.includes('actor') || q.includes('actress') || q.includes('director') ||
                    q.includes('streaming') || q.includes('netflix') || q.includes('disney')) {
                    return 'Entertainment';
                }
                
                // Crypto categories - Much more comprehensive
                if (q.includes('bitcoin') || q.includes('ethereum') || q.includes('crypto') || 
                    q.includes('token') || q.includes('coin') || q.includes('blockchain') ||
                    q.includes('defi') || q.includes('nft') || q.includes('airdrop') ||
                    q.includes('btc') || q.includes('eth') || q.includes('sol') || q.includes('solana') ||
                    q.includes('xrp') || q.includes('ripple') || q.includes('dogecoin') || q.includes('doge') ||
                    q.includes('cardano') || q.includes('ada') || q.includes('polkadot') || q.includes('dot') ||
                    q.includes('chainlink') || q.includes('link') || q.includes('uniswap') || q.includes('uni') ||
                    q.includes('opensea') || q.includes('blur') || q.includes('pump.fun') ||
                    q.includes('price') || q.includes('market cap') || q.includes('fdv') ||
                    q.includes('merge') || q.includes('eip') || q.includes('upgrade') ||
                    q.includes('wallet') || q.includes('exchange') || q.includes('dex') ||
                    q.includes('staking') || q.includes('yield') || q.includes('liquidity') ||
                    q.includes('dao') || q.includes('governance') || q.includes('protocol')) {
                    return 'Crypto';
                }
                
                // Economy categories
                if (q.includes('inflation') || q.includes('recession') || q.includes('gdp') || 
                    q.includes('unemployment') || q.includes('fed') || q.includes('interest rate') ||
                    q.includes('economy') || q.includes('market') || q.includes('stock') ||
                    q.includes('dollar') || q.includes('currency') || q.includes('trade') ||
                    q.includes('tariff') || q.includes('tax') || q.includes('debt') ||
                    q.includes('bond') || q.includes('treasury') || q.includes('central bank')) {
                    return 'Economy';
                }
                
                return 'Other';
            }
            
            // Filter markets by category
            filterPolymarketMarkets(category) {
                if (!window.polymarketActiveMarkets) {
                    this.log('No markets available for filtering.', 'warning');
                    return;
                }
                
                let filteredMarkets = window.polymarketActiveMarkets;
                
                if (category !== 'all') {
                    // Convert category to proper case for comparison
                    const categoryMap = {
                        'sports': 'Sports',
                        'politics': 'Politics', 
                        'entertainment': 'Entertainment',
                        'crypto': 'Crypto',
                        'economy': 'Economy'
                    };
                    const targetCategory = categoryMap[category] || category;
                    
                    filteredMarkets = window.polymarketActiveMarkets.filter(market => 
                        this.getMarketCategory(market.question || '') === targetCategory
                    );
                }
                
                // Display filtered results
                const displayMarkets = filteredMarkets.slice(0, 20);
                
                let html = `<b>🟢 ${category.charAt(0).toUpperCase() + category.slice(1)} Markets (${filteredMarkets.length} total, showing first 20)</b><br>`;
                
                if (displayMarkets.length > 0) {
                    html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                    html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Category</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;
                    
                    displayMarkets.forEach((market, index) => {
                        const endDate = market.end_date_iso ? new Date(market.end_date_iso).toLocaleDateString() : 'N/A';
                        const outcomes = market.tokens ? market.tokens.map(t => t.outcome).join(' / ') : 'N/A';
                        const marketCategory = this.getMarketCategory(market.question || '');
                        
                        html += `<tr style='border-bottom:1px solid #444;'>`;
                        html += `<td style='padding:8px;'>${market.question || 'N/A'}</td>`;
                        html += `<td style='padding:8px;'><span style='color: #99ccff;'>${marketCategory}</span></td>`;
                        html += `<td style='padding:8px;'>${endDate}</td>`;
                        html += `<td style='padding:8px;'>${outcomes}</td>`;
                        html += `</tr>`;
                    });
                    
                    html += `</table>`;
                    
                    // Add "Show More" button if there are more results
                    if (filteredMarkets.length > 20) {
                        html += `<br><button onclick="window.terminal.showMorePolymarketMarkets('${category}', 20)" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${filteredMarkets.length - 20} remaining)</button>`;
                    }
                } else {
                    html += `<p>No markets found in this category.</p>`;
                }
                
                this.logHtml(html, 'output');
            }
            
            // Show more markets for a category
            showMorePolymarketMarkets(category, currentCount) {
                if (!window.polymarketActiveMarkets) {
                    this.log('No markets available.', 'warning');
                    return;
                }
                
                let filteredMarkets = window.polymarketActiveMarkets;
                
                if (category !== 'all') {
                    // Convert category to proper case for comparison
                    const categoryMap = {
                        'sports': 'Sports',
                        'politics': 'Politics', 
                        'entertainment': 'Entertainment',
                        'crypto': 'Crypto',
                        'economy': 'Economy'
                    };
                    const targetCategory = categoryMap[category] || category;
                    
                    filteredMarkets = window.polymarketActiveMarkets.filter(market => 
                        this.getMarketCategory(market.question || '') === targetCategory
                    );
                }
                
                // Show next batch of results
                const nextBatch = Math.min(currentCount + 20, filteredMarkets.length);
                const displayMarkets = filteredMarkets.slice(0, nextBatch);
                
                let html = `<b>🟢 ${category.charAt(0).toUpperCase() + category.slice(1)} Markets (${filteredMarkets.length} total, showing ${nextBatch})</b><br>`;
                
                if (displayMarkets.length > 0) {
                    html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                    html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Category</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;
                    
                    displayMarkets.forEach((market, index) => {
                        const endDate = market.end_date_iso ? new Date(market.end_date_iso).toLocaleDateString() : 'N/A';
                        const outcomes = market.tokens ? market.tokens.map(t => t.outcome).join(' / ') : 'N/A';
                        const marketCategory = this.getMarketCategory(market.question || '');
                        
                        html += `<tr style='border-bottom:1px solid #444;'>`;
                        html += `<td style='padding:8px;'>${market.question || 'N/A'}</td>`;
                        html += `<td style='padding:8px;'><span style='color: #99ccff;'>${marketCategory}</span></td>`;
                        html += `<td style='padding:8px;'>${endDate}</td>`;
                        html += `<td style='padding:8px;'>${outcomes}</td>`;
                        html += `</tr>`;
                    });
                    
                    html += `</table>`;
                    
                    // Add "Show More" button if there are still more results
                    if (nextBatch < filteredMarkets.length) {
                        html += `<br><button onclick="window.terminal.showMorePolymarketMarkets('${category}', ${nextBatch})" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${filteredMarkets.length - nextBatch} remaining)</button>`;
                    }
                } else {
                    html += `<p>No markets found in this category.</p>`;
                }
                
                this.logHtml(html, 'output');
            }
            
            // Search within displayed markets
            searchPolymarketResults(query) {
                if (!window.polymarketActiveMarkets) {
                    this.log('No markets available for search.', 'warning');
                    return;
                }
                
                // If query is empty, show all markets
                if (!query || !query.trim()) {
                    this.filterPolymarketMarkets('all');
                    return;
                }
                
                const filteredMarkets = window.polymarketActiveMarkets.filter(market => 
                    market.question && market.question.toLowerCase().includes(query.toLowerCase())
                );
                
                const displayMarkets = filteredMarkets.slice(0, 20);
                
                let html = `<b>🔍 Search Results for "${query}" (${filteredMarkets.length} found, showing first 20)</b><br>`;
                
                if (displayMarkets.length > 0) {
                    html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                    html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Category</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;
                    
                    displayMarkets.forEach((market, index) => {
                        const endDate = market.end_date_iso ? new Date(market.end_date_iso).toLocaleDateString() : 'N/A';
                        const outcomes = market.tokens ? market.tokens.map(t => t.outcome).join(' / ') : 'N/A';
                        const category = this.getMarketCategory(market.question || '');
                        
                        html += `<tr style='border-bottom:1px solid #444;'>`;
                        html += `<td style='padding:8px;'>${market.question || 'N/A'}</td>`;
                        html += `<td style='padding:8px;'><span style='color: #99ccff;'>${category}</span></td>`;
                        html += `<td style='padding:8px;'>${endDate}</td>`;
                        html += `<td style='padding:8px;'>${outcomes}</td>`;
                        html += `</tr>`;
                    });
                    
                    html += `</table>`;
                    
                    // Add "Show More" button if there are more results
                    if (filteredMarkets.length > 20) {
                        html += `<br><button onclick="window.terminal.showMoreSearchResults('${query}', 20)" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${filteredMarkets.length - 20} remaining)</button>`;
                    }
                } else {
                    html += `<p>No markets found matching "${query}".</p>`;
                }
                
                this.logHtml(html, 'output');
            }
            
            // Show more all markets
            showMoreAllPolymarketMarkets(currentCount) {
                if (!window.polymarketActiveMarkets) {
                    this.log('No markets available.', 'warning');
                    return;
                }
                
                // Show next batch of results
                const nextBatch = Math.min(currentCount + 20, window.polymarketActiveMarkets.length);
                const displayMarkets = window.polymarketActiveMarkets.slice(0, nextBatch);
                
                let html = `<b>🟢 Active Polymarket Prediction Markets (${window.polymarketActiveMarkets.length} total, showing ${nextBatch})</b><br>`;
                
                // Add category filter buttons
                html += `<div style='margin: 10px 0;'><b>Quick Filters:</b><br>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('all')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>All (${window.polymarketActiveMarkets.length})</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('sports')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Sports</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('politics')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Politics</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('entertainment')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Entertainment</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('crypto')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Crypto</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('economy')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Economy</button>`;
                html += `</div>`;
                
                // Add search box
                html += `<div style='margin: 10px 0;'>`;
                html += `<input type="text" id="polymarketSearch" placeholder="Search markets..." style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; box-sizing: border-box; z-index: 1000; position: relative; pointer-events: auto;" autocomplete="off" spellcheck="false" oninput="window.terminal.searchPolymarketResults(this.value)" onclick="this.focus()" onkeydown="console.log('Key pressed:', event.key)">`;
                html += `<br><small style="color: #666;">Type to search markets (e.g., "bitcoin", "election", "nfl")</small>`;
                html += `</div>`;
                
                if (displayMarkets.length > 0) {
                    html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                    html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Category</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;
                    
                    displayMarkets.forEach((market, index) => {
                        const endDate = market.end_date_iso ? new Date(market.end_date_iso).toLocaleDateString() : 'N/A';
                        const outcomes = market.tokens ? market.tokens.map(t => t.outcome).join(' / ') : 'N/A';
                        const marketCategory = this.getMarketCategory(market.question || '');
                        
                        html += `<tr style='border-bottom:1px solid #444;'>`;
                        html += `<td style='padding:8px;'>${market.question || 'N/A'}</td>`;
                        html += `<td style='padding:8px;'><span style='color: #99ccff;'>${marketCategory}</span></td>`;
                        html += `<td style='padding:8px;'>${endDate}</td>`;
                        html += `<td style='padding:8px;'>${outcomes}</td>`;
                        html += `</tr>`;
                    });
                    
                    html += `</table>`;
                    
                    // Add "Show More" button if there are still more results
                    if (nextBatch < window.polymarketActiveMarkets.length) {
                        html += `<br><button onclick="window.terminal.showMoreAllPolymarketMarkets(${nextBatch})" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${window.polymarketActiveMarkets.length - nextBatch} remaining)</button>`;
                    }
                } else {
                    html += `<p>No markets found.</p>`;
                }
                
                this.logHtml(html, 'output');
                
                // Re-add search functionality
                this.setupPolymarketSearch();
            }
            
            // Setup search functionality for Polymarket
            setupPolymarketSearch() {
                // Since we're using inline event handlers, this function is now simplified
                // The search functionality is handled directly by the oninput attribute
                console.log('Polymarket search functionality ready');
                
                // Add a test button to help debug search issues
                setTimeout(() => {
                    const searchBox = document.getElementById('polymarketSearch');
                    if (searchBox) {
                        // Add a test button next to the search box
                        const testButton = document.createElement('button');
                        testButton.textContent = 'Test Search';
                        testButton.style.cssText = 'margin-left: 10px; padding: 4px 8px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;';
                        testButton.onclick = () => {
                            this.log('Testing search functionality...', 'info');
                            this.searchPolymarketResults('bitcoin');
                        };
                        searchBox.parentNode.insertBefore(testButton, searchBox.nextSibling);
                    }
                }, 1000);
            }
            
            // Show more search results
            showMoreSearchResults(query, currentCount) {
                if (!window.polymarketActiveMarkets || !query.trim()) {
                    return;
                }
                
                const filteredMarkets = window.polymarketActiveMarkets.filter(market => 
                    market.question && market.question.toLowerCase().includes(query.toLowerCase())
                );
                
                // Show next batch of results
                const nextBatch = Math.min(currentCount + 20, filteredMarkets.length);
                const displayMarkets = filteredMarkets.slice(0, nextBatch);
                
                let html = `<b>🔍 Search Results for "${query}" (${filteredMarkets.length} found, showing ${nextBatch})</b><br>`;
                
                if (displayMarkets.length > 0) {
                    html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                    html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Category</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;
                    
                    displayMarkets.forEach((market, index) => {
                        const endDate = market.end_date_iso ? new Date(market.end_date_iso).toLocaleDateString() : 'N/A';
                        const outcomes = market.tokens ? market.tokens.map(t => t.outcome).join(' / ') : 'N/A';
                        const category = this.getMarketCategory(market.question || '');
                        
                        html += `<tr style='border-bottom:1px solid #444;'>`;
                        html += `<td style='padding:8px;'>${market.question || 'N/A'}</td>`;
                        html += `<td style='padding:8px;'><span style='color: #99ccff;'>${category}</span></td>`;
                        html += `<td style='padding:8px;'>${endDate}</td>`;
                        html += `<td style='padding:8px;'>${outcomes}</td>`;
                        html += `</tr>`;
                    });
                    
                    html += `</table>`;
                    
                    // Add "Show More" button if there are still more results
                    if (nextBatch < filteredMarkets.length) {
                        html += `<br><button onclick="window.terminal.showMoreSearchResults('${query}', ${nextBatch})" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${filteredMarkets.length - nextBatch} remaining)</button>`;
                    }
                } else {
                    html += `<p>No markets found matching "${query}".</p>`;
                }
                
                this.logHtml(html, 'output');
            }
            
            async searchPolymarketMarkets(query) {
                try {
                    this.log(`Searching Polymarket markets for: "${query}"`, 'info');
                    
                    let data = null;
                    let response = null;
                    
                    try {
                        response = await fetch(`https://clob.polymarket.com/markets?limit=50`, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                            }
                        });
                        
                        if (response.ok) {
                            data = await response.json();
                        }
                    } catch (e) {
                        this.log('API request failed', 'warning');
                    }
                    
                    if (data && Array.isArray(data)) {
                        const searchResults = data.filter(market => 
                            market.question && market.question.toLowerCase().includes(query.toLowerCase()) ||
                            market.description && market.description.toLowerCase().includes(query.toLowerCase()) ||
                            market.tags && market.tags.some(tag => tag.toLowerCase().includes(query.toLowerCase()))
                        );
                        
                        if (searchResults.length > 0) {
                            let html = `<b>🔍 Polymarket Search Results for "${query}" (${searchResults.length} found)</b><br>`;
                            html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                            html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Status</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;
                            
                            searchResults.slice(0, 10).forEach((market, index) => {
                                const status = market.active ? '🟢 Active' : market.closed ? '🔴 Closed' : '🟡 Archived';
                                const endDate = market.end_date_iso ? new Date(market.end_date_iso).toLocaleDateString() : 'N/A';
                                const outcomes = market.tokens ? market.tokens.map(t => t.outcome).join(' / ') : 'N/A';
                                
                                html += `<tr style='border-bottom:1px solid #444;'>`;
                                html += `<td style='padding:8px;'>${market.question || 'N/A'}</td>`;
                                html += `<td style='padding:8px;'>${status}</td>`;
                                html += `<td style='padding:8px;'>${endDate}</td>`;
                                html += `<td style='padding:8px;'>${outcomes}</td>`;
                                html += `</tr>`;
                            });
                            
                            html += `</table>`;
                            if (searchResults.length > 10) {
                                html += `<br><small>Showing first 10 results. Use more specific search terms to narrow results.</small>`;
                            }
                            this.logHtml(html, 'output');
                        } else {
                            this.log(`No markets found matching "${query}"`, 'warning');
                        }
                    } else {
                        this.log('Failed to fetch markets for search.', 'error');
                    }
                } catch (e) {
                    this.log(`Search failed: ${e.message}`, 'error');
                }
            }
            

            

            
            async getPolymarketMarketDetails(marketId) {
                try {
                    this.log(`Fetching details for Polymarket market: ${marketId}`, 'info');
                    
                    let data = null;
                    let response = null;
                    
                    try {
                        response = await fetch(`https://clob.polymarket.com/markets?limit=100`, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                            }
                        });
                        
                        if (response.ok) {
                            data = await response.json();
                        }
                    } catch (e) {
                        this.log('API request failed', 'warning');
                    }
                    
                    if (data && Array.isArray(data)) {
                        // Try to find market by ID or slug
                        const market = data.find(m => 
                            m.condition_id === marketId || 
                            m.question_id === marketId || 
                            m.market_slug === marketId ||
                            m.question && m.question.toLowerCase().includes(marketId.toLowerCase())
                        );
                        
                        if (market) {
                            let html = `<b>🔮 Polymarket Market Details</b><br>`;
                            html += `<div style='background:#222;padding:15px;border-radius:5px;margin:10px 0;'>`;
                            html += `<b>Question:</b> ${market.question || 'N/A'}<br>`;
                            html += `<b>Description:</b> ${market.description ? market.description.substring(0, 200) + '...' : 'N/A'}<br>`;
                            html += `<b>Status:</b> ${market.active ? '🟢 Active' : market.closed ? '🔴 Closed' : '🟡 Archived'}<br>`;
                            html += `<b>End Date:</b> ${market.end_date_iso ? new Date(market.end_date_iso).toLocaleString() : 'N/A'}<br>`;
                            html += `<b>Minimum Order:</b> ${market.minimum_order_size ? `$${market.minimum_order_size}` : 'N/A'}<br>`;
                            html += `<b>Accepting Orders:</b> ${market.accepting_orders ? 'Yes' : 'No'}<br>`;
                            html += `</div>`;
                            
                            if (market.tokens && market.tokens.length > 0) {
                                html += `<b>Outcomes:</b><br>`;
                                html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;margin:10px 0;'>`;
                                html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Outcome</th><th style='padding:8px;text-align:left;'>Price</th><th style='padding:8px;text-align:left;'>Winner</th></tr>`;
                                
                                market.tokens.forEach(token => {
                                    const price = token.price !== undefined ? `$${token.price}` : 'N/A';
                                    const winner = token.winner ? '🏆 Yes' : 'No';
                                    
                                    html += `<tr style='border-bottom:1px solid #444;'>`;
                                    html += `<td style='padding:8px;'>${token.outcome || 'N/A'}</td>`;
                                    html += `<td style='padding:8px;'>${price}</td>`;
                                    html += `<td style='padding:8px;'>${winner}</td>`;
                                    html += `</tr>`;
                                });
                                
                                html += `</table>`;
                            }
                            
                            if (market.tags && market.tags.length > 0) {
                                html += `<b>Tags:</b> ${market.tags.join(', ')}<br>`;
                            }
                            
                            this.logHtml(html, 'output');
                        } else {
                            this.log(`Market not found: ${marketId}`, 'error');
                            this.log('Try using "polymarket markets" to see available markets', 'info');
                        }
                    } else {
                        this.log('Failed to fetch market details.', 'error');
                    }
                } catch (e) {
                    this.log(`Failed to fetch market details: ${e.message}`, 'error');
                }
            }
            
            // Magic Eden NFT Marketplace Functions
            async getMagicEdenCollections() {
                try {
                    this.log('Fetching Magic Eden collections...', 'info');
                    
                    let data = null;
                    let response = null;
                    
                    try {
                        response = await fetch('https://api-mainnet.magiceden.dev/v2/collections', {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                            }
                        });
                        
                        if (response.ok) {
                            data = await response.json();
                        }
                    } catch (e) {
                        this.log('Direct API request failed, trying proxy...', 'warning');
                        try {
                            response = await fetch('https://api.codetabs.com/v1/proxy?quest=https://api-mainnet.magiceden.dev/v2/collections', {
                                method: 'GET',
                                headers: {
                                    'Accept': 'application/json'
                                }
                            });
                            
                            if (response.ok) {
                                data = await response.json();
                            }
                        } catch (e2) {
                            this.log('Proxy request also failed', 'warning');
                        }
                    }
                    
                    if (data && Array.isArray(data)) {
                        const collections = data.slice(0, 20); // Show first 20
                        
                        let html = `<b>🎨 Magic Eden Collections (${data.length} total, showing first 20)</b><br>`;
                        html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                        html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Name</th><th style='padding:8px;text-align:left;'>Symbol</th><th style='padding:8px;text-align:left;'>Floor Price</th><th style='padding:8px;text-align:left;'>Listed</th><th style='padding:8px;text-align:left;'>Supply</th></tr>`;
                        
                        collections.forEach((collection, index) => {
                            const floorPrice = collection.floorPrice ? `${collection.floorPrice} SOL` : 'N/A';
                            const listed = collection.listedCount || 'N/A';
                            const supply = collection.supply || 'N/A';
                            
                            html += `<tr style='border-bottom:1px solid #444;'>`;
                            html += `<td style='padding:8px;'>${collection.name || 'N/A'}</td>`;
                            html += `<td style='padding:8px;'><span style='color: #99ccff;'>${collection.symbol || 'N/A'}</span></td>`;
                            html += `<td style='padding:8px;'>${floorPrice}</td>`;
                            html += `<td style='padding:8px;'>${listed}</td>`;
                            html += `<td style='padding:8px;'>${supply}</td>`;
                            html += `</tr>`;
                        });
                        
                        html += `</table>`;
                        
                        if (data.length > 20) {
                            html += `<br><button onclick="window.terminal.showMoreMagicEdenCollections(20)" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${data.length - 20} remaining)</button>`;
                        }
                        
                        this.logHtml(html, 'output');
                        window.magicEdenCollections = data;
                    } else {
                        this.log('Failed to fetch Magic Eden collections.', 'error');
                    }
                } catch (e) {
                    this.log(`Failed to fetch Magic Eden collections: ${e.message}`, 'error');
                }
            }
            
            async getMagicEdenPopularCollections() {
                try {
                    this.log('Fetching Magic Eden popular collections...', 'info');
                    
                    let data = null;
                    let response = null;
                    
                    try {
                        // Try the collections endpoint with sorting by volume
                        response = await fetch('https://api-mainnet.magiceden.dev/v2/collections?limit=50&offset=0', {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                            }
                        });
                        
                        if (response.ok) {
                            data = await response.json();
                        }
                    } catch (e) {
                        this.log('Direct API request failed, trying proxy...', 'warning');
                        try {
                            response = await fetch('https://api.codetabs.com/v1/proxy?quest=https://api-mainnet.magiceden.dev/v2/collections?limit=50&offset=0', {
                                method: 'GET',
                                headers: {
                                    'Accept': 'application/json'
                                }
                            });
                            
                            if (response.ok) {
                                data = await response.json();
                            }
                        } catch (e2) {
                            this.log('First proxy failed, trying second proxy...', 'warning');
                            try {
                                response = await fetch('https://thingproxy.freeboard.io/fetch/https://api-mainnet.magiceden.dev/v2/collections?limit=50&offset=0', {
                                    method: 'GET',
                                    headers: {
                                        'Accept': 'application/json'
                                    }
                                });
                                
                                if (response.ok) {
                                    data = await response.json();
                                }
                            } catch (e3) {
                                this.log('All proxies failed, trying popular collections as fallback', 'warning');
                                try {
                                    response = await fetch('https://api.codetabs.com/v1/proxy?quest=https://api-mainnet.magiceden.dev/v2/marketplace/popular_collections', {
                                        method: 'GET',
                                        headers: {
                                            'Accept': 'application/json'
                                        }
                                    });
                                    
                                    if (response.ok) {
                                        data = await response.json();
                                    }
                                } catch (e4) {
                                    this.log('All API requests failed', 'error');
                                }
                            }
                        }
                    }
                    
                    if (data && Array.isArray(data)) {
                        const collections = data.slice(0, 20); // Show first 20
                        
                        // Fetch stats for each collection to get volume and listed count
                        this.log('Fetching detailed stats for each collection...', 'info');
                        
                        const collectionsWithStats = await Promise.all(collections.map(async (collection) => {
                            try {
                                let statsResponse = await fetch(`https://api-mainnet.magiceden.dev/v2/collections/${collection.symbol}/stats?timeWindow=24h&listingAggMode=true`, {
                                    method: 'GET',
                                    headers: {
                                        'Accept': 'application/json',
                                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                                    }
                                });
                                
                                if (!statsResponse.ok) {
                                    // Try proxy if direct request fails
                                    statsResponse = await fetch(`https://api.codetabs.com/v1/proxy?quest=https://api-mainnet.magiceden.dev/v2/collections/${collection.symbol}/stats?timeWindow=24h&listingAggMode=true`, {
                                        method: 'GET',
                                        headers: {
                                            'Accept': 'application/json'
                                        }
                                    });
                                }
                                
                                if (statsResponse.ok) {
                                    const stats = await statsResponse.json();
                                    console.log(`Stats for ${collection.symbol}:`, stats); // Debug log
                                    return {
                                        ...collection,
                                        volume1d: stats.volumeAll, // Use volumeAll for 24h volume
                                        listedCount: stats.listedCount,
                                        floorPrice: stats.floorPrice // Use floor price from stats
                                    };
                                }
                            } catch (e) {
                                // If stats fetch fails, continue with original data
                                console.log(`Failed to fetch stats for ${collection.symbol}:`, e.message);
                            }
                            return collection;
                        }));
                        
                        let html = `<b>🔥 Magic Eden Popular Collections (${data.length} total, showing first 20)</b><br>`;
                        html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                        html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Name</th><th style='padding:8px;text-align:left;'>Symbol</th><th style='padding:8px;text-align:left;'>Floor Price</th><th style='padding:8px;text-align:left;'>Volume (24h)</th><th style='padding:8px;text-align:left;'>Listed</th></tr>`;
                        
                        collectionsWithStats.forEach((collection, index) => {
                            // Convert to SOL - API returns values in a different unit
                            // Based on the API response, it seems like values might be in a smaller unit
                            const floorPrice = collection.floorPrice ? `${(collection.floorPrice / 1000000000).toFixed(3)} SOL` : 'N/A';
                            
                            // Use stats data for volume and listed count
                            const volume = collection.volume1d ? `${(collection.volume1d / 1000000000).toFixed(1)} SOL` : 'N/A';
                            const listed = collection.listedCount || 'N/A';
                            
                            html += `<tr style='border-bottom:1px solid #444;'>`;
                            html += `<td style='padding:8px;'>${collection.name || 'N/A'}</td>`;
                            html += `<td style='padding:8px;'><span style='color: #99ccff;'>${collection.symbol || 'N/A'}</span></td>`;
                            html += `<td style='padding:8px;'>${floorPrice}</td>`;
                            html += `<td style='padding:8px;'>${volume}</td>`;
                            html += `<td style='padding:8px;'>${listed}</td>`;
                            html += `</tr>`;
                        });
                        
                        html += `</table>`;
                        
                        if (data.length > 20) {
                            html += `<br><button onclick="window.terminal.showMoreMagicEdenPopularCollections(20)" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${data.length - 20} remaining)</button>`;
                        }
                        
                        this.logHtml(html, 'output');
                        window.magicEdenPopularCollections = collectionsWithStats;
                    } else {
                        this.log('Failed to fetch Magic Eden popular collections.', 'error');
                    }
                } catch (e) {
                    this.log(`Failed to fetch Magic Eden popular collections: ${e.message}`, 'error');
                }
            }
            
            async getMagicEdenCollectionActivities(symbol) {
                try {
                    this.log(`Fetching Magic Eden activities for collection: ${symbol}`, 'info');
                    
                    let data = null;
                    let response = null;
                    
                    try {
                        response = await fetch(`https://api-mainnet.magiceden.dev/v2/collections/${symbol}/activities`, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                            }
                        });
                        
                        if (response.ok) {
                            data = await response.json();
                        }
                    } catch (e) {
                        this.log('Direct API request failed, trying proxy...', 'warning');
                        try {
                            response = await fetch(`https://api.codetabs.com/v1/proxy?quest=https://api-mainnet.magiceden.dev/v2/collections/${symbol}/activities`, {
                                method: 'GET',
                                headers: {
                                    'Accept': 'application/json'
                                }
                            });
                            
                            if (response.ok) {
                                data = await response.json();
                            }
                        } catch (e2) {
                            this.log('Proxy request also failed', 'warning');
                        }
                    }
                    
                    if (data && Array.isArray(data)) {
                        const activities = data.slice(0, 20); // Show first 20
                        
                        let html = `<b>📊 Magic Eden Activities for ${symbol} (${data.length} total, showing first 20)</b><br>`;
                        html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                        html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Type</th><th style='padding:8px;text-align:left;'>Price</th><th style='padding:8px;text-align:left;'>Token</th><th style='padding:8px;text-align:left;'>Time</th><th style='padding:8px;text-align:left;'>Buyer/Seller</th></tr>`;
                        
                        activities.forEach((activity, index) => {
                            const type = activity.type || 'N/A';
                            const price = activity.price ? `${activity.price} SOL` : 'N/A';
                            const token = activity.tokenMint ? activity.tokenMint.substring(0, 8) + '...' : 'N/A';
                            const time = activity.blockTime ? new Date(activity.blockTime * 1000).toLocaleString() : 'N/A';
                            const buyer = activity.buyer ? activity.buyer.substring(0, 8) + '...' : 'N/A';
                            const seller = activity.seller ? activity.seller.substring(0, 8) + '...' : 'N/A';
                            
                            html += `<tr style='border-bottom:1px solid #444;'>`;
                            html += `<td style='padding:8px;'><span style='color: #99ccff;'>${type}</span></td>`;
                            html += `<td style='padding:8px;'>${price}</td>`;
                            html += `<td style='padding:8px;'>${token}</td>`;
                            html += `<td style='padding:8px;'>${time}</td>`;
                            html += `<td style='padding:8px;'>${buyer} / ${seller}</td>`;
                            html += `</tr>`;
                        });
                        
                        html += `</table>`;
                        
                        if (data.length > 20) {
                            html += `<br><button onclick="window.terminal.showMoreMagicEdenActivities('${symbol}', 20)" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${data.length - 20} remaining)</button>`;
                        }
                        
                        this.logHtml(html, 'output');
                        window.magicEdenActivities = data;
                    } else {
                        this.log(`Failed to fetch activities for collection: ${symbol}`, 'error');
                    }
                } catch (e) {
                    this.log(`Failed to fetch Magic Eden activities: ${e.message}`, 'error');
                }
            }
            
            // Helper functions for "Show More" buttons
            showMoreMagicEdenCollections(currentCount) {
                if (!window.magicEdenCollections) {
                    this.log('No collections available.', 'warning');
                    return;
                }
                
                const nextBatch = Math.min(currentCount + 20, window.magicEdenCollections.length);
                const collections = window.magicEdenCollections.slice(0, nextBatch);
                
                let html = `<b>🎨 Magic Eden Collections (${window.magicEdenCollections.length} total, showing ${nextBatch})</b><br>`;
                html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Name</th><th style='padding:8px;text-align:left;'>Symbol</th><th style='padding:8px;text-align:left;'>Floor Price</th><th style='padding:8px;text-align:left;'>Listed</th><th style='padding:8px;text-align:left;'>Supply</th></tr>`;
                
                collections.forEach((collection, index) => {
                    const floorPrice = collection.floorPrice ? `${collection.floorPrice} SOL` : 'N/A';
                    const listed = collection.listedCount || 'N/A';
                    const supply = collection.supply || 'N/A';
                    
                    html += `<tr style='border-bottom:1px solid #444;'>`;
                    html += `<td style='padding:8px;'>${collection.name || 'N/A'}</td>`;
                    html += `<td style='padding:8px;'><span style='color: #99ccff;'>${collection.symbol || 'N/A'}</span></td>`;
                    html += `<td style='padding:8px;'>${floorPrice}</td>`;
                    html += `<td style='padding:8px;'>${listed}</td>`;
                    html += `<td style='padding:8px;'>${supply}</td>`;
                    html += `</tr>`;
                });
                
                html += `</table>`;
                
                if (nextBatch < window.magicEdenCollections.length) {
                    html += `<br><button onclick="window.terminal.showMoreMagicEdenCollections(${nextBatch})" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${window.magicEdenCollections.length - nextBatch} remaining)</button>`;
                }
                
                this.logHtml(html, 'output');
            }
            
            showMoreMagicEdenPopularCollections(currentCount) {
                if (!window.magicEdenPopularCollections) {
                    this.log('No popular collections available.', 'warning');
                    return;
                }
                
                const nextBatch = Math.min(currentCount + 20, window.magicEdenPopularCollections.length);
                const collections = window.magicEdenPopularCollections.slice(0, nextBatch);
                
                let html = `<b>🔥 Magic Eden Popular Collections (${window.magicEdenPopularCollections.length} total, showing ${nextBatch})</b><br>`;
                html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Name</th><th style='padding:8px;text-align:left;'>Symbol</th><th style='padding:8px;text-align:left;'>Floor Price</th><th style='padding:8px;text-align:left;'>Volume</th><th style='padding:8px;text-align:left;'>Listed</th></tr>`;
                
                collections.forEach((collection, index) => {
                    // Convert lamports to SOL (1 SOL = 1,000,000,000 lamports)
                    const floorPrice = collection.floorPrice ? `${(collection.floorPrice / 1000000000).toFixed(3)} SOL` : 'N/A';
                    
                    // Use stats data for volume and listed count
                    const volume = collection.volume1d ? `${(collection.volume1d / 1000000000).toFixed(1)} SOL` : 'N/A';
                    const listed = collection.listedCount || 'N/A';
                    
                    html += `<tr style='border-bottom:1px solid #444;'>`;
                    html += `<td style='padding:8px;'>${collection.name || 'N/A'}</td>`;
                    html += `<td style='padding:8px;'><span style='color: #99ccff;'>${collection.symbol || 'N/A'}</span></td>`;
                    html += `<td style='padding:8px;'>${floorPrice}</td>`;
                    html += `<td style='padding:8px;'>${volume}</td>`;
                    html += `<td style='padding:8px;'>${listed}</td>`;
                    html += `</tr>`;
                });
                
                html += `</table>`;
                
                if (nextBatch < window.magicEdenPopularCollections.length) {
                    html += `<br><button onclick="window.terminal.showMoreMagicEdenPopularCollections(${nextBatch})" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${window.magicEdenPopularCollections.length - nextBatch} remaining)</button>`;
                }
                
                this.logHtml(html, 'output');
            }
            
            showMoreMagicEdenActivities(symbol, currentCount) {
                if (!window.magicEdenActivities) {
                    this.log('No activities available.', 'warning');
                    return;
                }
                
                const nextBatch = Math.min(currentCount + 20, window.magicEdenActivities.length);
                const activities = window.magicEdenActivities.slice(0, nextBatch);
                
                let html = `<b>📊 Magic Eden Activities for ${symbol} (${window.magicEdenActivities.length} total, showing ${nextBatch})</b><br>`;
                html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Type</th><th style='padding:8px;text-align:left;'>Price</th><th style='padding:8px;text-align:left;'>Token</th><th style='padding:8px;text-align:left;'>Time</th><th style='padding:8px;text-align:left;'>Buyer/Seller</th></tr>`;
                
                activities.forEach((activity, index) => {
                    const type = activity.type || 'N/A';
                    const price = activity.price ? `${activity.price} SOL` : 'N/A';
                    const token = activity.tokenMint ? activity.tokenMint.substring(0, 8) + '...' : 'N/A';
                    const time = activity.blockTime ? new Date(activity.blockTime * 1000).toLocaleString() : 'N/A';
                    const buyer = activity.buyer ? activity.buyer.substring(0, 8) + '...' : 'N/A';
                    const seller = activity.seller ? activity.seller.substring(0, 8) + '...' : 'N/A';
                    
                    html += `<tr style='border-bottom:1px solid #444;'>`;
                    html += `<td style='padding:8px;'><span style='color: #99ccff;'>${type}</span></td>`;
                    html += `<td style='padding:8px;'>${price}</td>`;
                    html += `<td style='padding:8px;'>${token}</td>`;
                    html += `<td style='padding:8px;'>${time}</td>`;
                    html += `<td style='padding:8px;'>${buyer} / ${seller}</td>`;
                    html += `</tr>`;
                });
                
                html += `</table>`;
                
                if (nextBatch < window.magicEdenActivities.length) {
                    html += `<br><button onclick="window.terminal.showMoreMagicEdenActivities('${symbol}', ${nextBatch})" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${window.magicEdenActivities.length - nextBatch} remaining)</button>`;
                }
                
                this.logHtml(html, 'output');
            }
        }

        // Add this helper function to fund the Omega wallet via relayer
        async function fundOmegaWallet(address) {
            try {
                const response = await fetch(`${RELAYER_URL}/fund`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ address, amount: '0.1' })
                });
                const data = await response.json();
                if (data.success) {
                    window.terminal.log(`✅ Your wallet is being funded! Tx: ${data.txHash}`, 'success');
                    window.terminal.log('Please wait a few seconds before using your wallet.', 'info');
                } else {
                    window.terminal.log('❌ Funding failed: ' + (data.error || 'Unknown error'), 'error');
                }
            } catch (err) {
                window.terminal.log('❌ Funding request failed: ' + err.message, 'error');
            }
        }

        // Nuclear option: Completely block Phantom and force MetaMask
        (function() {
            console.log('🚨 PHANTOM BLOCKER: Starting aggressive Phantom blocking...');
            
            // Store original providers before any manipulation
            const originalProviders = window.ethereum?.providers || [];
            console.log('Original providers:', originalProviders.map(p => ({ isMetaMask: p.isMetaMask, isPhantom: p.isPhantom })));
            
            // Immediately block Phantom at the global level
            if (window.ethereum && window.ethereum.isPhantom) {
                console.log('🚨 PHANTOM DETECTED: Blocking immediately');
                const metamaskProvider = originalProviders.find(p => p.isMetaMask);
                if (metamaskProvider) {
                    window.ethereum = metamaskProvider;
                    console.log('✅ MetaMask forced as primary provider');
                } else {
                    window.ethereum = null;
                    console.log('❌ No MetaMask available - blocking all wallets');
                }
            }
            
            if (window.ethereum && window.ethereum.providers && Array.isArray(window.ethereum.providers)) {
                const metamaskProvider = window.ethereum.providers.find(p => p.isMetaMask);
                const phantomProvider = window.ethereum.providers.find(p => p.isPhantom);
                
                console.log('Found providers:', { 
                    metamask: !!metamaskProvider, 
                    phantom: !!phantomProvider 
                });
                
                if (metamaskProvider) {
                    // Completely replace window.ethereum with MetaMask
                    window.ethereum = metamaskProvider;
                    console.log('✅ MetaMask provider selected and forced');
                    
                    // Completely disable Phantom
                    if (phantomProvider) {
                        phantomProvider.isPhantom = false;
                        phantomProvider.request = () => Promise.reject(new Error('Phantom disabled - use MetaMask'));
                        phantomProvider.send = () => Promise.reject(new Error('Phantom disabled - use MetaMask'));
                        phantomProvider.on = () => {};
                        phantomProvider.removeListener = () => {};
                        phantomProvider.isConnected = () => false;
                        phantomProvider.connect = () => Promise.reject(new Error('Phantom disabled - use MetaMask'));
                        console.log('🚫 Phantom provider completely disabled');
                    }
                } else if (phantomProvider) {
                    // Only Phantom available - block it completely
                    console.warn('🚨 Only Phantom detected - blocking connection');
                    window.ethereum = null;
                    console.log('❌ Phantom blocked - no wallet available');
                }
            }
            
            // Nuclear safety check - if we detect Phantom at any point, block it
            const checkAndBlockPhantom = () => {
                if (window.ethereum && window.ethereum.isPhantom) {
                    console.log('🚨 PHANTOM DETECTED in safety check - blocking');
                    const metamaskProvider = originalProviders.find(p => p.isMetaMask);
                    if (metamaskProvider) {
                        window.ethereum = metamaskProvider;
                        console.log('✅ MetaMask restored after Phantom detection');
                    } else {
                        window.ethereum = null;
                        console.log('❌ No MetaMask available - blocking all wallets');
                    }
                }
            };
            
            // Run safety check immediately and set up periodic checks
            checkAndBlockPhantom();
            setInterval(checkAndBlockPhantom, 500); // Check every 500ms for more aggressive blocking
            
            // Also block any attempts to restore Phantom
            const originalDefineProperty = Object.defineProperty;
            Object.defineProperty = function(obj, prop, descriptor) {
                if (obj === window && prop === 'ethereum' && descriptor.value && descriptor.value.isPhantom) {
                    console.log('🚨 BLOCKED: Attempt to restore Phantom via Object.defineProperty');
                    const metamaskProvider = originalProviders.find(p => p.isMetaMask);
                    if (metamaskProvider) {
                        descriptor.value = metamaskProvider;
                    } else {
                        descriptor.value = null;
                    }
                }
                return originalDefineProperty.call(this, obj, prop, descriptor);
            };
            
            console.log('🚨 PHANTOM BLOCKER: Setup complete');
        })();
    </script>
    <script>
    // Force cache busting by adding a version parameter
    const scriptVersion = Date.now();
    console.log('Terminal script version:', scriptVersion);
    
    // Clear any existing terminal instance
    if (window.terminal) {
        console.log('Clearing existing terminal instance');
        window.terminal = null;
    }
    
    document.addEventListener('DOMContentLoaded', function() {
        console.log('DOMContentLoaded - creating new terminal instance');
        window.terminal = new OmegaMinerTerminal();
        // init() is already called in the constructor, so we don't need to call it again
    });
    </script>
</body>
</html>
